<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>fast-refresh</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
</head>
<body>
<h1 id="fast-refresh">Fast Refresh</h1>
<details open>
<summary><b>Examples</b></summary>
<ul>
<li>
<a href="https://github.com/vercel/next.js/tree/canary/examples/fast-refresh-demo">Fast Refresh Demo</a>
</li>
</ul>
</details>
<p>Fast Refresh is a Next.js feature that gives you instantaneous feedback on edits made to your React components. Fast Refresh is enabled by default in all Next.js applications on <strong>9.4 or newer</strong>. With Next.js Fast Refresh enabled, most edits should be visible within a second, <strong>without losing component state</strong>.</p>
<h2 id="how-it-works">How It Works</h2>
<ul>
<li>If you edit a file that <strong>only exports React component(s)</strong>, Fast Refresh will update the code only for that file, and re-render your component. You can edit anything in that file, including styles, rendering logic, event handlers, or effects.</li>
<li>If you edit a file with exports that <em>aren’t</em> React components, Fast Refresh will re-run both that file, and the other files importing it. So if both <code>Button.js</code> and <code>Modal.js</code> import <code>theme.js</code>, editing <code>theme.js</code> will update both components.</li>
<li>Finally, if you <strong>edit a file</strong> that’s <strong>imported by files outside of the React tree</strong>, Fast Refresh <strong>will fall back to doing a full reload</strong>. You might have a file which renders a React component but also exports a value that is imported by a <strong>non-React component</strong>. For example, maybe your component also exports a constant, and a non-React utility file imports it. In that case, consider migrating the constant to a separate file and importing it into both files. This will re-enable Fast Refresh to work. Other cases can usually be solved in a similar way.</li>
</ul>
<h2 id="error-resilience">Error Resilience</h2>
<h3 id="syntax-errors">Syntax Errors</h3>
<p>If you make a syntax error during development, you can fix it and save the file again. The error will disappear automatically, so you won’t need to reload the app. <strong>You will not lose component state</strong>.</p>
<h3 id="runtime-errors">Runtime Errors</h3>
<p>If you make a mistake that leads to a runtime error inside your component, you’ll be greeted with a contextual overlay. Fixing the error will automatically dismiss the overlay, without reloading the app.</p>
<p>Component state will be retained if the error did not occur during rendering. If the error did occur during rendering, React will remount your application using the updated code.</p>
<p>If you have <a href="https://reactjs.org/docs/error-boundaries.html">error boundaries</a> in your app (which is a good idea for graceful failures in production), they will retry rendering on the next edit after a rendering error. This means having an error boundary can prevent you from always getting reset to the root app state. However, keep in mind that error boundaries shouldn’t be <em>too</em> granular. They are used by React in production, and should always be designed intentionally.</p>
<h2 id="limitations">Limitations</h2>
<p>Fast Refresh tries to preserve local React state in the component you’re editing, but only if it’s safe to do so. Here’s a few reasons why you might see local state being reset on every edit to a file:</p>
<ul>
<li>Local state is not preserved for class components (only function components and Hooks preserve state).</li>
<li>The file you’re editing might have <em>other</em> exports in addition to a React component.</li>
<li>Sometimes, a file would export the result of calling higher-order component like <code>HOC(WrappedComponent)</code>. If the returned component is a class, state will be reset.</li>
<li>Anonymous arrow functions like <code>export default () =&gt; &lt;div /&gt;;</code> cause Fast Refresh to not preserve local component state. For large codebases you can use our <a href="/docs/advanced-features/codemods.md#name-default-component"><code>name-default-component</code> codemod</a>.</li>
</ul>
<p>As more of your codebase moves to function components and Hooks, you can expect state to be preserved in more cases.</p>
<h2 id="tips">Tips</h2>
<ul>
<li>Fast Refresh preserves React local state in function components (and Hooks) by default.</li>
<li>Sometimes you might want to <em>force</em> the state to be reset, and a component to be remounted. For example, this can be handy if you’re tweaking an animation that only happens on mount. To do this, you can add <code>// @refresh reset</code> anywhere in the file you’re editing. This directive is local to the file, and instructs Fast Refresh to remount components defined in that file on every edit.</li>
<li>You can put <code>console.log</code> or <code>debugger;</code> into the components you edit during development.</li>
</ul>
<h2 id="fast-refresh-and-hooks">Fast Refresh and Hooks</h2>
<p>When possible, Fast Refresh attempts to preserve the state of your component between edits. In particular, <code>useState</code> and <code>useRef</code> preserve their previous values as long as you don’t change their arguments or the order of the Hook calls.</p>
<p>Hooks with dependencies—such as <code>useEffect</code>, <code>useMemo</code>, and <code>useCallback</code>—will <em>always</em> update during Fast Refresh. Their list of dependencies will be ignored while Fast Refresh is happening.</p>
<p>For example, when you edit <code>useMemo(() =&gt; x * 2, [x])</code> to <code>useMemo(() =&gt; x * 10, [x])</code>, it will re-run even though <code>x</code> (the dependency) has not changed. If React didn’t do that, your edit wouldn’t reflect on the screen!</p>
<p>Sometimes, this can lead to unexpected results. For example, even a <code>useEffect</code> with an empty array of dependencies would still re-run once during Fast Refresh.</p>
<p>However, writing code resilient to occasional re-running of <code>useEffect</code> is a good practice even without Fast Refresh. It will make it easier for you to introduce new dependencies to it later on and it’s enforced by <a href="/docs/api-reference/next.config.js/react-strict-mode.md">React Strict Mode</a>, which we highly recommend enabling.</p>
</body>
</html>
