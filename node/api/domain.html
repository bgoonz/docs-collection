<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <meta charset="utf-8" />
    <meta name="generator" content="pandoc" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=yes"
    />
    <title>domain</title>
    <style type="text/css">
      code {
        white-space: pre-wrap;
      }
      span.smallcaps {
        font-variant: small-caps;
      }
      span.underline {
        text-decoration: underline;
      }
      div.column {
        display: inline-block;
        vertical-align: top;
        width: 50%;
      }
    </style>
    <style type="text/css">
      a.sourceLine {
        display: inline-block;
        line-height: 1.25;
      }
      a.sourceLine {
        pointer-events: none;
        color: inherit;
        text-decoration: inherit;
      }
      a.sourceLine:empty {
        height: 1.2em;
      }
      .sourceCode {
        overflow: visible;
      }
      code.sourceCode {
        white-space: pre;
        position: relative;
      }
      div.sourceCode {
        margin: 1em 0;
      }
      pre.sourceCode {
        margin: 0;
      }
      @media screen {
        div.sourceCode {
          overflow: auto;
        }
      }
      @media print {
        code.sourceCode {
          white-space: pre-wrap;
        }
        a.sourceLine {
          text-indent: -1em;
          padding-left: 1em;
        }
      }
      pre.numberSource a.sourceLine {
        position: relative;
        left: -4em;
      }
      pre.numberSource a.sourceLine::before {
        content: attr(title);
        position: relative;
        left: -1em;
        text-align: right;
        vertical-align: baseline;
        border: none;
        pointer-events: all;
        display: inline-block;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        -khtml-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        padding: 0 4px;
        width: 4em;
        color: #aaaaaa;
      }
      pre.numberSource {
        margin-left: 3em;
        border-left: 1px solid #aaaaaa;
        padding-left: 4px;
      }
      div.sourceCode {
      }
      @media screen {
        a.sourceLine::before {
          text-decoration: underline;
        }
      }
      code span.al {
        color: #ff0000;
        font-weight: bold;
      } /* Alert */
      code span.an {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* Annotation */
      code span.at {
        color: #7d9029;
      } /* Attribute */
      code span.bn {
        color: #40a070;
      } /* BaseN */
      code span.bu {
      } /* BuiltIn */
      code span.cf {
        color: #007020;
        font-weight: bold;
      } /* ControlFlow */
      code span.ch {
        color: #4070a0;
      } /* Char */
      code span.cn {
        color: #880000;
      } /* Constant */
      code span.co {
        color: #60a0b0;
        font-style: italic;
      } /* Comment */
      code span.cv {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* CommentVar */
      code span.do {
        color: #ba2121;
        font-style: italic;
      } /* Documentation */
      code span.dt {
        color: #902000;
      } /* DataType */
      code span.dv {
        color: #40a070;
      } /* DecVal */
      code span.er {
        color: #ff0000;
        font-weight: bold;
      } /* Error */
      code span.ex {
      } /* Extension */
      code span.fl {
        color: #40a070;
      } /* Float */
      code span.fu {
        color: #06287e;
      } /* Function */
      code span.im {
      } /* Import */
      code span.in {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* Information */
      code span.kw {
        color: #007020;
        font-weight: bold;
      } /* Keyword */
      code span.op {
        color: #666666;
      } /* Operator */
      code span.ot {
        color: #007020;
      } /* Other */
      code span.pp {
        color: #bc7a00;
      } /* Preprocessor */
      code span.sc {
        color: #4070a0;
      } /* SpecialChar */
      code span.ss {
        color: #bb6688;
      } /* SpecialString */
      code span.st {
        color: #4070a0;
      } /* String */
      code span.va {
        color: #19177c;
      } /* Variable */
      code span.vs {
        color: #4070a0;
      } /* VerbatimString */
      code span.wa {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* Warning */
    </style>
  </head>
  <body>
    <h1 id="domain">Domain</h1>
    <!-- YAML
deprecated: v1.4.2
changes:
  - version: v8.8.0
    pr-url: https://github.com/nodejs/node/pull/15695
    description: Any `Promise`s created in VM contexts no longer have a
                 `.domain` property. Their handlers are still executed in the
                 proper domain, however, and `Promise`s created in the main
                 context still possess a `.domain` property.
  - version: v8.0.0
    pr-url: https://github.com/nodejs/node/pull/12489
    description: Handlers for `Promise`s are now invoked in the domain in which
                 the first promise of a chain was created.
-->
    <!--introduced_in=v0.10.0-->
    <blockquote>
      <p>Stability: 0 - Deprecated</p>
    </blockquote>
    <!-- source_link=lib/domain.js -->
    <p>
      <strong>This module is pending deprecation.</strong> Once a replacement
      API has been finalized, this module will be fully deprecated. Most
      developers should <strong>not</strong> have cause to use this module.
      Users who absolutely must have the functionality that domains provide may
      rely on it for the time being but should expect to have to migrate to a
      different solution in the future.
    </p>
    <p>
      Domains provide a way to handle multiple different IO operations as a
      single group. If any of the event emitters or callbacks registered to a
      domain emit an <code>'error'</code> event, or throw an error, then the
      domain object will be notified, rather than losing the context of the
      error in the <code>process.on('uncaughtException')</code> handler, or
      causing the program to exit immediately with an error code.
    </p>
    <h2 id="warning-dont-ignore-errors">Warning: Don’t ignore errors!</h2>
    <!-- type=misc -->
    <p>
      Domain error handlers are not a substitute for closing down a process when
      an error occurs.
    </p>
    <p>
      By the very nature of how
      <a
        href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/throw"
        ><code>throw</code></a
      >
      works in JavaScript, there is almost never any way to safely “pick up
      where it left off”, without leaking references, or creating some other
      sort of undefined brittle state.
    </p>
    <p>
      The safest way to respond to a thrown error is to shut down the process.
      Of course, in a normal web server, there may be many open connections, and
      it is not reasonable to abruptly shut those down because an error was
      triggered by someone else.
    </p>
    <p>
      The better approach is to send an error response to the request that
      triggered the error, while letting the others finish in their normal time,
      and stop listening for new requests in that worker.
    </p>
    <p>
      In this way, <code>domain</code> usage goes hand-in-hand with the cluster
      module, since the primary process can fork a new worker when a worker
      encounters an error. For Node.js programs that scale to multiple machines,
      the terminating proxy or service registry can take note of the failure,
      and react accordingly.
    </p>
    <p>For example, this is not a good idea:</p>
    <div class="sourceCode" id="cb1">
      <pre
        class="sourceCode js"
      ><code class="sourceCode javascript"><a class="sourceLine" id="cb1-1" title="1"><span class="co">// XXX </span><span class="al">WARNING</span><span class="co">! BAD IDEA!</span></a>
<a class="sourceLine" id="cb1-2" title="2"></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="kw">const</span> d <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;domain&#39;</span>).<span class="at">create</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb1-4" title="4"><span class="va">d</span>.<span class="at">on</span>(<span class="st">&#39;error&#39;</span><span class="op">,</span> (er) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb1-5" title="5">  <span class="co">// The error won&#39;t crash the process, but what it does is worse!</span></a>
<a class="sourceLine" id="cb1-6" title="6">  <span class="co">// Though we&#39;ve prevented abrupt process restarting, we are leaking</span></a>
<a class="sourceLine" id="cb1-7" title="7">  <span class="co">// a lot of resources if this ever happens.</span></a>
<a class="sourceLine" id="cb1-8" title="8">  <span class="co">// This is no better than process.on(&#39;uncaughtException&#39;)!</span></a>
<a class="sourceLine" id="cb1-9" title="9">  <span class="va">console</span>.<span class="at">log</span>(<span class="vs">`error, but oh well </span><span class="sc">${</span><span class="va">er</span>.<span class="at">message</span><span class="sc">}</span><span class="vs">`</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb1-10" title="10"><span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb1-11" title="11"><span class="va">d</span>.<span class="at">run</span>(() <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb1-12" title="12">  <span class="at">require</span>(<span class="st">&#39;http&#39;</span>).<span class="at">createServer</span>((req<span class="op">,</span> res) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb1-13" title="13">    <span class="at">handleRequest</span>(req<span class="op">,</span> res)<span class="op">;</span></a>
<a class="sourceLine" id="cb1-14" title="14">  <span class="op">}</span>).<span class="at">listen</span>(PORT)<span class="op">;</span></a>
<a class="sourceLine" id="cb1-15" title="15"><span class="op">}</span>)<span class="op">;</span></a></code></pre>
    </div>
    <p>
      By using the context of a domain, and the resilience of separating our
      program into multiple worker processes, we can react more appropriately,
      and handle errors with much greater safety.
    </p>
    <div class="sourceCode" id="cb2">
      <pre
        class="sourceCode js"
      ><code class="sourceCode javascript"><a class="sourceLine" id="cb2-1" title="1"><span class="co">// Much better!</span></a>
<a class="sourceLine" id="cb2-2" title="2"></a>
<a class="sourceLine" id="cb2-3" title="3"><span class="kw">const</span> cluster <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;cluster&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb2-4" title="4"><span class="kw">const</span> PORT <span class="op">=</span> <span class="op">+</span><span class="va">process</span>.<span class="va">env</span>.<span class="at">PORT</span> <span class="op">||</span> <span class="dv">1337</span><span class="op">;</span></a>
<a class="sourceLine" id="cb2-5" title="5"></a>
<a class="sourceLine" id="cb2-6" title="6"><span class="cf">if</span> (<span class="va">cluster</span>.<span class="at">isPrimary</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb2-7" title="7">  <span class="co">// A more realistic scenario would have more than 2 workers,</span></a>
<a class="sourceLine" id="cb2-8" title="8">  <span class="co">// and perhaps not put the primary and worker in the same file.</span></a>
<a class="sourceLine" id="cb2-9" title="9">  <span class="co">//</span></a>
<a class="sourceLine" id="cb2-10" title="10">  <span class="co">// It is also possible to get a bit fancier about logging, and</span></a>
<a class="sourceLine" id="cb2-11" title="11">  <span class="co">// implement whatever custom logic is needed to prevent DoS</span></a>
<a class="sourceLine" id="cb2-12" title="12">  <span class="co">// attacks and other bad behavior.</span></a>
<a class="sourceLine" id="cb2-13" title="13">  <span class="co">//</span></a>
<a class="sourceLine" id="cb2-14" title="14">  <span class="co">// See the options in the cluster documentation.</span></a>
<a class="sourceLine" id="cb2-15" title="15">  <span class="co">//</span></a>
<a class="sourceLine" id="cb2-16" title="16">  <span class="co">// The important thing is that the primary does very little,</span></a>
<a class="sourceLine" id="cb2-17" title="17">  <span class="co">// increasing our resilience to unexpected errors.</span></a>
<a class="sourceLine" id="cb2-18" title="18"></a>
<a class="sourceLine" id="cb2-19" title="19">  <span class="va">cluster</span>.<span class="at">fork</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb2-20" title="20">  <span class="va">cluster</span>.<span class="at">fork</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb2-21" title="21"></a>
<a class="sourceLine" id="cb2-22" title="22">  <span class="va">cluster</span>.<span class="at">on</span>(<span class="st">&#39;disconnect&#39;</span><span class="op">,</span> (worker) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb2-23" title="23">    <span class="va">console</span>.<span class="at">error</span>(<span class="st">&#39;disconnect!&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb2-24" title="24">    <span class="va">cluster</span>.<span class="at">fork</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb2-25" title="25">  <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb2-26" title="26"></a>
<a class="sourceLine" id="cb2-27" title="27"><span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb2-28" title="28">  <span class="co">// the worker</span></a>
<a class="sourceLine" id="cb2-29" title="29">  <span class="co">//</span></a>
<a class="sourceLine" id="cb2-30" title="30">  <span class="co">// This is where we put our bugs!</span></a>
<a class="sourceLine" id="cb2-31" title="31"></a>
<a class="sourceLine" id="cb2-32" title="32">  <span class="kw">const</span> domain <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;domain&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb2-33" title="33"></a>
<a class="sourceLine" id="cb2-34" title="34">  <span class="co">// See the cluster documentation for more details about using</span></a>
<a class="sourceLine" id="cb2-35" title="35">  <span class="co">// worker processes to serve requests. How it works, caveats, etc.</span></a>
<a class="sourceLine" id="cb2-36" title="36"></a>
<a class="sourceLine" id="cb2-37" title="37">  <span class="kw">const</span> server <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;http&#39;</span>).<span class="at">createServer</span>((req<span class="op">,</span> res) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb2-38" title="38">    <span class="kw">const</span> d <span class="op">=</span> <span class="va">domain</span>.<span class="at">create</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb2-39" title="39">    <span class="va">d</span>.<span class="at">on</span>(<span class="st">&#39;error&#39;</span><span class="op">,</span> (er) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb2-40" title="40">      <span class="va">console</span>.<span class="at">error</span>(<span class="vs">`error </span><span class="sc">${</span><span class="va">er</span>.<span class="at">stack</span><span class="sc">}</span><span class="vs">`</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb2-41" title="41"></a>
<a class="sourceLine" id="cb2-42" title="42">      <span class="co">// We&#39;re in dangerous territory!</span></a>
<a class="sourceLine" id="cb2-43" title="43">      <span class="co">// By definition, something unexpected occurred,</span></a>
<a class="sourceLine" id="cb2-44" title="44">      <span class="co">// which we probably didn&#39;t want.</span></a>
<a class="sourceLine" id="cb2-45" title="45">      <span class="co">// Anything can happen now! Be very careful!</span></a>
<a class="sourceLine" id="cb2-46" title="46"></a>
<a class="sourceLine" id="cb2-47" title="47">      <span class="cf">try</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb2-48" title="48">        <span class="co">// Make sure we close down within 30 seconds</span></a>
<a class="sourceLine" id="cb2-49" title="49">        <span class="kw">const</span> killtimer <span class="op">=</span> <span class="at">setTimeout</span>(() <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb2-50" title="50">          <span class="va">process</span>.<span class="at">exit</span>(<span class="dv">1</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb2-51" title="51">        <span class="op">},</span> <span class="dv">30000</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb2-52" title="52">        <span class="co">// But don&#39;t keep the process open just for that!</span></a>
<a class="sourceLine" id="cb2-53" title="53">        <span class="va">killtimer</span>.<span class="at">unref</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb2-54" title="54"></a>
<a class="sourceLine" id="cb2-55" title="55">        <span class="co">// Stop taking new requests.</span></a>
<a class="sourceLine" id="cb2-56" title="56">        <span class="va">server</span>.<span class="at">close</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb2-57" title="57"></a>
<a class="sourceLine" id="cb2-58" title="58">        <span class="co">// Let the primary know we&#39;re dead. This will trigger a</span></a>
<a class="sourceLine" id="cb2-59" title="59">        <span class="co">// &#39;disconnect&#39; in the cluster primary, and then it will fork</span></a>
<a class="sourceLine" id="cb2-60" title="60">        <span class="co">// a new worker.</span></a>
<a class="sourceLine" id="cb2-61" title="61">        <span class="va">cluster</span>.<span class="va">worker</span>.<span class="at">disconnect</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb2-62" title="62"></a>
<a class="sourceLine" id="cb2-63" title="63">        <span class="co">// Try to send an error to the request that triggered the problem</span></a>
<a class="sourceLine" id="cb2-64" title="64">        <span class="va">res</span>.<span class="at">statusCode</span> <span class="op">=</span> <span class="dv">500</span><span class="op">;</span></a>
<a class="sourceLine" id="cb2-65" title="65">        <span class="va">res</span>.<span class="at">setHeader</span>(<span class="st">&#39;content-type&#39;</span><span class="op">,</span> <span class="st">&#39;text/plain&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb2-66" title="66">        <span class="va">res</span>.<span class="at">end</span>(<span class="st">&#39;Oops, there was a problem!</span><span class="sc">\n</span><span class="st">&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb2-67" title="67">      <span class="op">}</span> <span class="cf">catch</span> (er2) <span class="op">{</span></a>
<a class="sourceLine" id="cb2-68" title="68">        <span class="co">// Oh well, not much we can do at this point.</span></a>
<a class="sourceLine" id="cb2-69" title="69">        <span class="va">console</span>.<span class="at">error</span>(<span class="vs">`Error sending 500! </span><span class="sc">${</span><span class="va">er2</span>.<span class="at">stack</span><span class="sc">}</span><span class="vs">`</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb2-70" title="70">      <span class="op">}</span></a>
<a class="sourceLine" id="cb2-71" title="71">    <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb2-72" title="72"></a>
<a class="sourceLine" id="cb2-73" title="73">    <span class="co">// Because req and res were created before this domain existed,</span></a>
<a class="sourceLine" id="cb2-74" title="74">    <span class="co">// we need to explicitly add them.</span></a>
<a class="sourceLine" id="cb2-75" title="75">    <span class="co">// See the explanation of implicit vs explicit binding below.</span></a>
<a class="sourceLine" id="cb2-76" title="76">    <span class="va">d</span>.<span class="at">add</span>(req)<span class="op">;</span></a>
<a class="sourceLine" id="cb2-77" title="77">    <span class="va">d</span>.<span class="at">add</span>(res)<span class="op">;</span></a>
<a class="sourceLine" id="cb2-78" title="78"></a>
<a class="sourceLine" id="cb2-79" title="79">    <span class="co">// Now run the handler function in the domain.</span></a>
<a class="sourceLine" id="cb2-80" title="80">    <span class="va">d</span>.<span class="at">run</span>(() <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb2-81" title="81">      <span class="at">handleRequest</span>(req<span class="op">,</span> res)<span class="op">;</span></a>
<a class="sourceLine" id="cb2-82" title="82">    <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb2-83" title="83">  <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb2-84" title="84">  <span class="va">server</span>.<span class="at">listen</span>(PORT)<span class="op">;</span></a>
<a class="sourceLine" id="cb2-85" title="85"><span class="op">}</span></a>
<a class="sourceLine" id="cb2-86" title="86"></a>
<a class="sourceLine" id="cb2-87" title="87"><span class="co">// This part is not important. Just an example routing thing.</span></a>
<a class="sourceLine" id="cb2-88" title="88"><span class="co">// Put fancy application logic here.</span></a>
<a class="sourceLine" id="cb2-89" title="89"><span class="kw">function</span> <span class="at">handleRequest</span>(req<span class="op">,</span> res) <span class="op">{</span></a>
<a class="sourceLine" id="cb2-90" title="90">  <span class="cf">switch</span> (<span class="va">req</span>.<span class="at">url</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb2-91" title="91">    <span class="cf">case</span> <span class="st">&#39;/error&#39;</span><span class="op">:</span></a>
<a class="sourceLine" id="cb2-92" title="92">      <span class="co">// We do some async stuff, and then...</span></a>
<a class="sourceLine" id="cb2-93" title="93">      <span class="at">setTimeout</span>(() <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb2-94" title="94">        <span class="co">// Whoops!</span></a>
<a class="sourceLine" id="cb2-95" title="95">        <span class="va">flerb</span>.<span class="at">bark</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb2-96" title="96">      <span class="op">},</span> timeout)<span class="op">;</span></a>
<a class="sourceLine" id="cb2-97" title="97">      <span class="cf">break</span><span class="op">;</span></a>
<a class="sourceLine" id="cb2-98" title="98">    <span class="cf">default</span><span class="op">:</span></a>
<a class="sourceLine" id="cb2-99" title="99">      <span class="va">res</span>.<span class="at">end</span>(<span class="st">&#39;ok&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb2-100" title="100">  <span class="op">}</span></a>
<a class="sourceLine" id="cb2-101" title="101"><span class="op">}</span></a></code></pre>
    </div>
    <h2 id="additions-to-error-objects">
      Additions to <code>Error</code> objects
    </h2>
    <!-- type=misc -->
    <p>
      Any time an <code>Error</code> object is routed through a domain, a few
      extra fields are added to it.
    </p>
    <ul>
      <li>
        <code>error.domain</code> The domain that first handled the error.
      </li>
      <li>
        <code>error.domainEmitter</code> The event emitter that emitted an
        <code>'error'</code> event with the error object.
      </li>
      <li>
        <code>error.domainBound</code> The callback function which was bound to
        the domain, and passed an error as its first argument.
      </li>
      <li>
        <code>error.domainThrown</code> A boolean indicating whether the error
        was thrown, emitted, or passed to a bound callback function.
      </li>
    </ul>
    <h2 id="implicit-binding">Implicit binding</h2>
    <!--type=misc-->
    <p>
      If domains are in use, then all <strong>new</strong>
      <code>EventEmitter</code> objects (including Stream objects, requests,
      responses, etc.) will be implicitly bound to the active domain at the time
      of their creation.
    </p>
    <p>
      Additionally, callbacks passed to lowlevel event loop requests (such as to
      <code>fs.open()</code>, or other callback-taking methods) will
      automatically be bound to the active domain. If they throw, then the
      domain will catch the error.
    </p>
    <p>
      In order to prevent excessive memory usage, <code>Domain</code> objects
      themselves are not implicitly added as children of the active domain. If
      they were, then it would be too easy to prevent request and response
      objects from being properly garbage collected.
    </p>
    <p>
      To nest <code>Domain</code> objects as children of a parent
      <code>Domain</code> they must be explicitly added.
    </p>
    <p>
      Implicit binding routes thrown errors and <code>'error'</code> events to
      the <code>Domain</code>’s <code>'error'</code> event, but does not
      register the <code>EventEmitter</code> on the <code>Domain</code>.
      Implicit binding only takes care of thrown errors and
      <code>'error'</code> events.
    </p>
    <h2 id="explicit-binding">Explicit binding</h2>
    <!--type=misc-->
    <p>
      Sometimes, the domain in use is not the one that ought to be used for a
      specific event emitter. Or, the event emitter could have been created in
      the context of one domain, but ought to instead be bound to some other
      domain.
    </p>
    <p>
      For example, there could be one domain in use for an HTTP server, but
      perhaps we would like to have a separate domain to use for each request.
    </p>
    <p>That is possible via explicit binding.</p>
    <div class="sourceCode" id="cb3">
      <pre
        class="sourceCode js"
      ><code class="sourceCode javascript"><a class="sourceLine" id="cb3-1" title="1"><span class="co">// Create a top-level domain for the server</span></a>
<a class="sourceLine" id="cb3-2" title="2"><span class="kw">const</span> domain <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;domain&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb3-3" title="3"><span class="kw">const</span> http <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;http&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb3-4" title="4"><span class="kw">const</span> serverDomain <span class="op">=</span> <span class="va">domain</span>.<span class="at">create</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb3-5" title="5"></a>
<a class="sourceLine" id="cb3-6" title="6"><span class="va">serverDomain</span>.<span class="at">run</span>(() <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb3-7" title="7">  <span class="co">// Server is created in the scope of serverDomain</span></a>
<a class="sourceLine" id="cb3-8" title="8">  <span class="va">http</span>.<span class="at">createServer</span>((req<span class="op">,</span> res) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb3-9" title="9">    <span class="co">// Req and res are also created in the scope of serverDomain</span></a>
<a class="sourceLine" id="cb3-10" title="10">    <span class="co">// however, we&#39;d prefer to have a separate domain for each request.</span></a>
<a class="sourceLine" id="cb3-11" title="11">    <span class="co">// create it first thing, and add req and res to it.</span></a>
<a class="sourceLine" id="cb3-12" title="12">    <span class="kw">const</span> reqd <span class="op">=</span> <span class="va">domain</span>.<span class="at">create</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb3-13" title="13">    <span class="va">reqd</span>.<span class="at">add</span>(req)<span class="op">;</span></a>
<a class="sourceLine" id="cb3-14" title="14">    <span class="va">reqd</span>.<span class="at">add</span>(res)<span class="op">;</span></a>
<a class="sourceLine" id="cb3-15" title="15">    <span class="va">reqd</span>.<span class="at">on</span>(<span class="st">&#39;error&#39;</span><span class="op">,</span> (er) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb3-16" title="16">      <span class="va">console</span>.<span class="at">error</span>(<span class="st">&#39;Error&#39;</span><span class="op">,</span> er<span class="op">,</span> <span class="va">req</span>.<span class="at">url</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb3-17" title="17">      <span class="cf">try</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb3-18" title="18">        <span class="va">res</span>.<span class="at">writeHead</span>(<span class="dv">500</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb3-19" title="19">        <span class="va">res</span>.<span class="at">end</span>(<span class="st">&#39;Error occurred, sorry.&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb3-20" title="20">      <span class="op">}</span> <span class="cf">catch</span> (er2) <span class="op">{</span></a>
<a class="sourceLine" id="cb3-21" title="21">        <span class="va">console</span>.<span class="at">error</span>(<span class="st">&#39;Error sending 500&#39;</span><span class="op">,</span> er2<span class="op">,</span> <span class="va">req</span>.<span class="at">url</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb3-22" title="22">      <span class="op">}</span></a>
<a class="sourceLine" id="cb3-23" title="23">    <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb3-24" title="24">  <span class="op">}</span>).<span class="at">listen</span>(<span class="dv">1337</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb3-25" title="25"><span class="op">}</span>)<span class="op">;</span></a></code></pre>
    </div>
    <h2 id="domain.create"><code>domain.create()</code></h2>
    <ul>
      <li>Returns: {Domain}</li>
    </ul>
    <h2 id="class-domain">Class: <code>Domain</code></h2>
    <ul>
      <li>Extends: {EventEmitter}</li>
    </ul>
    <p>
      The <code>Domain</code> class encapsulates the functionality of routing
      errors and uncaught exceptions to the active <code>Domain</code> object.
    </p>
    <p>
      To handle the errors that it catches, listen to its
      <code>'error'</code> event.
    </p>
    <h3 id="domain.members"><code>domain.members</code></h3>
    <ul>
      <li>{Array}</li>
    </ul>
    <p>
      An array of timers and event emitters that have been explicitly added to
      the domain.
    </p>
    <h3 id="domain.addemitter"><code>domain.add(emitter)</code></h3>
    <ul>
      <li>
        <code>emitter</code> {EventEmitter|Timer} emitter or timer to be added
        to the domain
      </li>
    </ul>
    <p>
      Explicitly adds an emitter to the domain. If any event handlers called by
      the emitter throw an error, or if the emitter emits an
      <code>'error'</code> event, it will be routed to the domain’s
      <code>'error'</code> event, just like with implicit binding.
    </p>
    <p>
      This also works with timers that are returned from
      <a href="timers.md#timers_setinterval_callback_delay_args"
        ><code>setInterval()</code></a
      >
      and
      <a href="timers.md#timers_settimeout_callback_delay_args"
        ><code>setTimeout()</code></a
      >. If their callback function throws, it will be caught by the domain
      <code>'error'</code> handler.
    </p>
    <p>
      If the Timer or <code>EventEmitter</code> was already bound to a domain,
      it is removed from that one, and bound to this one instead.
    </p>
    <h3 id="domain.bindcallback"><code>domain.bind(callback)</code></h3>
    <ul>
      <li><code>callback</code> {Function} The callback function</li>
      <li>Returns: {Function} The bound function</li>
    </ul>
    <p>
      The returned function will be a wrapper around the supplied callback
      function. When the returned function is called, any errors that are thrown
      will be routed to the domain’s <code>'error'</code> event.
    </p>
    <div class="sourceCode" id="cb4">
      <pre
        class="sourceCode js"
      ><code class="sourceCode javascript"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">const</span> d <span class="op">=</span> <span class="va">domain</span>.<span class="at">create</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb4-2" title="2"></a>
<a class="sourceLine" id="cb4-3" title="3"><span class="kw">function</span> <span class="at">readSomeFile</span>(filename<span class="op">,</span> cb) <span class="op">{</span></a>
<a class="sourceLine" id="cb4-4" title="4">  <span class="va">fs</span>.<span class="at">readFile</span>(filename<span class="op">,</span> <span class="st">&#39;utf8&#39;</span><span class="op">,</span> <span class="va">d</span>.<span class="at">bind</span>((er<span class="op">,</span> data) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb4-5" title="5">    <span class="co">// If this throws, it will also be passed to the domain.</span></a>
<a class="sourceLine" id="cb4-6" title="6">    <span class="cf">return</span> <span class="at">cb</span>(er<span class="op">,</span> data <span class="op">?</span> <span class="va">JSON</span>.<span class="at">parse</span>(data) : <span class="kw">null</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb4-7" title="7">  <span class="op">}</span>))<span class="op">;</span></a>
<a class="sourceLine" id="cb4-8" title="8"><span class="op">}</span></a>
<a class="sourceLine" id="cb4-9" title="9"></a>
<a class="sourceLine" id="cb4-10" title="10"><span class="va">d</span>.<span class="at">on</span>(<span class="st">&#39;error&#39;</span><span class="op">,</span> (er) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb4-11" title="11">  <span class="co">// An error occurred somewhere. If we throw it now, it will crash the program</span></a>
<a class="sourceLine" id="cb4-12" title="12">  <span class="co">// with the normal line number and stack message.</span></a>
<a class="sourceLine" id="cb4-13" title="13"><span class="op">}</span>)<span class="op">;</span></a></code></pre>
    </div>
    <h3 id="domain.enter"><code>domain.enter()</code></h3>
    <p>
      The <code>enter()</code> method is plumbing used by the
      <code>run()</code>, <code>bind()</code>, and
      <code>intercept()</code> methods to set the active domain. It sets
      <code>domain.active</code> and <code>process.domain</code> to the domain,
      and implicitly pushes the domain onto the domain stack managed by the
      domain module (see
      <a href="#domain_domain_exit"><code>domain.exit()</code></a> for details
      on the domain stack). The call to <code>enter()</code> delimits the
      beginning of a chain of asynchronous calls and I/O operations bound to a
      domain.
    </p>
    <p>
      Calling <code>enter()</code> changes only the active domain, and does not
      alter the domain itself. <code>enter()</code> and <code>exit()</code> can
      be called an arbitrary number of times on a single domain.
    </p>
    <h3 id="domain.exit"><code>domain.exit()</code></h3>
    <p>
      The <code>exit()</code> method exits the current domain, popping it off
      the domain stack. Any time execution is going to switch to the context of
      a different chain of asynchronous calls, it’s important to ensure that the
      current domain is exited. The call to <code>exit()</code> delimits either
      the end of or an interruption to the chain of asynchronous calls and I/O
      operations bound to a domain.
    </p>
    <p>
      If there are multiple, nested domains bound to the current execution
      context, <code>exit()</code> will exit any domains nested within this
      domain.
    </p>
    <p>
      Calling <code>exit()</code> changes only the active domain, and does not
      alter the domain itself. <code>enter()</code> and <code>exit()</code> can
      be called an arbitrary number of times on a single domain.
    </p>
    <h3 id="domain.interceptcallback">
      <code>domain.intercept(callback)</code>
    </h3>
    <ul>
      <li><code>callback</code> {Function} The callback function</li>
      <li>Returns: {Function} The intercepted function</li>
    </ul>
    <p>
      This method is almost identical to
      <a href="#domain_domain_bind_callback"
        ><code>domain.bind(callback)</code></a
      >. However, in addition to catching thrown errors, it will also intercept
      <a href="errors.md#errors_class_error"><code>Error</code></a> objects sent
      as the first argument to the function.
    </p>
    <p>
      In this way, the common
      <code>if (err) return callback(err);</code> pattern can be replaced with a
      single error handler in a single place.
    </p>
    <div class="sourceCode" id="cb5">
      <pre
        class="sourceCode js"
      ><code class="sourceCode javascript"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">const</span> d <span class="op">=</span> <span class="va">domain</span>.<span class="at">create</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb5-2" title="2"></a>
<a class="sourceLine" id="cb5-3" title="3"><span class="kw">function</span> <span class="at">readSomeFile</span>(filename<span class="op">,</span> cb) <span class="op">{</span></a>
<a class="sourceLine" id="cb5-4" title="4">  <span class="va">fs</span>.<span class="at">readFile</span>(filename<span class="op">,</span> <span class="st">&#39;utf8&#39;</span><span class="op">,</span> <span class="va">d</span>.<span class="at">intercept</span>((data) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb5-5" title="5">    <span class="co">// Note, the first argument is never passed to the</span></a>
<a class="sourceLine" id="cb5-6" title="6">    <span class="co">// callback since it is assumed to be the &#39;Error&#39; argument</span></a>
<a class="sourceLine" id="cb5-7" title="7">    <span class="co">// and thus intercepted by the domain.</span></a>
<a class="sourceLine" id="cb5-8" title="8"></a>
<a class="sourceLine" id="cb5-9" title="9">    <span class="co">// If this throws, it will also be passed to the domain</span></a>
<a class="sourceLine" id="cb5-10" title="10">    <span class="co">// so the error-handling logic can be moved to the &#39;error&#39;</span></a>
<a class="sourceLine" id="cb5-11" title="11">    <span class="co">// event on the domain instead of being repeated throughout</span></a>
<a class="sourceLine" id="cb5-12" title="12">    <span class="co">// the program.</span></a>
<a class="sourceLine" id="cb5-13" title="13">    <span class="cf">return</span> <span class="at">cb</span>(<span class="kw">null</span><span class="op">,</span> <span class="va">JSON</span>.<span class="at">parse</span>(data))<span class="op">;</span></a>
<a class="sourceLine" id="cb5-14" title="14">  <span class="op">}</span>))<span class="op">;</span></a>
<a class="sourceLine" id="cb5-15" title="15"><span class="op">}</span></a>
<a class="sourceLine" id="cb5-16" title="16"></a>
<a class="sourceLine" id="cb5-17" title="17"><span class="va">d</span>.<span class="at">on</span>(<span class="st">&#39;error&#39;</span><span class="op">,</span> (er) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb5-18" title="18">  <span class="co">// An error occurred somewhere. If we throw it now, it will crash the program</span></a>
<a class="sourceLine" id="cb5-19" title="19">  <span class="co">// with the normal line number and stack message.</span></a>
<a class="sourceLine" id="cb5-20" title="20"><span class="op">}</span>)<span class="op">;</span></a></code></pre>
    </div>
    <h3 id="domain.removeemitter"><code>domain.remove(emitter)</code></h3>
    <ul>
      <li>
        <code>emitter</code> {EventEmitter|Timer} emitter or timer to be removed
        from the domain
      </li>
    </ul>
    <p>
      The opposite of
      <a href="#domain_domain_add_emitter"><code>domain.add(emitter)</code></a
      >. Removes domain handling from the specified emitter.
    </p>
    <h3 id="domain.runfn-...args"><code>domain.run(fn[, ...args])</code></h3>
    <ul>
      <li><code>fn</code> {Function}</li>
      <li><code>...args</code> {any}</li>
    </ul>
    <p>
      Run the supplied function in the context of the domain, implicitly binding
      all event emitters, timers, and lowlevel requests that are created in that
      context. Optionally, arguments can be passed to the function.
    </p>
    <p>This is the most basic way to use a domain.</p>
    <div class="sourceCode" id="cb6">
      <pre
        class="sourceCode js"
      ><code class="sourceCode javascript"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">const</span> domain <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;domain&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb6-2" title="2"><span class="kw">const</span> fs <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;fs&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb6-3" title="3"><span class="kw">const</span> d <span class="op">=</span> <span class="va">domain</span>.<span class="at">create</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb6-4" title="4"><span class="va">d</span>.<span class="at">on</span>(<span class="st">&#39;error&#39;</span><span class="op">,</span> (er) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb6-5" title="5">  <span class="va">console</span>.<span class="at">error</span>(<span class="st">&#39;Caught error!&#39;</span><span class="op">,</span> er)<span class="op">;</span></a>
<a class="sourceLine" id="cb6-6" title="6"><span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb6-7" title="7"><span class="va">d</span>.<span class="at">run</span>(() <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb6-8" title="8">  <span class="va">process</span>.<span class="at">nextTick</span>(() <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb6-9" title="9">    <span class="at">setTimeout</span>(() <span class="kw">=&gt;</span> <span class="op">{</span> <span class="co">// Simulating some various async stuff</span></a>
<a class="sourceLine" id="cb6-10" title="10">      <span class="va">fs</span>.<span class="at">open</span>(<span class="st">&#39;non-existent file&#39;</span><span class="op">,</span> <span class="st">&#39;r&#39;</span><span class="op">,</span> (er<span class="op">,</span> fd) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb6-11" title="11">        <span class="cf">if</span> (er) <span class="cf">throw</span> er<span class="op">;</span></a>
<a class="sourceLine" id="cb6-12" title="12">        <span class="co">// proceed...</span></a>
<a class="sourceLine" id="cb6-13" title="13">      <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb6-14" title="14">    <span class="op">},</span> <span class="dv">100</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb6-15" title="15">  <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb6-16" title="16"><span class="op">}</span>)<span class="op">;</span></a></code></pre>
    </div>
    <p>
      In this example, the <code>d.on('error')</code> handler will be triggered,
      rather than crashing the program.
    </p>
    <h2 id="domains-and-promises">Domains and promises</h2>
    <p>
      As of Node.js 8.0.0, the handlers of promises are run inside the domain in
      which the call to <code>.then()</code> or <code>.catch()</code> itself was
      made:
    </p>
    <div class="sourceCode" id="cb7">
      <pre
        class="sourceCode js"
      ><code class="sourceCode javascript"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">const</span> d1 <span class="op">=</span> <span class="va">domain</span>.<span class="at">create</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb7-2" title="2"><span class="kw">const</span> d2 <span class="op">=</span> <span class="va">domain</span>.<span class="at">create</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb7-3" title="3"></a>
<a class="sourceLine" id="cb7-4" title="4"><span class="kw">let</span> p<span class="op">;</span></a>
<a class="sourceLine" id="cb7-5" title="5"><span class="va">d1</span>.<span class="at">run</span>(() <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb7-6" title="6">  p <span class="op">=</span> <span class="va">Promise</span>.<span class="at">resolve</span>(<span class="dv">42</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb7-7" title="7"><span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb7-8" title="8"></a>
<a class="sourceLine" id="cb7-9" title="9"><span class="va">d2</span>.<span class="at">run</span>(() <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb7-10" title="10">  <span class="va">p</span>.<span class="at">then</span>((v) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb7-11" title="11">    <span class="co">// running in d2</span></a>
<a class="sourceLine" id="cb7-12" title="12">  <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb7-13" title="13"><span class="op">}</span>)<span class="op">;</span></a></code></pre>
    </div>
    <p>
      A callback may be bound to a specific domain using
      <a href="#domain_domain_bind_callback"
        ><code>domain.bind(callback)</code></a
      >:
    </p>
    <div class="sourceCode" id="cb8">
      <pre
        class="sourceCode js"
      ><code class="sourceCode javascript"><a class="sourceLine" id="cb8-1" title="1"><span class="kw">const</span> d1 <span class="op">=</span> <span class="va">domain</span>.<span class="at">create</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb8-2" title="2"><span class="kw">const</span> d2 <span class="op">=</span> <span class="va">domain</span>.<span class="at">create</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb8-3" title="3"></a>
<a class="sourceLine" id="cb8-4" title="4"><span class="kw">let</span> p<span class="op">;</span></a>
<a class="sourceLine" id="cb8-5" title="5"><span class="va">d1</span>.<span class="at">run</span>(() <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb8-6" title="6">  p <span class="op">=</span> <span class="va">Promise</span>.<span class="at">resolve</span>(<span class="dv">42</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb8-7" title="7"><span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb8-8" title="8"></a>
<a class="sourceLine" id="cb8-9" title="9"><span class="va">d2</span>.<span class="at">run</span>(() <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb8-10" title="10">  <span class="va">p</span>.<span class="at">then</span>(<span class="va">p</span>.<span class="va">domain</span>.<span class="at">bind</span>((v) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb8-11" title="11">    <span class="co">// running in d1</span></a>
<a class="sourceLine" id="cb8-12" title="12">  <span class="op">}</span>))<span class="op">;</span></a>
<a class="sourceLine" id="cb8-13" title="13"><span class="op">}</span>)<span class="op">;</span></a></code></pre>
    </div>
    <p>
      Domains will not interfere with the error handling mechanisms for
      promises. In other words, no <code>'error'</code> event will be emitted
      for unhandled <code>Promise</code> rejections.
    </p>
  </body>
</html>
