<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <meta charset="utf-8" />
    <meta name="generator" content="pandoc" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=yes"
    />
    <title>modules</title>
    <style type="text/css">
      code {
        white-space: pre-wrap;
      }
      span.smallcaps {
        font-variant: small-caps;
      }
      span.underline {
        text-decoration: underline;
      }
      div.column {
        display: inline-block;
        vertical-align: top;
        width: 50%;
      }
    </style>
    <style type="text/css">
      a.sourceLine {
        display: inline-block;
        line-height: 1.25;
      }
      a.sourceLine {
        pointer-events: none;
        color: inherit;
        text-decoration: inherit;
      }
      a.sourceLine:empty {
        height: 1.2em;
      }
      .sourceCode {
        overflow: visible;
      }
      code.sourceCode {
        white-space: pre;
        position: relative;
      }
      div.sourceCode {
        margin: 1em 0;
      }
      pre.sourceCode {
        margin: 0;
      }
      @media screen {
        div.sourceCode {
          overflow: auto;
        }
      }
      @media print {
        code.sourceCode {
          white-space: pre-wrap;
        }
        a.sourceLine {
          text-indent: -1em;
          padding-left: 1em;
        }
      }
      pre.numberSource a.sourceLine {
        position: relative;
        left: -4em;
      }
      pre.numberSource a.sourceLine::before {
        content: attr(title);
        position: relative;
        left: -1em;
        text-align: right;
        vertical-align: baseline;
        border: none;
        pointer-events: all;
        display: inline-block;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        -khtml-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        padding: 0 4px;
        width: 4em;
        color: #aaaaaa;
      }
      pre.numberSource {
        margin-left: 3em;
        border-left: 1px solid #aaaaaa;
        padding-left: 4px;
      }
      div.sourceCode {
      }
      @media screen {
        a.sourceLine::before {
          text-decoration: underline;
        }
      }
      code span.al {
        color: #ff0000;
        font-weight: bold;
      } /* Alert */
      code span.an {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* Annotation */
      code span.at {
        color: #7d9029;
      } /* Attribute */
      code span.bn {
        color: #40a070;
      } /* BaseN */
      code span.bu {
      } /* BuiltIn */
      code span.cf {
        color: #007020;
        font-weight: bold;
      } /* ControlFlow */
      code span.ch {
        color: #4070a0;
      } /* Char */
      code span.cn {
        color: #880000;
      } /* Constant */
      code span.co {
        color: #60a0b0;
        font-style: italic;
      } /* Comment */
      code span.cv {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* CommentVar */
      code span.do {
        color: #ba2121;
        font-style: italic;
      } /* Documentation */
      code span.dt {
        color: #902000;
      } /* DataType */
      code span.dv {
        color: #40a070;
      } /* DecVal */
      code span.er {
        color: #ff0000;
        font-weight: bold;
      } /* Error */
      code span.ex {
      } /* Extension */
      code span.fl {
        color: #40a070;
      } /* Float */
      code span.fu {
        color: #06287e;
      } /* Function */
      code span.im {
      } /* Import */
      code span.in {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* Information */
      code span.kw {
        color: #007020;
        font-weight: bold;
      } /* Keyword */
      code span.op {
        color: #666666;
      } /* Operator */
      code span.ot {
        color: #007020;
      } /* Other */
      code span.pp {
        color: #bc7a00;
      } /* Preprocessor */
      code span.sc {
        color: #4070a0;
      } /* SpecialChar */
      code span.ss {
        color: #bb6688;
      } /* SpecialString */
      code span.st {
        color: #4070a0;
      } /* String */
      code span.va {
        color: #19177c;
      } /* Variable */
      code span.vs {
        color: #4070a0;
      } /* VerbatimString */
      code span.wa {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* Warning */
    </style>
  </head>
  <body>
    <h1 id="modules-commonjs-modules">Modules: CommonJS modules</h1>
    <!--introduced_in=v0.10.0-->
    <blockquote>
      <p>Stability: 2 - Stable</p>
    </blockquote>
    <!--name=module-->
    <p>
      In the Node.js module system, each file is treated as a separate module.
      For example, consider a file named <code>foo.js</code>:
    </p>
    <div class="sourceCode" id="cb1">
      <pre
        class="sourceCode js"
      ><code class="sourceCode javascript"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">const</span> circle <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;./circle.js&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="va">console</span>.<span class="at">log</span>(<span class="vs">`The area of a circle of radius 4 is </span><span class="sc">${</span><span class="va">circle</span>.<span class="at">area</span>(<span class="dv">4</span>)<span class="sc">}</span><span class="vs">`</span>)<span class="op">;</span></a></code></pre>
    </div>
    <p>
      On the first line, <code>foo.js</code> loads the module
      <code>circle.js</code> that is in the same directory as
      <code>foo.js</code>.
    </p>
    <p>Here are the contents of <code>circle.js</code>:</p>
    <div class="sourceCode" id="cb2">
      <pre
        class="sourceCode js"
      ><code class="sourceCode javascript"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">const</span> <span class="op">{</span> PI <span class="op">}</span> <span class="op">=</span> Math<span class="op">;</span></a>
<a class="sourceLine" id="cb2-2" title="2"></a>
<a class="sourceLine" id="cb2-3" title="3"><span class="va">exports</span>.<span class="at">area</span> <span class="op">=</span> (r) <span class="kw">=&gt;</span> PI <span class="op">*</span> r <span class="op">**</span> <span class="dv">2</span><span class="op">;</span></a>
<a class="sourceLine" id="cb2-4" title="4"></a>
<a class="sourceLine" id="cb2-5" title="5"><span class="va">exports</span>.<span class="at">circumference</span> <span class="op">=</span> (r) <span class="kw">=&gt;</span> <span class="dv">2</span> <span class="op">*</span> PI <span class="op">*</span> r<span class="op">;</span></a></code></pre>
    </div>
    <p>
      The module <code>circle.js</code> has exported the functions
      <code>area()</code> and <code>circumference()</code>. Functions and
      objects are added to the root of a module by specifying additional
      properties on the special <code>exports</code> object.
    </p>
    <p>
      Variables local to the module will be private, because the module is
      wrapped in a function by Node.js (see
      <a href="#modules_the_module_wrapper">module wrapper</a>). In this
      example, the variable <code>PI</code> is private to
      <code>circle.js</code>.
    </p>
    <p>
      The <code>module.exports</code> property can be assigned a new value (such
      as a function or object).
    </p>
    <p>
      Below, <code>bar.js</code> makes use of the <code>square</code> module,
      which exports a Square class:
    </p>
    <div class="sourceCode" id="cb3">
      <pre
        class="sourceCode js"
      ><code class="sourceCode javascript"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">const</span> Square <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;./square.js&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb3-2" title="2"><span class="kw">const</span> mySquare <span class="op">=</span> <span class="kw">new</span> <span class="at">Square</span>(<span class="dv">2</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb3-3" title="3"><span class="va">console</span>.<span class="at">log</span>(<span class="vs">`The area of mySquare is </span><span class="sc">${</span><span class="va">mySquare</span>.<span class="at">area</span>()<span class="sc">}</span><span class="vs">`</span>)<span class="op">;</span></a></code></pre>
    </div>
    <p>The <code>square</code> module is defined in <code>square.js</code>:</p>
    <div class="sourceCode" id="cb4">
      <pre
        class="sourceCode js"
      ><code class="sourceCode javascript"><a class="sourceLine" id="cb4-1" title="1"><span class="co">// Assigning to exports will not modify module, must use module.exports</span></a>
<a class="sourceLine" id="cb4-2" title="2"><span class="va">module</span>.<span class="at">exports</span> <span class="op">=</span> <span class="kw">class</span> Square <span class="op">{</span></a>
<a class="sourceLine" id="cb4-3" title="3">  <span class="at">constructor</span>(width) <span class="op">{</span></a>
<a class="sourceLine" id="cb4-4" title="4">    <span class="kw">this</span>.<span class="at">width</span> <span class="op">=</span> width<span class="op">;</span></a>
<a class="sourceLine" id="cb4-5" title="5">  <span class="op">}</span></a>
<a class="sourceLine" id="cb4-6" title="6"></a>
<a class="sourceLine" id="cb4-7" title="7">  <span class="at">area</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb4-8" title="8">    <span class="cf">return</span> <span class="kw">this</span>.<span class="at">width</span> <span class="op">**</span> <span class="dv">2</span><span class="op">;</span></a>
<a class="sourceLine" id="cb4-9" title="9">  <span class="op">}</span></a>
<a class="sourceLine" id="cb4-10" title="10"><span class="op">};</span></a></code></pre>
    </div>
    <p>
      The module system is implemented in the
      <code>require('module')</code> module.
    </p>
    <h2 id="accessing-the-main-module">Accessing the main module</h2>
    <!-- type=misc -->
    <p>
      When a file is run directly from Node.js, <code>require.main</code> is set
      to its <code>module</code>. That means that it is possible to determine
      whether a file has been run directly by testing
      <code>require.main === module</code>.
    </p>
    <p>
      For a file <code>foo.js</code>, this will be <code>true</code> if run via
      <code>node foo.js</code>, but <code>false</code> if run by
      <code>require('./foo')</code>.
    </p>
    <p>
      Because <code>module</code> provides a <code>filename</code> property
      (normally equivalent to <code>__filename</code>), the entry point of the
      current application can be obtained by checking
      <code>require.main.filename</code>.
    </p>
    <h2 id="package-manager-tips">Package manager tips</h2>
    <!-- type=misc -->
    <p>
      The semantics of the Node.js <code>require()</code> function were designed
      to be general enough to support reasonable directory structures. Package
      manager programs such as <code>dpkg</code>, <code>rpm</code>, and
      <code>npm</code> will hopefully find it possible to build native packages
      from Node.js modules without modification.
    </p>
    <p>Below we give a suggested directory structure that could work:</p>
    <p>
      Let’s say that we wanted to have the folder at
      <code>/usr/lib/node/&lt;some-package&gt;/&lt;some-version&gt;</code> hold
      the contents of a specific version of a package.
    </p>
    <p>
      Packages can depend on one another. In order to install package
      <code>foo</code>, it may be necessary to install a specific version of
      package <code>bar</code>. The <code>bar</code> package may itself have
      dependencies, and in some cases, these may even collide or form cyclic
      dependencies.
    </p>
    <p>
      Because Node.js looks up the <code>realpath</code> of any modules it loads
      (that is, it resolves symlinks) and then
      <a href="#modules_loading_from_node_modules_folders"
        >looks for their dependencies in <code>node_modules</code> folders</a
      >, this situation can be resolved with the following architecture:
    </p>
    <ul>
      <li>
        <code>/usr/lib/node/foo/1.2.3/</code>: Contents of the
        <code>foo</code> package, version 1.2.3.
      </li>
      <li>
        <code>/usr/lib/node/bar/4.3.2/</code>: Contents of the
        <code>bar</code> package that <code>foo</code> depends on.
      </li>
      <li>
        <code>/usr/lib/node/foo/1.2.3/node_modules/bar</code>: Symbolic link to
        <code>/usr/lib/node/bar/4.3.2/</code>.
      </li>
      <li>
        <code>/usr/lib/node/bar/4.3.2/node_modules/*</code>: Symbolic links to
        the packages that <code>bar</code> depends on.
      </li>
    </ul>
    <p>
      Thus, even if a cycle is encountered, or if there are dependency
      conflicts, every module will be able to get a version of its dependency
      that it can use.
    </p>
    <p>
      When the code in the <code>foo</code> package does
      <code>require('bar')</code>, it will get the version that is symlinked
      into <code>/usr/lib/node/foo/1.2.3/node_modules/bar</code>. Then, when the
      code in the <code>bar</code> package calls <code>require('quux')</code>,
      it’ll get the version that is symlinked into
      <code>/usr/lib/node/bar/4.3.2/node_modules/quux</code>.
    </p>
    <p>
      Furthermore, to make the module lookup process even more optimal, rather
      than putting packages directly in <code>/usr/lib/node</code>, we could put
      them in <code>/usr/lib/node_modules/&lt;name&gt;/&lt;version&gt;</code>.
      Then Node.js will not bother looking for missing dependencies in
      <code>/usr/node_modules</code> or <code>/node_modules</code>.
    </p>
    <p>
      In order to make modules available to the Node.js REPL, it might be useful
      to also add the <code>/usr/lib/node_modules</code> folder to the
      <code>$NODE_PATH</code> environment variable. Since the module lookups
      using <code>node_modules</code> folders are all relative, and based on the
      real path of the files making the calls to <code>require()</code>, the
      packages themselves can be anywhere.
    </p>
    <h2 id="the-.mjs-extension">The <code>.mjs</code> extension</h2>
    <p>
      It is not possible to <code>require()</code> files that have the
      <code>.mjs</code> extension. Attempting to do so will throw
      <a href="errors.md#errors_err_require_esm">an error</a>. The
      <code>.mjs</code> extension is reserved for
      <a href="esm.md">ECMAScript Modules</a> which cannot be loaded via
      <code>require()</code>. See <a href="esm.md">ECMAScript Modules</a> for
      more details.
    </p>
    <h2 id="all-together">All together…</h2>
    <!-- type=misc -->
    <p>
      To get the exact filename that will be loaded when
      <code>require()</code> is called, use the
      <code>require.resolve()</code> function.
    </p>
    <p>
      Putting together all of the above, here is the high-level algorithm in
      pseudocode of what <code>require()</code> does:
    </p>
    <pre>
require(X) from module at path Y
1. If X is a core module,
   a. return the core module
   b. STOP
2. If X begins with '/'
   a. set Y to be the filesystem root
3. If X begins with './' or '/' or '../'
   a. LOAD_AS_FILE(Y + X)
   b. LOAD_AS_DIRECTORY(Y + X)
   c. THROW "not found"
4. If X begins with '#'
   a. LOAD_PACKAGE_IMPORTS(X, dirname(Y))
5. LOAD_PACKAGE_SELF(X, dirname(Y))
6. LOAD_NODE_MODULES(X, dirname(Y))
7. THROW "not found"

LOAD_AS_FILE(X)
1. If X is a file, load X as its file extension format. STOP
2. If X.js is a file, load X.js as JavaScript text. STOP
3. If X.json is a file, parse X.json to a JavaScript Object. STOP
4. If X.node is a file, load X.node as binary addon. STOP

LOAD_INDEX(X)
1. If X/index.js is a file, load X/index.js as JavaScript text. STOP
2. If X/index.json is a file, parse X/index.json to a JavaScript object. STOP
3. If X/index.node is a file, load X/index.node as binary addon. STOP

LOAD_AS_DIRECTORY(X)
1. If X/package.json is a file,
   a. Parse X/package.json, and look for "main" field.
   b. If "main" is a falsy value, GOTO 2.
   c. let M = X + (json main field)
   d. LOAD_AS_FILE(M)
   e. LOAD_INDEX(M)
   f. LOAD_INDEX(X) DEPRECATED
   g. THROW "not found"
2. LOAD_INDEX(X)

LOAD_NODE_MODULES(X, START)
1. let DIRS = NODE_MODULES_PATHS(START)
2. for each DIR in DIRS:
   a. LOAD_PACKAGE_EXPORTS(X, DIR)
   b. LOAD_AS_FILE(DIR/X)
   c. LOAD_AS_DIRECTORY(DIR/X)

NODE_MODULES_PATHS(START)
1. let PARTS = path split(START)
2. let I = count of PARTS - 1
3. let DIRS = [GLOBAL_FOLDERS]
4. while I >= 0,
   a. if PARTS[I] = "node_modules" CONTINUE
   b. DIR = path join(PARTS[0 .. I] + "node_modules")
   c. DIRS = DIRS + DIR
   d. let I = I - 1
5. return DIRS

LOAD_PACKAGE_IMPORTS(X, DIR)
1. Find the closest package scope SCOPE to DIR.
2. If no scope was found, return.
3. If the SCOPE/package.json "imports" is null or undefined, return.
4. let MATCH = PACKAGE_IMPORTS_RESOLVE(X, pathToFileURL(SCOPE),
  ["node", "require"]) <a href="esm.md#resolver-algorithm-specification">defined in the ESM resolver</a>.
5. RESOLVE_ESM_MATCH(MATCH).

LOAD_PACKAGE_EXPORTS(X, DIR)
1. Try to interpret X as a combination of NAME and SUBPATH where the name
   may have a @scope/ prefix and the subpath begins with a slash (`/`).
2. If X does not match this pattern or DIR/NAME/package.json is not a file,
   return.
3. Parse DIR/NAME/package.json, and look for "exports" field.
4. If "exports" is null or undefined, return.
5. let MATCH = PACKAGE_EXPORTS_RESOLVE(pathToFileURL(DIR/NAME), "." + SUBPATH,
   `package.json` "exports", ["node", "require"]) <a href="esm.md#resolver-algorithm-specification">defined in the ESM resolver</a>.
6. RESOLVE_ESM_MATCH(MATCH)

LOAD_PACKAGE_SELF(X, DIR)
1. Find the closest package scope SCOPE to DIR.
2. If no scope was found, return.
3. If the SCOPE/package.json "exports" is null or undefined, return.
4. If the SCOPE/package.json "name" is not the first segment of X, return.
5. let MATCH = PACKAGE_EXPORTS_RESOLVE(pathToFileURL(SCOPE),
   "." + X.slice("name".length), `package.json` "exports", ["node", "require"])
   <a href="esm.md#resolver-algorithm-specification">defined in the ESM resolver</a>.
6. RESOLVE_ESM_MATCH(MATCH)

RESOLVE_ESM_MATCH(MATCH)
1. let { RESOLVED, EXACT } = MATCH
2. let RESOLVED_PATH = fileURLToPath(RESOLVED)
3. If EXACT is true,
   a. If the file at RESOLVED_PATH exists, load RESOLVED_PATH as its extension
      format. STOP
4. Otherwise, if EXACT is false,
   a. LOAD_AS_FILE(RESOLVED_PATH)
   b. LOAD_AS_DIRECTORY(RESOLVED_PATH)
5. THROW "not found"
</pre>
    <h2 id="caching">Caching</h2>
    <!--type=misc-->
    <p>
      Modules are cached after the first time they are loaded. This means (among
      other things) that every call to <code>require('foo')</code> will get
      exactly the same object returned, if it would resolve to the same file.
    </p>
    <p>
      Provided <code>require.cache</code> is not modified, multiple calls to
      <code>require('foo')</code> will not cause the module code to be executed
      multiple times. This is an important feature. With it, “partially done”
      objects can be returned, thus allowing transitive dependencies to be
      loaded even when they would cause cycles.
    </p>
    <p>
      To have a module execute code multiple times, export a function, and call
      that function.
    </p>
    <h3 id="module-caching-caveats">Module caching caveats</h3>
    <!--type=misc-->
    <p>
      Modules are cached based on their resolved filename. Since modules may
      resolve to a different filename based on the location of the calling
      module (loading from <code>node_modules</code> folders), it is not a
      <em>guarantee</em> that <code>require('foo')</code> will always return the
      exact same object, if it would resolve to different files.
    </p>
    <p>
      Additionally, on case-insensitive file systems or operating systems,
      different resolved filenames can point to the same file, but the cache
      will still treat them as different modules and will reload the file
      multiple times. For example, <code>require('./foo')</code> and
      <code>require('./FOO')</code> return two different objects, irrespective
      of whether or not <code>./foo</code> and <code>./FOO</code> are the same
      file.
    </p>
    <h2 id="core-modules">Core modules</h2>
    <!--type=misc-->
    <!-- YAML
changes:
  - version: v16.0.0
    pr-url: https://github.com/nodejs/node/pull/37246
    description: Added `node:` import support to `require(...)`.
-->
    <p>
      Node.js has several modules compiled into the binary. These modules are
      described in greater detail elsewhere in this documentation.
    </p>
    <p>
      The core modules are defined within the Node.js source and are located in
      the <code>lib/</code> folder.
    </p>
    <p>
      Core modules are always preferentially loaded if their identifier is
      passed to <code>require()</code>. For instance,
      <code>require('http')</code> will always return the built in HTTP module,
      even if there is a file by that name.
    </p>
    <p>
      Core modules can also be identified using the <code>node:</code> prefix,
      in which case it bypasses the <code>require</code> cache. For instance,
      <code>require('node:http')</code> will always return the built in HTTP
      module, even if there is <code>require.cache</code> entry by that name.
    </p>
    <h2 id="cycles">Cycles</h2>
    <!--type=misc-->
    <p>
      When there are circular <code>require()</code> calls, a module might not
      have finished executing when it is returned.
    </p>
    <p>Consider this situation:</p>
    <p><code>a.js</code>:</p>
    <div class="sourceCode" id="cb5">
      <pre
        class="sourceCode js"
      ><code class="sourceCode javascript"><a class="sourceLine" id="cb5-1" title="1"><span class="va">console</span>.<span class="at">log</span>(<span class="st">&#39;a starting&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb5-2" title="2"><span class="va">exports</span>.<span class="at">done</span> <span class="op">=</span> <span class="kw">false</span><span class="op">;</span></a>
<a class="sourceLine" id="cb5-3" title="3"><span class="kw">const</span> b <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;./b.js&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb5-4" title="4"><span class="va">console</span>.<span class="at">log</span>(<span class="st">&#39;in a, b.done = %j&#39;</span><span class="op">,</span> <span class="va">b</span>.<span class="at">done</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb5-5" title="5"><span class="va">exports</span>.<span class="at">done</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></a>
<a class="sourceLine" id="cb5-6" title="6"><span class="va">console</span>.<span class="at">log</span>(<span class="st">&#39;a done&#39;</span>)<span class="op">;</span></a></code></pre>
    </div>
    <p><code>b.js</code>:</p>
    <div class="sourceCode" id="cb6">
      <pre
        class="sourceCode js"
      ><code class="sourceCode javascript"><a class="sourceLine" id="cb6-1" title="1"><span class="va">console</span>.<span class="at">log</span>(<span class="st">&#39;b starting&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb6-2" title="2"><span class="va">exports</span>.<span class="at">done</span> <span class="op">=</span> <span class="kw">false</span><span class="op">;</span></a>
<a class="sourceLine" id="cb6-3" title="3"><span class="kw">const</span> a <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;./a.js&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb6-4" title="4"><span class="va">console</span>.<span class="at">log</span>(<span class="st">&#39;in b, a.done = %j&#39;</span><span class="op">,</span> <span class="va">a</span>.<span class="at">done</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb6-5" title="5"><span class="va">exports</span>.<span class="at">done</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></a>
<a class="sourceLine" id="cb6-6" title="6"><span class="va">console</span>.<span class="at">log</span>(<span class="st">&#39;b done&#39;</span>)<span class="op">;</span></a></code></pre>
    </div>
    <p><code>main.js</code>:</p>
    <div class="sourceCode" id="cb7">
      <pre
        class="sourceCode js"
      ><code class="sourceCode javascript"><a class="sourceLine" id="cb7-1" title="1"><span class="va">console</span>.<span class="at">log</span>(<span class="st">&#39;main starting&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb7-2" title="2"><span class="kw">const</span> a <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;./a.js&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb7-3" title="3"><span class="kw">const</span> b <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;./b.js&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb7-4" title="4"><span class="va">console</span>.<span class="at">log</span>(<span class="st">&#39;in main, a.done = %j, b.done = %j&#39;</span><span class="op">,</span> <span class="va">a</span>.<span class="at">done</span><span class="op">,</span> <span class="va">b</span>.<span class="at">done</span>)<span class="op">;</span></a></code></pre>
    </div>
    <p>
      When <code>main.js</code> loads <code>a.js</code>, then
      <code>a.js</code> in turn loads <code>b.js</code>. At that point,
      <code>b.js</code> tries to load <code>a.js</code>. In order to prevent an
      infinite loop, an <strong>unfinished copy</strong> of the
      <code>a.js</code> exports object is returned to the
      <code>b.js</code> module. <code>b.js</code> then finishes loading, and its
      <code>exports</code> object is provided to the <code>a.js</code> module.
    </p>
    <p>
      By the time <code>main.js</code> has loaded both modules, they’re both
      finished. The output of this program would thus be:
    </p>
    <pre class="console"><code>$ node main.js
main starting
a starting
b starting
in b, a.done = false
b done
in a, b.done = true
a done
in main, a.done = true, b.done = true</code></pre>
    <p>
      Careful planning is required to allow cyclic module dependencies to work
      correctly within an application.
    </p>
    <h2 id="file-modules">File modules</h2>
    <!--type=misc-->
    <p>
      If the exact filename is not found, then Node.js will attempt to load the
      required filename with the added extensions: <code>.js</code>,
      <code>.json</code>, and finally <code>.node</code>.
    </p>
    <p>
      <code>.js</code> files are interpreted as JavaScript text files, and
      <code>.json</code> files are parsed as JSON text files.
      <code>.node</code> files are interpreted as compiled addon modules loaded
      with <code>process.dlopen()</code>.
    </p>
    <p>
      A required module prefixed with <code>'/'</code> is an absolute path to
      the file. For example, <code>require('/home/marco/foo.js')</code> will
      load the file at <code>/home/marco/foo.js</code>.
    </p>
    <p>
      A required module prefixed with <code>'./'</code> is relative to the file
      calling <code>require()</code>. That is, <code>circle.js</code> must be in
      the same directory as <code>foo.js</code> for
      <code>require('./circle')</code> to find it.
    </p>
    <p>
      Without a leading <code>'/'</code>, <code>'./'</code>, or
      <code>'../'</code> to indicate a file, the module must either be a core
      module or is loaded from a <code>node_modules</code> folder.
    </p>
    <p>
      If the given path does not exist, <code>require()</code> will throw an
      <a href="errors.md#errors_class_error"><code>Error</code></a> with its
      <code>code</code> property set to <code>'MODULE_NOT_FOUND'</code>.
    </p>
    <h2 id="folders-as-modules">Folders as modules</h2>
    <!--type=misc-->
    <p>
      It is convenient to organize programs and libraries into self-contained
      directories, and then provide a single entry point to those directories.
      There are three ways in which a folder may be passed to
      <code>require()</code> as an argument.
    </p>
    <p>
      The first is to create a
      <a href="packages.md#packages_node_js_package_json_field_definitions"
        ><code>package.json</code></a
      >
      file in the root of the folder, which specifies a
      <code>main</code> module. An example
      <a href="packages.md#packages_node_js_package_json_field_definitions"
        ><code>package.json</code></a
      >
      file might look like this:
    </p>
    <div class="sourceCode" id="cb9">
      <pre
        class="sourceCode json"
      ><code class="sourceCode json"><a class="sourceLine" id="cb9-1" title="1"><span class="fu">{</span> <span class="dt">&quot;name&quot;</span> <span class="fu">:</span> <span class="st">&quot;some-library&quot;</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb9-2" title="2">  <span class="dt">&quot;main&quot;</span> <span class="fu">:</span> <span class="st">&quot;./lib/some-library.js&quot;</span> <span class="fu">}</span></a></code></pre>
    </div>
    <p>
      If this was in a folder at <code>./some-library</code>, then
      <code>require('./some-library')</code> would attempt to load
      <code>./some-library/lib/some-library.js</code>.
    </p>
    <p>
      This is the extent of the awareness of <code>package.json</code> files
      within Node.js.
    </p>
    <p>
      If there is no
      <a href="packages.md#packages_node_js_package_json_field_definitions"
        ><code>package.json</code></a
      >
      file present in the directory, or if the
      <a href="packages.md#packages_main"><code>"main"</code></a> entry is
      missing or cannot be resolved, then Node.js will attempt to load an
      <code>index.js</code> or <code>index.node</code> file out of that
      directory. For example, if there was no
      <a href="packages.md#packages_node_js_package_json_field_definitions"
        ><code>package.json</code></a
      >
      file in the previous example, then
      <code>require('./some-library')</code> would attempt to load:
    </p>
    <ul>
      <li><code>./some-library/index.js</code></li>
      <li><code>./some-library/index.node</code></li>
    </ul>
    <p>
      If these attempts fail, then Node.js will report the entire module as
      missing with the default error:
    </p>
    <pre
      class="console"
    ><code>Error: Cannot find module &#39;some-library&#39;</code></pre>
    <h2 id="loading-from-node_modules-folders">
      Loading from <code>node_modules</code> folders
    </h2>
    <!--type=misc-->
    <p>
      If the module identifier passed to <code>require()</code> is not a
      <a href="#modules_core_modules">core</a> module, and does not begin with
      <code>'/'</code>, <code>'../'</code>, or <code>'./'</code>, then Node.js
      starts at the parent directory of the current module, and adds
      <code>/node_modules</code>, and attempts to load the module from that
      location. Node.js will not append <code>node_modules</code> to a path
      already ending in <code>node_modules</code>.
    </p>
    <p>
      If it is not found there, then it moves to the parent directory, and so
      on, until the root of the file system is reached.
    </p>
    <p>
      For example, if the file at <code>'/home/ry/projects/foo.js'</code> called
      <code>require('bar.js')</code>, then Node.js would look in the following
      locations, in this order:
    </p>
    <ul>
      <li><code>/home/ry/projects/node_modules/bar.js</code></li>
      <li><code>/home/ry/node_modules/bar.js</code></li>
      <li><code>/home/node_modules/bar.js</code></li>
      <li><code>/node_modules/bar.js</code></li>
    </ul>
    <p>
      This allows programs to localize their dependencies, so that they do not
      clash.
    </p>
    <p>
      It is possible to require specific files or sub modules distributed with a
      module by including a path suffix after the module name. For instance
      <code>require('example-module/path/to/file')</code> would resolve
      <code>path/to/file</code> relative to where <code>example-module</code> is
      located. The suffixed path follows the same module resolution semantics.
    </p>
    <h2 id="loading-from-the-global-folders">
      Loading from the global folders
    </h2>
    <!-- type=misc -->
    <p>
      If the <code>NODE_PATH</code> environment variable is set to a
      colon-delimited list of absolute paths, then Node.js will search those
      paths for modules if they are not found elsewhere.
    </p>
    <p>
      On Windows, <code>NODE_PATH</code> is delimited by semicolons
      (<code>;</code>) instead of colons.
    </p>
    <p>
      <code>NODE_PATH</code> was originally created to support loading modules
      from varying paths before the current
      <a href="#modules_all_together">module resolution</a> algorithm was
      defined.
    </p>
    <p>
      <code>NODE_PATH</code> is still supported, but is less necessary now that
      the Node.js ecosystem has settled on a convention for locating dependent
      modules. Sometimes deployments that rely on <code>NODE_PATH</code> show
      surprising behavior when people are unaware that
      <code>NODE_PATH</code> must be set. Sometimes a module’s dependencies
      change, causing a different version (or even a different module) to be
      loaded as the <code>NODE_PATH</code> is searched.
    </p>
    <p>
      Additionally, Node.js will search in the following list of GLOBAL_FOLDERS:
    </p>
    <ul>
      <li>1: <code>$HOME/.node_modules</code></li>
      <li>2: <code>$HOME/.node_libraries</code></li>
      <li>3: <code>$PREFIX/lib/node</code></li>
    </ul>
    <p>
      Where <code>$HOME</code> is the user’s home directory, and
      <code>$PREFIX</code> is the Node.js configured <code>node_prefix</code>.
    </p>
    <p>These are mostly for historic reasons.</p>
    <p>
      It is strongly encouraged to place dependencies in the local
      <code>node_modules</code> folder. These will be loaded faster, and more
      reliably.
    </p>
    <h2 id="the-module-wrapper">The module wrapper</h2>
    <!-- type=misc -->
    <p>
      Before a module’s code is executed, Node.js will wrap it with a function
      wrapper that looks like the following:
    </p>
    <div class="sourceCode" id="cb11">
      <pre
        class="sourceCode js"
      ><code class="sourceCode javascript"><a class="sourceLine" id="cb11-1" title="1">(<span class="kw">function</span>(exports<span class="op">,</span> require<span class="op">,</span> module<span class="op">,</span> __filename<span class="op">,</span> __dirname) <span class="op">{</span></a>
<a class="sourceLine" id="cb11-2" title="2"><span class="co">// Module code actually lives in here</span></a>
<a class="sourceLine" id="cb11-3" title="3"><span class="op">}</span>)<span class="op">;</span></a></code></pre>
    </div>
    <p>By doing this, Node.js achieves a few things:</p>
    <ul>
      <li>
        It keeps top-level variables (defined with <code>var</code>,
        <code>const</code> or <code>let</code>) scoped to the module rather than
        the global object.
      </li>
      <li>
        It helps to provide some global-looking variables that are actually
        specific to the module, such as:
        <ul>
          <li>
            The <code>module</code> and <code>exports</code> objects that the
            implementor can use to export values from the module.
          </li>
          <li>
            The convenience variables <code>__filename</code> and
            <code>__dirname</code>, containing the module’s absolute filename
            and directory path.
          </li>
        </ul>
      </li>
    </ul>
    <h2 id="the-module-scope">The module scope</h2>
    <h3 id="dirname"><code>__dirname</code></h3>
    <!-- YAML
added: v0.1.27
-->
    <!-- type=var -->
    <ul>
      <li>{string}</li>
    </ul>
    <p>
      The directory name of the current module. This is the same as the
      <a href="path.md#path_path_dirname_path"><code>path.dirname()</code></a>
      of the <a href="#modules_filename"><code>__filename</code></a
      >.
    </p>
    <p>
      Example: running <code>node example.js</code> from <code>/Users/mjr</code>
    </p>
    <div class="sourceCode" id="cb12">
      <pre
        class="sourceCode js"
      ><code class="sourceCode javascript"><a class="sourceLine" id="cb12-1" title="1"><span class="va">console</span>.<span class="at">log</span>(__dirname)<span class="op">;</span></a>
<a class="sourceLine" id="cb12-2" title="2"><span class="co">// Prints: /Users/mjr</span></a>
<a class="sourceLine" id="cb12-3" title="3"><span class="va">console</span>.<span class="at">log</span>(<span class="va">path</span>.<span class="at">dirname</span>(__filename))<span class="op">;</span></a>
<a class="sourceLine" id="cb12-4" title="4"><span class="co">// Prints: /Users/mjr</span></a></code></pre>
    </div>
    <h3 id="filename"><code>__filename</code></h3>
    <!-- YAML
added: v0.0.1
-->
    <!-- type=var -->
    <ul>
      <li>{string}</li>
    </ul>
    <p>
      The file name of the current module. This is the current module file’s
      absolute path with symlinks resolved.
    </p>
    <p>
      For a main program this is not necessarily the same as the file name used
      in the command line.
    </p>
    <p>
      See <a href="#modules_dirname"><code>__dirname</code></a> for the
      directory name of the current module.
    </p>
    <p>Examples:</p>
    <p>Running <code>node example.js</code> from <code>/Users/mjr</code></p>
    <div class="sourceCode" id="cb13">
      <pre
        class="sourceCode js"
      ><code class="sourceCode javascript"><a class="sourceLine" id="cb13-1" title="1"><span class="va">console</span>.<span class="at">log</span>(__filename)<span class="op">;</span></a>
<a class="sourceLine" id="cb13-2" title="2"><span class="co">// Prints: /Users/mjr/example.js</span></a>
<a class="sourceLine" id="cb13-3" title="3"><span class="va">console</span>.<span class="at">log</span>(__dirname)<span class="op">;</span></a>
<a class="sourceLine" id="cb13-4" title="4"><span class="co">// Prints: /Users/mjr</span></a></code></pre>
    </div>
    <p>
      Given two modules: <code>a</code> and <code>b</code>, where
      <code>b</code> is a dependency of <code>a</code> and there is a directory
      structure of:
    </p>
    <ul>
      <li><code>/Users/mjr/app/a.js</code></li>
      <li><code>/Users/mjr/app/node_modules/b/b.js</code></li>
    </ul>
    <p>
      References to <code>__filename</code> within <code>b.js</code> will return
      <code>/Users/mjr/app/node_modules/b/b.js</code> while references to
      <code>__filename</code> within <code>a.js</code> will return
      <code>/Users/mjr/app/a.js</code>.
    </p>
    <h3 id="exports"><code>exports</code></h3>
    <!-- YAML
added: v0.1.12
-->
    <!-- type=var -->
    <ul>
      <li>{Object}</li>
    </ul>
    <p>
      A reference to the <code>module.exports</code> that is shorter to type.
      See the section about the
      <a href="#modules_exports_shortcut">exports shortcut</a> for details on
      when to use <code>exports</code> and when to use
      <code>module.exports</code>.
    </p>
    <h3 id="module"><code>module</code></h3>
    <!-- YAML
added: v0.1.16
-->
    <!-- type=var -->
    <ul>
      <li>{module}</li>
    </ul>
    <p>
      A reference to the current module, see the section about the
      <a href="#modules_the_module_object"><code>module</code> object</a>. In
      particular, <code>module.exports</code> is used for defining what a module
      exports and makes available through <code>require()</code>.
    </p>
    <h3 id="requireid"><code>require(id)</code></h3>
    <!-- YAML
added: v0.1.13
-->
    <!-- type=var -->
    <ul>
      <li><code>id</code> {string} module name or path</li>
      <li>Returns: {any} exported module content</li>
    </ul>
    <p>
      Used to import modules, <code>JSON</code>, and local files. Modules can be
      imported from <code>node_modules</code>. Local modules and JSON files can
      be imported using a relative path (e.g. <code>./</code>,
      <code>./foo</code>, <code>./bar/baz</code>, <code>../foo</code>) that will
      be resolved against the directory named by
      <a href="#modules_dirname"><code>__dirname</code></a> (if defined) or the
      current working directory. The relative paths of POSIX style are resolved
      in an OS independent fashion, meaning that the examples above will work on
      Windows in the same way they would on Unix systems.
    </p>
    <div class="sourceCode" id="cb14">
      <pre
        class="sourceCode js"
      ><code class="sourceCode javascript"><a class="sourceLine" id="cb14-1" title="1"><span class="co">// Importing a local module with a path relative to the `__dirname` or current</span></a>
<a class="sourceLine" id="cb14-2" title="2"><span class="co">// working directory. (On Windows, this would resolve to .\path\myLocalModule.)</span></a>
<a class="sourceLine" id="cb14-3" title="3"><span class="kw">const</span> myLocalModule <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;./path/myLocalModule&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb14-4" title="4"></a>
<a class="sourceLine" id="cb14-5" title="5"><span class="co">// Importing a JSON file:</span></a>
<a class="sourceLine" id="cb14-6" title="6"><span class="kw">const</span> jsonData <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;./path/filename.json&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb14-7" title="7"></a>
<a class="sourceLine" id="cb14-8" title="8"><span class="co">// Importing a module from node_modules or Node.js built-in module:</span></a>
<a class="sourceLine" id="cb14-9" title="9"><span class="kw">const</span> crypto <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;crypto&#39;</span>)<span class="op">;</span></a></code></pre>
    </div>
    <h4 id="require.cache"><code>require.cache</code></h4>
    <!-- YAML
added: v0.3.0
-->
    <ul>
      <li>{Object}</li>
    </ul>
    <p>
      Modules are cached in this object when they are required. By deleting a
      key value from this object, the next <code>require</code> will reload the
      module. This does not apply to <a href="addons.md">native addons</a>, for
      which reloading will result in an error.
    </p>
    <p>
      Adding or replacing entries is also possible. This cache is checked before
      native modules and if a name matching a native module is added to the
      cache, only <code>node:</code>-prefixed require calls are going to receive
      the native module. Use with care!
    </p>
    <!-- eslint-disable node-core/no-duplicate-requires -->
    <div class="sourceCode" id="cb15">
      <pre
        class="sourceCode js"
      ><code class="sourceCode javascript"><a class="sourceLine" id="cb15-1" title="1"><span class="kw">const</span> assert <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;assert&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb15-2" title="2"><span class="kw">const</span> realFs <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;fs&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb15-3" title="3"></a>
<a class="sourceLine" id="cb15-4" title="4"><span class="kw">const</span> fakeFs <span class="op">=</span> <span class="op">{};</span></a>
<a class="sourceLine" id="cb15-5" title="5"><span class="va">require</span>.<span class="va">cache</span>.<span class="at">fs</span> <span class="op">=</span> <span class="op">{</span> <span class="dt">exports</span><span class="op">:</span> fakeFs <span class="op">};</span></a>
<a class="sourceLine" id="cb15-6" title="6"></a>
<a class="sourceLine" id="cb15-7" title="7"><span class="va">assert</span>.<span class="at">strictEqual</span>(<span class="at">require</span>(<span class="st">&#39;fs&#39;</span>)<span class="op">,</span> fakeFs)<span class="op">;</span></a>
<a class="sourceLine" id="cb15-8" title="8"><span class="va">assert</span>.<span class="at">strictEqual</span>(<span class="at">require</span>(<span class="st">&#39;node:fs&#39;</span>)<span class="op">,</span> realFs)<span class="op">;</span></a></code></pre>
    </div>
    <h4 id="require.extensions"><code>require.extensions</code></h4>
    <!-- YAML
added: v0.3.0
deprecated: v0.10.6
-->
    <blockquote>
      <p>Stability: 0 - Deprecated</p>
    </blockquote>
    <ul>
      <li>{Object}</li>
    </ul>
    <p>
      Instruct <code>require</code> on how to handle certain file extensions.
    </p>
    <p>
      Process files with the extension <code>.sjs</code> as <code>.js</code>:
    </p>
    <div class="sourceCode" id="cb16">
      <pre
        class="sourceCode js"
      ><code class="sourceCode javascript"><a class="sourceLine" id="cb16-1" title="1"><span class="va">require</span>.<span class="at">extensions</span>[<span class="st">&#39;.sjs&#39;</span>] <span class="op">=</span> <span class="va">require</span>.<span class="at">extensions</span>[<span class="st">&#39;.js&#39;</span>]<span class="op">;</span></a></code></pre>
    </div>
    <p>
      <strong>Deprecated.</strong> In the past, this list has been used to load
      non-JavaScript modules into Node.js by compiling them on-demand. However,
      in practice, there are much better ways to do this, such as loading
      modules via some other Node.js program, or compiling them to JavaScript
      ahead of time.
    </p>
    <p>
      Avoid using <code>require.extensions</code>. Use could cause subtle bugs
      and resolving the extensions gets slower with each registered extension.
    </p>
    <h4 id="require.main"><code>require.main</code></h4>
    <!-- YAML
added: v0.1.17
-->
    <ul>
      <li>{module}</li>
    </ul>
    <p>
      The <code>Module</code> object representing the entry script loaded when
      the Node.js process launched. See
      <a href="#modules_accessing_the_main_module"
        >“Accessing the main module”</a
      >.
    </p>
    <p>In <code>entry.js</code> script:</p>
    <div class="sourceCode" id="cb17">
      <pre
        class="sourceCode js"
      ><code class="sourceCode javascript"><a class="sourceLine" id="cb17-1" title="1"><span class="va">console</span>.<span class="at">log</span>(<span class="va">require</span>.<span class="at">main</span>)<span class="op">;</span></a></code></pre>
    </div>
    <div class="sourceCode" id="cb18">
      <pre
        class="sourceCode bash"
      ><code class="sourceCode bash"><a class="sourceLine" id="cb18-1" title="1"><span class="ex">node</span> entry.js</a></code></pre>
    </div>
    <!-- eslint-skip -->
    <div class="sourceCode" id="cb19">
      <pre
        class="sourceCode js"
      ><code class="sourceCode javascript"><a class="sourceLine" id="cb19-1" title="1">Module <span class="op">{</span></a>
<a class="sourceLine" id="cb19-2" title="2">  <span class="dt">id</span><span class="op">:</span> <span class="st">&#39;.&#39;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb19-3" title="3">  <span class="dt">path</span><span class="op">:</span> <span class="st">&#39;/absolute/path/to&#39;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb19-4" title="4">  <span class="dt">exports</span><span class="op">:</span> <span class="op">{},</span></a>
<a class="sourceLine" id="cb19-5" title="5">  <span class="dt">filename</span><span class="op">:</span> <span class="st">&#39;/absolute/path/to/entry.js&#39;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb19-6" title="6">  <span class="dt">loaded</span><span class="op">:</span> <span class="kw">false</span><span class="op">,</span></a>
<a class="sourceLine" id="cb19-7" title="7">  <span class="dt">children</span><span class="op">:</span> []<span class="op">,</span></a>
<a class="sourceLine" id="cb19-8" title="8">  <span class="dt">paths</span><span class="op">:</span></a>
<a class="sourceLine" id="cb19-9" title="9">   [ <span class="st">&#39;/absolute/path/to/node_modules&#39;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb19-10" title="10">     <span class="st">&#39;/absolute/path/node_modules&#39;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb19-11" title="11">     <span class="st">&#39;/absolute/node_modules&#39;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb19-12" title="12">     <span class="st">&#39;/node_modules&#39;</span> ] <span class="op">}</span></a></code></pre>
    </div>
    <h4 id="require.resolverequest-options">
      <code>require.resolve(request[, options])</code>
    </h4>
    <!-- YAML
added: v0.3.0
changes:
  - version: v8.9.0
    pr-url: https://github.com/nodejs/node/pull/16397
    description: The `paths` option is now supported.
-->
    <ul>
      <li><code>request</code> {string} The module path to resolve.</li>
      <li>
        <code>options</code> {Object}
        <ul>
          <li>
            <code>paths</code> {string[]} Paths to resolve module location from.
            If present, these paths are used instead of the default resolution
            paths, with the exception of
            <a href="#modules_loading_from_the_global_folders"
              >GLOBAL_FOLDERS</a
            >
            like <code>$HOME/.node_modules</code>, which are always included.
            Each of these paths is used as a starting point for the module
            resolution algorithm, meaning that the
            <code>node_modules</code> hierarchy is checked from this location.
          </li>
        </ul>
      </li>
      <li>Returns: {string}</li>
    </ul>
    <p>
      Use the internal <code>require()</code> machinery to look up the location
      of a module, but rather than loading the module, just return the resolved
      filename.
    </p>
    <p>
      If the module can not be found, a <code>MODULE_NOT_FOUND</code> error is
      thrown.
    </p>
    <h5 id="require.resolve.pathsrequest">
      <code>require.resolve.paths(request)</code>
    </h5>
    <!-- YAML
added: v8.9.0
-->
    <ul>
      <li>
        <code>request</code> {string} The module path whose lookup paths are
        being retrieved.
      </li>
      <li>Returns: {string[]|null}</li>
    </ul>
    <p>
      Returns an array containing the paths searched during resolution of
      <code>request</code> or <code>null</code> if the
      <code>request</code> string references a core module, for example
      <code>http</code> or <code>fs</code>.
    </p>
    <h2 id="the-module-object">The <code>module</code> object</h2>
    <!-- YAML
added: v0.1.16
-->
    <!-- type=var -->
    <!-- name=module -->
    <ul>
      <li>{Object}</li>
    </ul>
    <p>
      In each module, the <code>module</code> free variable is a reference to
      the object representing the current module. For convenience,
      <code>module.exports</code> is also accessible via the
      <code>exports</code> module-global. <code>module</code> is not actually a
      global but rather local to each module.
    </p>
    <h3 id="module.children"><code>module.children</code></h3>
    <!-- YAML
added: v0.1.16
-->
    <ul>
      <li>{module[]}</li>
    </ul>
    <p>The module objects required for the first time by this one.</p>
    <h3 id="module.exports"><code>module.exports</code></h3>
    <!-- YAML
added: v0.1.16
-->
    <ul>
      <li>{Object}</li>
    </ul>
    <p>
      The <code>module.exports</code> object is created by the
      <code>Module</code> system. Sometimes this is not acceptable; many want
      their module to be an instance of some class. To do this, assign the
      desired export object to <code>module.exports</code>. Assigning the
      desired object to <code>exports</code> will simply rebind the local
      <code>exports</code> variable, which is probably not what is desired.
    </p>
    <p>
      For example, suppose we were making a module called <code>a.js</code>:
    </p>
    <div class="sourceCode" id="cb20">
      <pre
        class="sourceCode js"
      ><code class="sourceCode javascript"><a class="sourceLine" id="cb20-1" title="1"><span class="kw">const</span> EventEmitter <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;events&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb20-2" title="2"></a>
<a class="sourceLine" id="cb20-3" title="3"><span class="va">module</span>.<span class="at">exports</span> <span class="op">=</span> <span class="kw">new</span> <span class="at">EventEmitter</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb20-4" title="4"></a>
<a class="sourceLine" id="cb20-5" title="5"><span class="co">// Do some work, and after some time emit</span></a>
<a class="sourceLine" id="cb20-6" title="6"><span class="co">// the &#39;ready&#39; event from the module itself.</span></a>
<a class="sourceLine" id="cb20-7" title="7"><span class="at">setTimeout</span>(() <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb20-8" title="8">  <span class="va">module</span>.<span class="va">exports</span>.<span class="at">emit</span>(<span class="st">&#39;ready&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb20-9" title="9"><span class="op">},</span> <span class="dv">1000</span>)<span class="op">;</span></a></code></pre>
    </div>
    <p>Then in another file we could do:</p>
    <div class="sourceCode" id="cb21">
      <pre
        class="sourceCode js"
      ><code class="sourceCode javascript"><a class="sourceLine" id="cb21-1" title="1"><span class="kw">const</span> a <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;./a&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb21-2" title="2"><span class="va">a</span>.<span class="at">on</span>(<span class="st">&#39;ready&#39;</span><span class="op">,</span> () <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb21-3" title="3">  <span class="va">console</span>.<span class="at">log</span>(<span class="st">&#39;module &quot;a&quot; is ready&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb21-4" title="4"><span class="op">}</span>)<span class="op">;</span></a></code></pre>
    </div>
    <p>
      Assignment to <code>module.exports</code> must be done immediately. It
      cannot be done in any callbacks. This does not work:
    </p>
    <p><code>x.js</code>:</p>
    <div class="sourceCode" id="cb22">
      <pre
        class="sourceCode js"
      ><code class="sourceCode javascript"><a class="sourceLine" id="cb22-1" title="1"><span class="at">setTimeout</span>(() <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb22-2" title="2">  <span class="va">module</span>.<span class="at">exports</span> <span class="op">=</span> <span class="op">{</span> <span class="dt">a</span><span class="op">:</span> <span class="st">&#39;hello&#39;</span> <span class="op">};</span></a>
<a class="sourceLine" id="cb22-3" title="3"><span class="op">},</span> <span class="dv">0</span>)<span class="op">;</span></a></code></pre>
    </div>
    <p><code>y.js</code>:</p>
    <div class="sourceCode" id="cb23">
      <pre
        class="sourceCode js"
      ><code class="sourceCode javascript"><a class="sourceLine" id="cb23-1" title="1"><span class="kw">const</span> x <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;./x&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb23-2" title="2"><span class="va">console</span>.<span class="at">log</span>(<span class="va">x</span>.<span class="at">a</span>)<span class="op">;</span></a></code></pre>
    </div>
    <h4 id="exports-shortcut"><code>exports</code> shortcut</h4>
    <!-- YAML
added: v0.1.16
-->
    <p>
      The <code>exports</code> variable is available within a module’s
      file-level scope, and is assigned the value of
      <code>module.exports</code> before the module is evaluated.
    </p>
    <p>
      It allows a shortcut, so that <code>module.exports.f = ...</code> can be
      written more succinctly as <code>exports.f = ...</code>. However, be aware
      that like any variable, if a new value is assigned to
      <code>exports</code>, it is no longer bound to
      <code>module.exports</code>:
    </p>
    <div class="sourceCode" id="cb24">
      <pre
        class="sourceCode js"
      ><code class="sourceCode javascript"><a class="sourceLine" id="cb24-1" title="1"><span class="va">module</span>.<span class="va">exports</span>.<span class="at">hello</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span> <span class="co">// Exported from require of module</span></a>
<a class="sourceLine" id="cb24-2" title="2">exports <span class="op">=</span> <span class="op">{</span> <span class="dt">hello</span><span class="op">:</span> <span class="kw">false</span> <span class="op">};</span>  <span class="co">// Not exported, only available in the module</span></a></code></pre>
    </div>
    <p>
      When the <code>module.exports</code> property is being completely replaced
      by a new object, it is common to also reassign <code>exports</code>:
    </p>
    <!-- eslint-disable func-name-matching -->
    <div class="sourceCode" id="cb25">
      <pre
        class="sourceCode js"
      ><code class="sourceCode javascript"><a class="sourceLine" id="cb25-1" title="1"><span class="va">module</span>.<span class="at">exports</span> <span class="op">=</span> exports <span class="op">=</span> <span class="kw">function</span> <span class="at">Constructor</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb25-2" title="2">  <span class="co">// ... etc.</span></a>
<a class="sourceLine" id="cb25-3" title="3"><span class="op">};</span></a></code></pre>
    </div>
    <p>
      To illustrate the behavior, imagine this hypothetical implementation of
      <code>require()</code>, which is quite similar to what is actually done by
      <code>require()</code>:
    </p>
    <div class="sourceCode" id="cb26">
      <pre
        class="sourceCode js"
      ><code class="sourceCode javascript"><a class="sourceLine" id="cb26-1" title="1"><span class="kw">function</span> <span class="at">require</span>(<span class="co">/* ... */</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb26-2" title="2">  <span class="kw">const</span> module <span class="op">=</span> <span class="op">{</span> <span class="dt">exports</span><span class="op">:</span> <span class="op">{}</span> <span class="op">};</span></a>
<a class="sourceLine" id="cb26-3" title="3">  ((module<span class="op">,</span> exports) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb26-4" title="4">    <span class="co">// Module code here. In this example, define a function.</span></a>
<a class="sourceLine" id="cb26-5" title="5">    <span class="kw">function</span> <span class="at">someFunc</span>() <span class="op">{}</span></a>
<a class="sourceLine" id="cb26-6" title="6">    exports <span class="op">=</span> someFunc<span class="op">;</span></a>
<a class="sourceLine" id="cb26-7" title="7">    <span class="co">// At this point, exports is no longer a shortcut to module.exports, and</span></a>
<a class="sourceLine" id="cb26-8" title="8">    <span class="co">// this module will still export an empty default object.</span></a>
<a class="sourceLine" id="cb26-9" title="9">    <span class="va">module</span>.<span class="at">exports</span> <span class="op">=</span> someFunc<span class="op">;</span></a>
<a class="sourceLine" id="cb26-10" title="10">    <span class="co">// At this point, the module will now export someFunc, instead of the</span></a>
<a class="sourceLine" id="cb26-11" title="11">    <span class="co">// default object.</span></a>
<a class="sourceLine" id="cb26-12" title="12">  <span class="op">}</span>)(module<span class="op">,</span> <span class="va">module</span>.<span class="at">exports</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb26-13" title="13">  <span class="cf">return</span> <span class="va">module</span>.<span class="at">exports</span><span class="op">;</span></a>
<a class="sourceLine" id="cb26-14" title="14"><span class="op">}</span></a></code></pre>
    </div>
    <h3 id="module.filename"><code>module.filename</code></h3>
    <!-- YAML
added: v0.1.16
-->
    <ul>
      <li>{string}</li>
    </ul>
    <p>The fully resolved filename of the module.</p>
    <h3 id="module.id"><code>module.id</code></h3>
    <!-- YAML
added: v0.1.16
-->
    <ul>
      <li>{string}</li>
    </ul>
    <p>
      The identifier for the module. Typically this is the fully resolved
      filename.
    </p>
    <h3 id="module.ispreloading"><code>module.isPreloading</code></h3>
    <!-- YAML
added:
  - v15.4.0
  - v14.17.0
-->
    <ul>
      <li>
        Type: {boolean} <code>true</code> if the module is running during the
        Node.js preload phase.
      </li>
    </ul>
    <h3 id="module.loaded"><code>module.loaded</code></h3>
    <!-- YAML
added: v0.1.16
-->
    <ul>
      <li>{boolean}</li>
    </ul>
    <p>
      Whether or not the module is done loading, or is in the process of
      loading.
    </p>
    <h3 id="module.parent"><code>module.parent</code></h3>
    <!-- YAML
added: v0.1.16
deprecated:
  - v14.6.0
  - v12.19.0
-->
    <blockquote>
      <p>
        Stability: 0 - Deprecated: Please use
        <a href="#modules_require_main"><code>require.main</code></a> and
        <a href="#modules_module_children"><code>module.children</code></a>
        instead.
      </p>
    </blockquote>
    <ul>
      <li>{module | null | undefined}</li>
    </ul>
    <p>
      The module that first required this one, or <code>null</code> if the
      current module is the entry point of the current process, or
      <code>undefined</code> if the module was loaded by something that is not a
      CommonJS module (E.G.: REPL or <code>import</code>).
    </p>
    <h3 id="module.path"><code>module.path</code></h3>
    <!-- YAML
added: v11.14.0
-->
    <ul>
      <li>{string}</li>
    </ul>
    <p>
      The directory name of the module. This is usually the same as the
      <a href="path.md#path_path_dirname_path"><code>path.dirname()</code></a>
      of the <a href="#modules_module_id"><code>module.id</code></a
      >.
    </p>
    <h3 id="module.paths"><code>module.paths</code></h3>
    <!-- YAML
added: v0.4.0
-->
    <ul>
      <li>{string[]}</li>
    </ul>
    <p>The search paths for the module.</p>
    <h3 id="module.requireid"><code>module.require(id)</code></h3>
    <!-- YAML
added: v0.5.1
-->
    <ul>
      <li><code>id</code> {string}</li>
      <li>Returns: {any} exported module content</li>
    </ul>
    <p>
      The <code>module.require()</code> method provides a way to load a module
      as if <code>require()</code> was called from the original module.
    </p>
    <p>
      In order to do this, it is necessary to get a reference to the
      <code>module</code> object. Since <code>require()</code> returns the
      <code>module.exports</code>, and the <code>module</code> is typically
      <em>only</em> available within a specific module’s code, it must be
      explicitly exported in order to be used.
    </p>
    <h2 id="the-module-object-1">The <code>Module</code> object</h2>
    <p>
      This section was moved to
      <a href="module.md#module_the_module_object"
        >Modules: <code>module</code> core module</a
      >.
    </p>
    <!-- Anchors to make sure old links find a target -->
    <ul>
      <li>
        <a
          id="modules_module_builtinmodules"
          href="module.html#module_module_builtinmodules"
          ><code>module.builtinModules</code></a
        >
      </li>
      <li>
        <a
          id="modules_module_createrequire_filename"
          href="module.html#module_module_createrequire_filename"
          ><code>module.createRequire(filename)</code></a
        >
      </li>
      <li>
        <a
          id="modules_module_syncbuiltinesmexports"
          href="module.html#module_module_syncbuiltinesmexports"
          ><code>module.syncBuiltinESMExports()</code></a
        >
      </li>
    </ul>
    <h2 id="source-map-v3-support">Source map v3 support</h2>
    <p>
      This section was moved to
      <a href="module.md#module_source_map_v3_support"
        >Modules: <code>module</code> core module</a
      >.
    </p>
    <!-- Anchors to make sure old links find a target -->
    <ul>
      <li>
        <a
          id="modules_module_findsourcemap_path_error"
          href="module.html#module_module_findsourcemap_path"
          ><code>module.findSourceMap(path)</code></a
        >
      </li>
      <li>
        <a
          id="modules_class_module_sourcemap"
          href="module.html#module_class_module_sourcemap"
          >Class: <code>module.SourceMap</code></a
        >
        <ul>
          <li>
            <a
              id="modules_new_sourcemap_payload"
              href="module.html#module_new_sourcemap_payload"
              ><code>new SourceMap(payload)</code></a
            >
          </li>
          <li>
            <a
              id="modules_sourcemap_payload"
              href="module.html#module_sourcemap_payload"
              ><code>sourceMap.payload</code></a
            >
          </li>
          <li>
            <a
              id="modules_sourcemap_findentry_linenumber_columnnumber"
              href="module.html#module_sourcemap_findentry_linenumber_columnnumber"
              ><code>sourceMap.findEntry(lineNumber, columnNumber)</code></a
            >
          </li>
        </ul>
      </li>
    </ul>
  </body>
</html>
