<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>stream</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
</head>
<body>
<h1 id="stream">Stream</h1>
<!--introduced_in=v0.10.0-->
<blockquote>
<p>Stability: 2 - Stable</p>
</blockquote>
<!-- source_link=lib/stream.js -->
<p>A stream is an abstract interface for working with streaming data in Node.js. The <code>stream</code> module provides an API for implementing the stream interface.</p>
<p>There are many stream objects provided by Node.js. For instance, a <a href="http.md#http_class_http_incomingmessage">request to an HTTP server</a> and <a href="process.md#process_process_stdout"><code>process.stdout</code></a> are both stream instances.</p>
<p>Streams can be readable, writable, or both. All streams are instances of <a href="events.md#events_class_eventemitter"><code>EventEmitter</code></a>.</p>
<p>To access the <code>stream</code> module:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">const</span> stream <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;stream&#39;</span>)<span class="op">;</span></a></code></pre></div>
<p>The <code>stream</code> module is useful for creating new types of stream instances. It is usually not necessary to use the <code>stream</code> module to consume streams.</p>
<h2 id="organization-of-this-document">Organization of this document</h2>
<p>This document contains two primary sections and a third section for notes. The first section explains how to use existing streams within an application. The second section explains how to create new types of streams.</p>
<h2 id="types-of-streams">Types of streams</h2>
<p>There are four fundamental stream types within Node.js:</p>
<ul>
<li><a href="#stream_class_stream_writable"><code>Writable</code></a>: streams to which data can be written (for example, <a href="fs.md#fs_fs_createwritestream_path_options"><code>fs.createWriteStream()</code></a>).</li>
<li><a href="#stream_class_stream_readable"><code>Readable</code></a>: streams from which data can be read (for example, <a href="fs.md#fs_fs_createreadstream_path_options"><code>fs.createReadStream()</code></a>).</li>
<li><a href="#stream_class_stream_duplex"><code>Duplex</code></a>: streams that are both <code>Readable</code> and <code>Writable</code> (for example, <a href="net.md#net_class_net_socket"><code>net.Socket</code></a>).</li>
<li><a href="#stream_class_stream_transform"><code>Transform</code></a>: <code>Duplex</code> streams that can modify or transform the data as it is written and read (for example, <a href="zlib.md#zlib_zlib_createdeflate_options"><code>zlib.createDeflate()</code></a>).</li>
</ul>
<p>Additionally, this module includes the utility functions <a href="#stream_stream_pipeline_source_transforms_destination_callback"><code>stream.pipeline()</code></a>, <a href="#stream_stream_finished_stream_options_callback"><code>stream.finished()</code></a>, <a href="#stream_stream_readable_from_iterable_options"><code>stream.Readable.from()</code></a> and <a href="#stream_stream_addabortsignal_signal_stream"><code>stream.addAbortSignal()</code></a>.</p>
<h3 id="streams-promises-api">Streams Promises API</h3>
<!-- YAML
added: v15.0.0
-->
<p>The <code>stream/promises</code> API provides an alternative set of asynchronous utility functions for streams that return <code>Promise</code> objects rather than using callbacks. The API is accessible via <code>require('stream/promises')</code> or <code>require('stream').promises</code>.</p>
<h3 id="object-mode">Object mode</h3>
<p>All streams created by Node.js APIs operate exclusively on strings and <code>Buffer</code> (or <code>Uint8Array</code>) objects. It is possible, however, for stream implementations to work with other types of JavaScript values (with the exception of <code>null</code>, which serves a special purpose within streams). Such streams are considered to operate in “object mode”.</p>
<p>Stream instances are switched into object mode using the <code>objectMode</code> option when the stream is created. Attempting to switch an existing stream into object mode is not safe.</p>
<h3 id="buffering">Buffering</h3>
<!--type=misc-->
<p>Both <a href="#stream_class_stream_writable"><code>Writable</code></a> and <a href="#stream_class_stream_readable"><code>Readable</code></a> streams will store data in an internal buffer.</p>
<p>The amount of data potentially buffered depends on the <code>highWaterMark</code> option passed into the stream’s constructor. For normal streams, the <code>highWaterMark</code> option specifies a <a href="#stream_highwatermark_discrepancy_after_calling_readable_setencoding">total number of bytes</a>. For streams operating in object mode, the <code>highWaterMark</code> specifies a total number of objects.</p>
<p>Data is buffered in <code>Readable</code> streams when the implementation calls <a href="#stream_readable_push_chunk_encoding"><code>stream.push(chunk)</code></a>. If the consumer of the Stream does not call <a href="#stream_readable_read_size"><code>stream.read()</code></a>, the data will sit in the internal queue until it is consumed.</p>
<p>Once the total size of the internal read buffer reaches the threshold specified by <code>highWaterMark</code>, the stream will temporarily stop reading data from the underlying resource until the data currently buffered can be consumed (that is, the stream will stop calling the internal <a href="#stream_readable_read_size_1"><code>readable._read()</code></a> method that is used to fill the read buffer).</p>
<p>Data is buffered in <code>Writable</code> streams when the <a href="#stream_writable_write_chunk_encoding_callback"><code>writable.write(chunk)</code></a> method is called repeatedly. While the total size of the internal write buffer is below the threshold set by <code>highWaterMark</code>, calls to <code>writable.write()</code> will return <code>true</code>. Once the size of the internal buffer reaches or exceeds the <code>highWaterMark</code>, <code>false</code> will be returned.</p>
<p>A key goal of the <code>stream</code> API, particularly the <a href="#stream_readable_pipe_destination_options"><code>stream.pipe()</code></a> method, is to limit the buffering of data to acceptable levels such that sources and destinations of differing speeds will not overwhelm the available memory.</p>
<p>The <code>highWaterMark</code> option is a threshold, not a limit: it dictates the amount of data that a stream buffers before it stops asking for more data. It does not enforce a strict memory limitation in general. Specific stream implementations may choose to enforce stricter limits but doing so is optional.</p>
<p>Because <a href="#stream_class_stream_duplex"><code>Duplex</code></a> and <a href="#stream_class_stream_transform"><code>Transform</code></a> streams are both <code>Readable</code> and <code>Writable</code>, each maintains <em>two</em> separate internal buffers used for reading and writing, allowing each side to operate independently of the other while maintaining an appropriate and efficient flow of data. For example, <a href="net.md#net_class_net_socket"><code>net.Socket</code></a> instances are <a href="#stream_class_stream_duplex"><code>Duplex</code></a> streams whose <code>Readable</code> side allows consumption of data received <em>from</em> the socket and whose <code>Writable</code> side allows writing data <em>to</em> the socket. Because data may be written to the socket at a faster or slower rate than data is received, each side should operate (and buffer) independently of the other.</p>
<p>The mechanics of the internal buffering are an internal implementation detail and may be changed at any time. However, for certain advanced implementations, the internal buffers can be retrieved using <code>writable.writableBuffer</code> or <code>readable.readableBuffer</code>. Use of these undocumented properties is discouraged.</p>
<h2 id="api-for-stream-consumers">API for stream consumers</h2>
<!--type=misc-->
<p>Almost all Node.js applications, no matter how simple, use streams in some manner. The following is an example of using streams in a Node.js application that implements an HTTP server:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">const</span> http <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;http&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb2-2" title="2"></a>
<a class="sourceLine" id="cb2-3" title="3"><span class="kw">const</span> server <span class="op">=</span> <span class="va">http</span>.<span class="at">createServer</span>((req<span class="op">,</span> res) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb2-4" title="4">  <span class="co">// `req` is an http.IncomingMessage, which is a readable stream.</span></a>
<a class="sourceLine" id="cb2-5" title="5">  <span class="co">// `res` is an http.ServerResponse, which is a writable stream.</span></a>
<a class="sourceLine" id="cb2-6" title="6"></a>
<a class="sourceLine" id="cb2-7" title="7">  <span class="kw">let</span> body <span class="op">=</span> <span class="st">&#39;&#39;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb2-8" title="8">  <span class="co">// Get the data as utf8 strings.</span></a>
<a class="sourceLine" id="cb2-9" title="9">  <span class="co">// If an encoding is not set, Buffer objects will be received.</span></a>
<a class="sourceLine" id="cb2-10" title="10">  <span class="va">req</span>.<span class="at">setEncoding</span>(<span class="st">&#39;utf8&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb2-11" title="11"></a>
<a class="sourceLine" id="cb2-12" title="12">  <span class="co">// Readable streams emit &#39;data&#39; events once a listener is added.</span></a>
<a class="sourceLine" id="cb2-13" title="13">  <span class="va">req</span>.<span class="at">on</span>(<span class="st">&#39;data&#39;</span><span class="op">,</span> (chunk) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb2-14" title="14">    body <span class="op">+=</span> chunk<span class="op">;</span></a>
<a class="sourceLine" id="cb2-15" title="15">  <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb2-16" title="16"></a>
<a class="sourceLine" id="cb2-17" title="17">  <span class="co">// The &#39;end&#39; event indicates that the entire body has been received.</span></a>
<a class="sourceLine" id="cb2-18" title="18">  <span class="va">req</span>.<span class="at">on</span>(<span class="st">&#39;end&#39;</span><span class="op">,</span> () <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb2-19" title="19">    <span class="cf">try</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb2-20" title="20">      <span class="kw">const</span> data <span class="op">=</span> <span class="va">JSON</span>.<span class="at">parse</span>(body)<span class="op">;</span></a>
<a class="sourceLine" id="cb2-21" title="21">      <span class="co">// Write back something interesting to the user:</span></a>
<a class="sourceLine" id="cb2-22" title="22">      <span class="va">res</span>.<span class="at">write</span>(<span class="kw">typeof</span> data)<span class="op">;</span></a>
<a class="sourceLine" id="cb2-23" title="23">      <span class="va">res</span>.<span class="at">end</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb2-24" title="24">    <span class="op">}</span> <span class="cf">catch</span> (er) <span class="op">{</span></a>
<a class="sourceLine" id="cb2-25" title="25">      <span class="co">// uh oh! bad json!</span></a>
<a class="sourceLine" id="cb2-26" title="26">      <span class="va">res</span>.<span class="at">statusCode</span> <span class="op">=</span> <span class="dv">400</span><span class="op">;</span></a>
<a class="sourceLine" id="cb2-27" title="27">      <span class="cf">return</span> <span class="va">res</span>.<span class="at">end</span>(<span class="vs">`error: </span><span class="sc">${</span><span class="va">er</span>.<span class="at">message</span><span class="sc">}</span><span class="vs">`</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb2-28" title="28">    <span class="op">}</span></a>
<a class="sourceLine" id="cb2-29" title="29">  <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb2-30" title="30"><span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb2-31" title="31"></a>
<a class="sourceLine" id="cb2-32" title="32"><span class="va">server</span>.<span class="at">listen</span>(<span class="dv">1337</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb2-33" title="33"></a>
<a class="sourceLine" id="cb2-34" title="34"><span class="co">// $ curl localhost:1337 -d &quot;{}&quot;</span></a>
<a class="sourceLine" id="cb2-35" title="35"><span class="co">// object</span></a>
<a class="sourceLine" id="cb2-36" title="36"><span class="co">// $ curl localhost:1337 -d &quot;\&quot;foo\&quot;&quot;</span></a>
<a class="sourceLine" id="cb2-37" title="37"><span class="co">// string</span></a>
<a class="sourceLine" id="cb2-38" title="38"><span class="co">// $ curl localhost:1337 -d &quot;not json&quot;</span></a>
<a class="sourceLine" id="cb2-39" title="39"><span class="co">// error: Unexpected token o in JSON at position 1</span></a></code></pre></div>
<p><a href="#stream_class_stream_writable"><code>Writable</code></a> streams (such as <code>res</code> in the example) expose methods such as <code>write()</code> and <code>end()</code> that are used to write data onto the stream.</p>
<p><a href="#stream_class_stream_readable"><code>Readable</code></a> streams use the <a href="events.md#events_class_eventemitter"><code>EventEmitter</code></a> API for notifying application code when data is available to be read off the stream. That available data can be read from the stream in multiple ways.</p>
<p>Both <a href="#stream_class_stream_writable"><code>Writable</code></a> and <a href="#stream_class_stream_readable"><code>Readable</code></a> streams use the <a href="events.md#events_class_eventemitter"><code>EventEmitter</code></a> API in various ways to communicate the current state of the stream.</p>
<p><a href="#stream_class_stream_duplex"><code>Duplex</code></a> and <a href="#stream_class_stream_transform"><code>Transform</code></a> streams are both <a href="#stream_class_stream_writable"><code>Writable</code></a> and <a href="#stream_class_stream_readable"><code>Readable</code></a>.</p>
<p>Applications that are either writing data to or consuming data from a stream are not required to implement the stream interfaces directly and will generally have no reason to call <code>require('stream')</code>.</p>
<p>Developers wishing to implement new types of streams should refer to the section <a href="#stream_api_for_stream_implementers">API for stream implementers</a>.</p>
<h3 id="writable-streams">Writable streams</h3>
<p>Writable streams are an abstraction for a <em>destination</em> to which data is written.</p>
<p>Examples of <a href="#stream_class_stream_writable"><code>Writable</code></a> streams include:</p>
<ul>
<li><a href="http.md#http_class_http_clientrequest">HTTP requests, on the client</a></li>
<li><a href="http.md#http_class_http_serverresponse">HTTP responses, on the server</a></li>
<li><a href="fs.md#fs_class_fs_writestream">fs write streams</a></li>
<li><a href="zlib.md">zlib streams</a></li>
<li><a href="crypto.md">crypto streams</a></li>
<li><a href="net.md#net_class_net_socket">TCP sockets</a></li>
<li><a href="child_process.md#child_process_subprocess_stdin">child process stdin</a></li>
<li><a href="process.md#process_process_stdout"><code>process.stdout</code></a>, <a href="process.md#process_process_stderr"><code>process.stderr</code></a></li>
</ul>
<p>Some of these examples are actually <a href="#stream_class_stream_duplex"><code>Duplex</code></a> streams that implement the <a href="#stream_class_stream_writable"><code>Writable</code></a> interface.</p>
<p>All <a href="#stream_class_stream_writable"><code>Writable</code></a> streams implement the interface defined by the <code>stream.Writable</code> class.</p>
<p>While specific instances of <a href="#stream_class_stream_writable"><code>Writable</code></a> streams may differ in various ways, all <code>Writable</code> streams follow the same fundamental usage pattern as illustrated in the example below:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">const</span> myStream <span class="op">=</span> <span class="at">getWritableStreamSomehow</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb3-2" title="2"><span class="va">myStream</span>.<span class="at">write</span>(<span class="st">&#39;some data&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb3-3" title="3"><span class="va">myStream</span>.<span class="at">write</span>(<span class="st">&#39;some more data&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb3-4" title="4"><span class="va">myStream</span>.<span class="at">end</span>(<span class="st">&#39;done writing data&#39;</span>)<span class="op">;</span></a></code></pre></div>
<h4 id="class-stream.writable">Class: <code>stream.Writable</code></h4>
<!-- YAML
added: v0.9.4
-->
<!--type=class-->
<h5 id="event-close">Event: <code>'close'</code></h5>
<!-- YAML
added: v0.9.4
changes:
  - version: v10.0.0
    pr-url: https://github.com/nodejs/node/pull/18438
    description: Add `emitClose` option to specify if `'close'` is emitted on
                 destroy.
-->
<p>The <code>'close'</code> event is emitted when the stream and any of its underlying resources (a file descriptor, for example) have been closed. The event indicates that no more events will be emitted, and no further computation will occur.</p>
<p>A <a href="#stream_class_stream_writable"><code>Writable</code></a> stream will always emit the <code>'close'</code> event if it is created with the <code>emitClose</code> option.</p>
<h5 id="event-drain">Event: <code>'drain'</code></h5>
<!-- YAML
added: v0.9.4
-->
<p>If a call to <a href="#stream_writable_write_chunk_encoding_callback"><code>stream.write(chunk)</code></a> returns <code>false</code>, the <code>'drain'</code> event will be emitted when it is appropriate to resume writing data to the stream.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb4-1" title="1"><span class="co">// Write the data to the supplied writable stream one million times.</span></a>
<a class="sourceLine" id="cb4-2" title="2"><span class="co">// Be attentive to back-pressure.</span></a>
<a class="sourceLine" id="cb4-3" title="3"><span class="kw">function</span> <span class="at">writeOneMillionTimes</span>(writer<span class="op">,</span> data<span class="op">,</span> encoding<span class="op">,</span> callback) <span class="op">{</span></a>
<a class="sourceLine" id="cb4-4" title="4">  <span class="kw">let</span> i <span class="op">=</span> <span class="dv">1000000</span><span class="op">;</span></a>
<a class="sourceLine" id="cb4-5" title="5">  <span class="at">write</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb4-6" title="6">  <span class="kw">function</span> <span class="at">write</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb4-7" title="7">    <span class="kw">let</span> ok <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></a>
<a class="sourceLine" id="cb4-8" title="8">    <span class="cf">do</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb4-9" title="9">      i<span class="op">--;</span></a>
<a class="sourceLine" id="cb4-10" title="10">      <span class="cf">if</span> (i <span class="op">===</span> <span class="dv">0</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb4-11" title="11">        <span class="co">// Last time!</span></a>
<a class="sourceLine" id="cb4-12" title="12">        <span class="va">writer</span>.<span class="at">write</span>(data<span class="op">,</span> encoding<span class="op">,</span> callback)<span class="op">;</span></a>
<a class="sourceLine" id="cb4-13" title="13">      <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb4-14" title="14">        <span class="co">// See if we should continue, or wait.</span></a>
<a class="sourceLine" id="cb4-15" title="15">        <span class="co">// Don&#39;t pass the callback, because we&#39;re not done yet.</span></a>
<a class="sourceLine" id="cb4-16" title="16">        ok <span class="op">=</span> <span class="va">writer</span>.<span class="at">write</span>(data<span class="op">,</span> encoding)<span class="op">;</span></a>
<a class="sourceLine" id="cb4-17" title="17">      <span class="op">}</span></a>
<a class="sourceLine" id="cb4-18" title="18">    <span class="op">}</span> <span class="cf">while</span> (i <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> ok)<span class="op">;</span></a>
<a class="sourceLine" id="cb4-19" title="19">    <span class="cf">if</span> (i <span class="op">&gt;</span> <span class="dv">0</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb4-20" title="20">      <span class="co">// Had to stop early!</span></a>
<a class="sourceLine" id="cb4-21" title="21">      <span class="co">// Write some more once it drains.</span></a>
<a class="sourceLine" id="cb4-22" title="22">      <span class="va">writer</span>.<span class="at">once</span>(<span class="st">&#39;drain&#39;</span><span class="op">,</span> write)<span class="op">;</span></a>
<a class="sourceLine" id="cb4-23" title="23">    <span class="op">}</span></a>
<a class="sourceLine" id="cb4-24" title="24">  <span class="op">}</span></a>
<a class="sourceLine" id="cb4-25" title="25"><span class="op">}</span></a></code></pre></div>
<h5 id="event-error">Event: <code>'error'</code></h5>
<!-- YAML
added: v0.9.4
-->
<ul>
<li>{Error}</li>
</ul>
<p>The <code>'error'</code> event is emitted if an error occurred while writing or piping data. The listener callback is passed a single <code>Error</code> argument when called.</p>
<p>The stream is closed when the <code>'error'</code> event is emitted unless the <a href="#stream_new_stream_writable_options"><code>autoDestroy</code></a> option was set to <code>false</code> when creating the stream.</p>
<p>After <code>'error'</code>, no further events other than <code>'close'</code> <em>should</em> be emitted (including <code>'error'</code> events).</p>
<h5 id="event-finish">Event: <code>'finish'</code></h5>
<!-- YAML
added: v0.9.4
-->
<p>The <code>'finish'</code> event is emitted after the <a href="#stream_writable_end_chunk_encoding_callback"><code>stream.end()</code></a> method has been called, and all data has been flushed to the underlying system.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">const</span> writer <span class="op">=</span> <span class="at">getWritableStreamSomehow</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb5-2" title="2"><span class="cf">for</span> (<span class="kw">let</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">100</span><span class="op">;</span> i<span class="op">++</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb5-3" title="3">  <span class="va">writer</span>.<span class="at">write</span>(<span class="vs">`hello, #</span><span class="sc">${</span>i<span class="sc">}</span><span class="vs">!</span><span class="sc">\n</span><span class="vs">`</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb5-4" title="4"><span class="op">}</span></a>
<a class="sourceLine" id="cb5-5" title="5"><span class="va">writer</span>.<span class="at">on</span>(<span class="st">&#39;finish&#39;</span><span class="op">,</span> () <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb5-6" title="6">  <span class="va">console</span>.<span class="at">log</span>(<span class="st">&#39;All writes are now complete.&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb5-7" title="7"><span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb5-8" title="8"><span class="va">writer</span>.<span class="at">end</span>(<span class="st">&#39;This is the end</span><span class="sc">\n</span><span class="st">&#39;</span>)<span class="op">;</span></a></code></pre></div>
<h5 id="event-pipe">Event: <code>'pipe'</code></h5>
<!-- YAML
added: v0.9.4
-->
<ul>
<li><code>src</code> {stream.Readable} source stream that is piping to this writable</li>
</ul>
<p>The <code>'pipe'</code> event is emitted when the <a href="#stream_readable_pipe_destination_options"><code>stream.pipe()</code></a> method is called on a readable stream, adding this writable to its set of destinations.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">const</span> writer <span class="op">=</span> <span class="at">getWritableStreamSomehow</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb6-2" title="2"><span class="kw">const</span> reader <span class="op">=</span> <span class="at">getReadableStreamSomehow</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb6-3" title="3"><span class="va">writer</span>.<span class="at">on</span>(<span class="st">&#39;pipe&#39;</span><span class="op">,</span> (src) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb6-4" title="4">  <span class="va">console</span>.<span class="at">log</span>(<span class="st">&#39;Something is piping into the writer.&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb6-5" title="5">  <span class="va">assert</span>.<span class="at">equal</span>(src<span class="op">,</span> reader)<span class="op">;</span></a>
<a class="sourceLine" id="cb6-6" title="6"><span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb6-7" title="7"><span class="va">reader</span>.<span class="at">pipe</span>(writer)<span class="op">;</span></a></code></pre></div>
<h5 id="event-unpipe">Event: <code>'unpipe'</code></h5>
<!-- YAML
added: v0.9.4
-->
<ul>
<li><code>src</code> {stream.Readable} The source stream that <a href="#stream_readable_unpipe_destination">unpiped</a> this writable</li>
</ul>
<p>The <code>'unpipe'</code> event is emitted when the <a href="#stream_readable_unpipe_destination"><code>stream.unpipe()</code></a> method is called on a <a href="#stream_class_stream_readable"><code>Readable</code></a> stream, removing this <a href="#stream_class_stream_writable"><code>Writable</code></a> from its set of destinations.</p>
<p>This is also emitted in case this <a href="#stream_class_stream_writable"><code>Writable</code></a> stream emits an error when a <a href="#stream_class_stream_readable"><code>Readable</code></a> stream pipes into it.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">const</span> writer <span class="op">=</span> <span class="at">getWritableStreamSomehow</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb7-2" title="2"><span class="kw">const</span> reader <span class="op">=</span> <span class="at">getReadableStreamSomehow</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb7-3" title="3"><span class="va">writer</span>.<span class="at">on</span>(<span class="st">&#39;unpipe&#39;</span><span class="op">,</span> (src) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb7-4" title="4">  <span class="va">console</span>.<span class="at">log</span>(<span class="st">&#39;Something has stopped piping into the writer.&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb7-5" title="5">  <span class="va">assert</span>.<span class="at">equal</span>(src<span class="op">,</span> reader)<span class="op">;</span></a>
<a class="sourceLine" id="cb7-6" title="6"><span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb7-7" title="7"><span class="va">reader</span>.<span class="at">pipe</span>(writer)<span class="op">;</span></a>
<a class="sourceLine" id="cb7-8" title="8"><span class="va">reader</span>.<span class="at">unpipe</span>(writer)<span class="op">;</span></a></code></pre></div>
<h5 id="writable.cork"><code>writable.cork()</code></h5>
<!-- YAML
added: v0.11.2
-->
<p>The <code>writable.cork()</code> method forces all written data to be buffered in memory. The buffered data will be flushed when either the <a href="#stream_writable_uncork"><code>stream.uncork()</code></a> or <a href="#stream_writable_end_chunk_encoding_callback"><code>stream.end()</code></a> methods are called.</p>
<p>The primary intent of <code>writable.cork()</code> is to accommodate a situation in which several small chunks are written to the stream in rapid succession. Instead of immediately forwarding them to the underlying destination, <code>writable.cork()</code> buffers all the chunks until <code>writable.uncork()</code> is called, which will pass them all to <code>writable._writev()</code>, if present. This prevents a head-of-line blocking situation where data is being buffered while waiting for the first small chunk to be processed. However, use of <code>writable.cork()</code> without implementing <code>writable._writev()</code> may have an adverse effect on throughput.</p>
<p>See also: <a href="#stream_writable_uncork"><code>writable.uncork()</code></a>, <a href="#stream_writable_writev_chunks_callback"><code>writable._writev()</code></a>.</p>
<h5 id="writable.destroyerror"><code>writable.destroy([error])</code></h5>
<!-- YAML
added: v8.0.0
changes:
  - version: v14.0.0
    pr-url: https://github.com/nodejs/node/pull/29197
    description: Work as a no-op on a stream that has already been destroyed.
-->
<ul>
<li><code>error</code> {Error} Optional, an error to emit with <code>'error'</code> event.</li>
<li>Returns: {this}</li>
</ul>
<p>Destroy the stream. Optionally emit an <code>'error'</code> event, and emit a <code>'close'</code> event (unless <code>emitClose</code> is set to <code>false</code>). After this call, the writable stream has ended and subsequent calls to <code>write()</code> or <code>end()</code> will result in an <code>ERR_STREAM_DESTROYED</code> error. This is a destructive and immediate way to destroy a stream. Previous calls to <code>write()</code> may not have drained, and may trigger an <code>ERR_STREAM_DESTROYED</code> error. Use <code>end()</code> instead of destroy if data should flush before close, or wait for the <code>'drain'</code> event before destroying the stream.</p>
<pre class="cjs"><code>const { Writable } = require(&#39;stream&#39;);

const myStream = new Writable();

const fooErr = new Error(&#39;foo error&#39;);
myStream.destroy(fooErr);
myStream.on(&#39;error&#39;, (fooErr) =&gt; console.error(fooErr.message)); // foo error</code></pre>
<pre class="cjs"><code>const { Writable } = require(&#39;stream&#39;);

const myStream = new Writable();

myStream.destroy();
myStream.on(&#39;error&#39;, function wontHappen() {});</code></pre>
<pre class="cjs"><code>const { Writable } = require(&#39;stream&#39;);

const myStream = new Writable();
myStream.destroy();

myStream.write(&#39;foo&#39;, (error) =&gt; console.error(error.code));
// ERR_STREAM_DESTROYED</code></pre>
<p>Once <code>destroy()</code> has been called any further calls will be a no-op and no further errors except from <code>_destroy()</code> may be emitted as <code>'error'</code>.</p>
<p>Implementors should not override this method, but instead implement <a href="#stream_writable_destroy_err_callback"><code>writable._destroy()</code></a>.</p>
<h5 id="writable.destroyed"><code>writable.destroyed</code></h5>
<!-- YAML
added: v8.0.0
-->
<ul>
<li>{boolean}</li>
</ul>
<p>Is <code>true</code> after <a href="#stream_writable_destroy_error"><code>writable.destroy()</code></a> has been called.</p>
<pre class="cjs"><code>const { Writable } = require(&#39;stream&#39;);

const myStream = new Writable();

console.log(myStream.destroyed); // false
myStream.destroy();
console.log(myStream.destroyed); // true</code></pre>
<h5 id="writable.endchunk-encoding-callback"><code>writable.end([chunk[, encoding]][, callback])</code></h5>
<!-- YAML
added: v0.9.4
changes:
  - version: v15.0.0
    pr-url: https://github.com/nodejs/node/pull/34101
    description: The `callback` is invoked before 'finish' or on error.
  - version: v14.0.0
    pr-url: https://github.com/nodejs/node/pull/29747
    description: The `callback` is invoked if 'finish' or 'error' is emitted.
  - version: v10.0.0
    pr-url: https://github.com/nodejs/node/pull/18780
    description: This method now returns a reference to `writable`.
  - version: v8.0.0
    pr-url: https://github.com/nodejs/node/pull/11608
    description: The `chunk` argument can now be a `Uint8Array` instance.
-->
<ul>
<li><code>chunk</code> {string|Buffer|Uint8Array|any} Optional data to write. For streams not operating in object mode, <code>chunk</code> must be a string, <code>Buffer</code> or <code>Uint8Array</code>. For object mode streams, <code>chunk</code> may be any JavaScript value other than <code>null</code>.</li>
<li><code>encoding</code> {string} The encoding if <code>chunk</code> is a string</li>
<li><code>callback</code> {Function} Callback for when the stream is finished.</li>
<li>Returns: {this}</li>
</ul>
<p>Calling the <code>writable.end()</code> method signals that no more data will be written to the <a href="#stream_class_stream_writable"><code>Writable</code></a>. The optional <code>chunk</code> and <code>encoding</code> arguments allow one final additional chunk of data to be written immediately before closing the stream.</p>
<p>Calling the <a href="#stream_writable_write_chunk_encoding_callback"><code>stream.write()</code></a> method after calling <a href="#stream_writable_end_chunk_encoding_callback"><code>stream.end()</code></a> will raise an error.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb12-1" title="1"><span class="co">// Write &#39;hello, &#39; and then end with &#39;world!&#39;.</span></a>
<a class="sourceLine" id="cb12-2" title="2"><span class="kw">const</span> fs <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;fs&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb12-3" title="3"><span class="kw">const</span> file <span class="op">=</span> <span class="va">fs</span>.<span class="at">createWriteStream</span>(<span class="st">&#39;example.txt&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb12-4" title="4"><span class="va">file</span>.<span class="at">write</span>(<span class="st">&#39;hello, &#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb12-5" title="5"><span class="va">file</span>.<span class="at">end</span>(<span class="st">&#39;world!&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb12-6" title="6"><span class="co">// Writing more now is not allowed!</span></a></code></pre></div>
<h5 id="writable.setdefaultencodingencoding"><code>writable.setDefaultEncoding(encoding)</code></h5>
<!-- YAML
added: v0.11.15
changes:
  - version: v6.1.0
    pr-url: https://github.com/nodejs/node/pull/5040
    description: This method now returns a reference to `writable`.
-->
<ul>
<li><code>encoding</code> {string} The new default encoding</li>
<li>Returns: {this}</li>
</ul>
<p>The <code>writable.setDefaultEncoding()</code> method sets the default <code>encoding</code> for a <a href="#stream_class_stream_writable"><code>Writable</code></a> stream.</p>
<h5 id="writable.uncork"><code>writable.uncork()</code></h5>
<!-- YAML
added: v0.11.2
-->
<p>The <code>writable.uncork()</code> method flushes all data buffered since <a href="#stream_writable_cork"><code>stream.cork()</code></a> was called.</p>
<p>When using <a href="#stream_writable_cork"><code>writable.cork()</code></a> and <code>writable.uncork()</code> to manage the buffering of writes to a stream, it is recommended that calls to <code>writable.uncork()</code> be deferred using <code>process.nextTick()</code>. Doing so allows batching of all <code>writable.write()</code> calls that occur within a given Node.js event loop phase.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb13-1" title="1"><span class="va">stream</span>.<span class="at">cork</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb13-2" title="2"><span class="va">stream</span>.<span class="at">write</span>(<span class="st">&#39;some &#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb13-3" title="3"><span class="va">stream</span>.<span class="at">write</span>(<span class="st">&#39;data &#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb13-4" title="4"><span class="va">process</span>.<span class="at">nextTick</span>(() <span class="kw">=&gt;</span> <span class="va">stream</span>.<span class="at">uncork</span>())<span class="op">;</span></a></code></pre></div>
<p>If the <a href="#stream_writable_cork"><code>writable.cork()</code></a> method is called multiple times on a stream, the same number of calls to <code>writable.uncork()</code> must be called to flush the buffered data.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb14-1" title="1"><span class="va">stream</span>.<span class="at">cork</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb14-2" title="2"><span class="va">stream</span>.<span class="at">write</span>(<span class="st">&#39;some &#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb14-3" title="3"><span class="va">stream</span>.<span class="at">cork</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb14-4" title="4"><span class="va">stream</span>.<span class="at">write</span>(<span class="st">&#39;data &#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb14-5" title="5"><span class="va">process</span>.<span class="at">nextTick</span>(() <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb14-6" title="6">  <span class="va">stream</span>.<span class="at">uncork</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb14-7" title="7">  <span class="co">// The data will not be flushed until uncork() is called a second time.</span></a>
<a class="sourceLine" id="cb14-8" title="8">  <span class="va">stream</span>.<span class="at">uncork</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb14-9" title="9"><span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<p>See also: <a href="#stream_writable_cork"><code>writable.cork()</code></a>.</p>
<h5 id="writable.writable"><code>writable.writable</code></h5>
<!-- YAML
added: v11.4.0
-->
<ul>
<li>{boolean}</li>
</ul>
<p>Is <code>true</code> if it is safe to call <a href="#stream_writable_write_chunk_encoding_callback"><code>writable.write()</code></a>, which means the stream has not been destroyed, errored or ended.</p>
<h5 id="writable.writableended"><code>writable.writableEnded</code></h5>
<!-- YAML
added: v12.9.0
-->
<ul>
<li>{boolean}</li>
</ul>
<p>Is <code>true</code> after <a href="#stream_writable_end_chunk_encoding_callback"><code>writable.end()</code></a> has been called. This property does not indicate whether the data has been flushed, for this use <a href="#stream_writable_writablefinished"><code>writable.writableFinished</code></a> instead.</p>
<h5 id="writable.writablecorked"><code>writable.writableCorked</code></h5>
<!-- YAML
added:
 - v13.2.0
 - v12.16.0
-->
<ul>
<li>{integer}</li>
</ul>
<p>Number of times <a href="#stream_writable_uncork"><code>writable.uncork()</code></a> needs to be called in order to fully uncork the stream.</p>
<h5 id="writable.writablefinished"><code>writable.writableFinished</code></h5>
<!-- YAML
added: v12.6.0
-->
<ul>
<li>{boolean}</li>
</ul>
<p>Is set to <code>true</code> immediately before the <a href="#stream_event_finish"><code>'finish'</code></a> event is emitted.</p>
<h5 id="writable.writablehighwatermark"><code>writable.writableHighWaterMark</code></h5>
<!-- YAML
added: v9.3.0
-->
<ul>
<li>{number}</li>
</ul>
<p>Return the value of <code>highWaterMark</code> passed when creating this <code>Writable</code>.</p>
<h5 id="writable.writablelength"><code>writable.writableLength</code></h5>
<!-- YAML
added: v9.4.0
-->
<ul>
<li>{number}</li>
</ul>
<p>This property contains the number of bytes (or objects) in the queue ready to be written. The value provides introspection data regarding the status of the <code>highWaterMark</code>.</p>
<h5 id="writable.writableneeddrain"><code>writable.writableNeedDrain</code></h5>
<!-- YAML
added:
  - v15.2.0
  - v14.17.0
-->
<ul>
<li>{boolean}</li>
</ul>
<p>Is <code>true</code> if the stream’s buffer has been full and stream will emit <code>'drain'</code>.</p>
<h5 id="writable.writableobjectmode"><code>writable.writableObjectMode</code></h5>
<!-- YAML
added: v12.3.0
-->
<ul>
<li>{boolean}</li>
</ul>
<p>Getter for the property <code>objectMode</code> of a given <code>Writable</code> stream.</p>
<h5 id="writable.writechunk-encoding-callback"><code>writable.write(chunk[, encoding][, callback])</code></h5>
<!-- YAML
added: v0.9.4
changes:
  - version: v8.0.0
    pr-url: https://github.com/nodejs/node/pull/11608
    description: The `chunk` argument can now be a `Uint8Array` instance.
  - version: v6.0.0
    pr-url: https://github.com/nodejs/node/pull/6170
    description: Passing `null` as the `chunk` parameter will always be
                 considered invalid now, even in object mode.
-->
<ul>
<li><code>chunk</code> {string|Buffer|Uint8Array|any} Optional data to write. For streams not operating in object mode, <code>chunk</code> must be a string, <code>Buffer</code> or <code>Uint8Array</code>. For object mode streams, <code>chunk</code> may be any JavaScript value other than <code>null</code>.</li>
<li><code>encoding</code> {string|null} The encoding, if <code>chunk</code> is a string. <strong>Default:</strong> <code>'utf8'</code></li>
<li><code>callback</code> {Function} Callback for when this chunk of data is flushed.</li>
<li>Returns: {boolean} <code>false</code> if the stream wishes for the calling code to wait for the <code>'drain'</code> event to be emitted before continuing to write additional data; otherwise <code>true</code>.</li>
</ul>
<p>The <code>writable.write()</code> method writes some data to the stream, and calls the supplied <code>callback</code> once the data has been fully handled. If an error occurs, the <code>callback</code> will be called with the error as its first argument. The <code>callback</code> is called asynchronously and before <code>'error'</code> is emitted.</p>
<p>The return value is <code>true</code> if the internal buffer is less than the <code>highWaterMark</code> configured when the stream was created after admitting <code>chunk</code>. If <code>false</code> is returned, further attempts to write data to the stream should stop until the <a href="#stream_event_drain"><code>'drain'</code></a> event is emitted.</p>
<p>While a stream is not draining, calls to <code>write()</code> will buffer <code>chunk</code>, and return false. Once all currently buffered chunks are drained (accepted for delivery by the operating system), the <code>'drain'</code> event will be emitted. It is recommended that once <code>write()</code> returns false, no more chunks be written until the <code>'drain'</code> event is emitted. While calling <code>write()</code> on a stream that is not draining is allowed, Node.js will buffer all written chunks until maximum memory usage occurs, at which point it will abort unconditionally. Even before it aborts, high memory usage will cause poor garbage collector performance and high RSS (which is not typically released back to the system, even after the memory is no longer required). Since TCP sockets may never drain if the remote peer does not read the data, writing a socket that is not draining may lead to a remotely exploitable vulnerability.</p>
<p>Writing data while the stream is not draining is particularly problematic for a <a href="#stream_class_stream_transform"><code>Transform</code></a>, because the <code>Transform</code> streams are paused by default until they are piped or a <code>'data'</code> or <code>'readable'</code> event handler is added.</p>
<p>If the data to be written can be generated or fetched on demand, it is recommended to encapsulate the logic into a <a href="#stream_class_stream_readable"><code>Readable</code></a> and use <a href="#stream_readable_pipe_destination_options"><code>stream.pipe()</code></a>. However, if calling <code>write()</code> is preferred, it is possible to respect backpressure and avoid memory issues using the <a href="#stream_event_drain"><code>'drain'</code></a> event:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb15-1" title="1"><span class="kw">function</span> <span class="at">write</span>(data<span class="op">,</span> cb) <span class="op">{</span></a>
<a class="sourceLine" id="cb15-2" title="2">  <span class="cf">if</span> (<span class="op">!</span><span class="va">stream</span>.<span class="at">write</span>(data)) <span class="op">{</span></a>
<a class="sourceLine" id="cb15-3" title="3">    <span class="va">stream</span>.<span class="at">once</span>(<span class="st">&#39;drain&#39;</span><span class="op">,</span> cb)<span class="op">;</span></a>
<a class="sourceLine" id="cb15-4" title="4">  <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb15-5" title="5">    <span class="va">process</span>.<span class="at">nextTick</span>(cb)<span class="op">;</span></a>
<a class="sourceLine" id="cb15-6" title="6">  <span class="op">}</span></a>
<a class="sourceLine" id="cb15-7" title="7"><span class="op">}</span></a>
<a class="sourceLine" id="cb15-8" title="8"></a>
<a class="sourceLine" id="cb15-9" title="9"><span class="co">// Wait for cb to be called before doing any other write.</span></a>
<a class="sourceLine" id="cb15-10" title="10"><span class="at">write</span>(<span class="st">&#39;hello&#39;</span><span class="op">,</span> () <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb15-11" title="11">  <span class="va">console</span>.<span class="at">log</span>(<span class="st">&#39;Write completed, do more writes now.&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb15-12" title="12"><span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<p>A <code>Writable</code> stream in object mode will always ignore the <code>encoding</code> argument.</p>
<h3 id="readable-streams">Readable streams</h3>
<p>Readable streams are an abstraction for a <em>source</em> from which data is consumed.</p>
<p>Examples of <code>Readable</code> streams include:</p>
<ul>
<li><a href="http.md#http_class_http_incomingmessage">HTTP responses, on the client</a></li>
<li><a href="http.md#http_class_http_incomingmessage">HTTP requests, on the server</a></li>
<li><a href="fs.md#fs_class_fs_readstream">fs read streams</a></li>
<li><a href="zlib.md">zlib streams</a></li>
<li><a href="crypto.md">crypto streams</a></li>
<li><a href="net.md#net_class_net_socket">TCP sockets</a></li>
<li><a href="child_process.md#child_process_subprocess_stdout">child process stdout and stderr</a></li>
<li><a href="process.md#process_process_stdin"><code>process.stdin</code></a></li>
</ul>
<p>All <a href="#stream_class_stream_readable"><code>Readable</code></a> streams implement the interface defined by the <code>stream.Readable</code> class.</p>
<h4 id="two-reading-modes">Two reading modes</h4>
<p><code>Readable</code> streams effectively operate in one of two modes: flowing and paused. These modes are separate from <a href="#stream_object_mode">object mode</a>. A <a href="#stream_class_stream_readable"><code>Readable</code></a> stream can be in object mode or not, regardless of whether it is in flowing mode or paused mode.</p>
<ul>
<li><p>In flowing mode, data is read from the underlying system automatically and provided to an application as quickly as possible using events via the <a href="events.md#events_class_eventemitter"><code>EventEmitter</code></a> interface.</p></li>
<li><p>In paused mode, the <a href="#stream_readable_read_size"><code>stream.read()</code></a> method must be called explicitly to read chunks of data from the stream.</p></li>
</ul>
<p>All <a href="#stream_class_stream_readable"><code>Readable</code></a> streams begin in paused mode but can be switched to flowing mode in one of the following ways:</p>
<ul>
<li>Adding a <a href="#stream_event_data"><code>'data'</code></a> event handler.</li>
<li>Calling the <a href="#stream_readable_resume"><code>stream.resume()</code></a> method.</li>
<li>Calling the <a href="#stream_readable_pipe_destination_options"><code>stream.pipe()</code></a> method to send the data to a <a href="#stream_class_stream_writable"><code>Writable</code></a>.</li>
</ul>
<p>The <code>Readable</code> can switch back to paused mode using one of the following:</p>
<ul>
<li>If there are no pipe destinations, by calling the <a href="#stream_readable_pause"><code>stream.pause()</code></a> method.</li>
<li>If there are pipe destinations, by removing all pipe destinations. Multiple pipe destinations may be removed by calling the <a href="#stream_readable_unpipe_destination"><code>stream.unpipe()</code></a> method.</li>
</ul>
<p>The important concept to remember is that a <code>Readable</code> will not generate data until a mechanism for either consuming or ignoring that data is provided. If the consuming mechanism is disabled or taken away, the <code>Readable</code> will <em>attempt</em> to stop generating the data.</p>
<p>For backward compatibility reasons, removing <a href="#stream_event_data"><code>'data'</code></a> event handlers will <strong>not</strong> automatically pause the stream. Also, if there are piped destinations, then calling <a href="#stream_readable_pause"><code>stream.pause()</code></a> will not guarantee that the stream will <em>remain</em> paused once those destinations drain and ask for more data.</p>
<p>If a <a href="#stream_class_stream_readable"><code>Readable</code></a> is switched into flowing mode and there are no consumers available to handle the data, that data will be lost. This can occur, for instance, when the <code>readable.resume()</code> method is called without a listener attached to the <code>'data'</code> event, or when a <code>'data'</code> event handler is removed from the stream.</p>
<p>Adding a <a href="#stream_event_readable"><code>'readable'</code></a> event handler automatically makes the stream stop flowing, and the data has to be consumed via <a href="#stream_readable_read_size"><code>readable.read()</code></a>. If the <a href="#stream_event_readable"><code>'readable'</code></a> event handler is removed, then the stream will start flowing again if there is a <a href="#stream_event_data"><code>'data'</code></a> event handler.</p>
<h4 id="three-states">Three states</h4>
<p>The “two modes” of operation for a <code>Readable</code> stream are a simplified abstraction for the more complicated internal state management that is happening within the <code>Readable</code> stream implementation.</p>
<p>Specifically, at any given point in time, every <code>Readable</code> is in one of three possible states:</p>
<ul>
<li><code>readable.readableFlowing === null</code></li>
<li><code>readable.readableFlowing === false</code></li>
<li><code>readable.readableFlowing === true</code></li>
</ul>
<p>When <code>readable.readableFlowing</code> is <code>null</code>, no mechanism for consuming the stream’s data is provided. Therefore, the stream will not generate data. While in this state, attaching a listener for the <code>'data'</code> event, calling the <code>readable.pipe()</code> method, or calling the <code>readable.resume()</code> method will switch <code>readable.readableFlowing</code> to <code>true</code>, causing the <code>Readable</code> to begin actively emitting events as data is generated.</p>
<p>Calling <code>readable.pause()</code>, <code>readable.unpipe()</code>, or receiving backpressure will cause the <code>readable.readableFlowing</code> to be set as <code>false</code>, temporarily halting the flowing of events but <em>not</em> halting the generation of data. While in this state, attaching a listener for the <code>'data'</code> event will not switch <code>readable.readableFlowing</code> to <code>true</code>.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb16-1" title="1"><span class="kw">const</span> <span class="op">{</span> PassThrough<span class="op">,</span> Writable <span class="op">}</span> <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;stream&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb16-2" title="2"><span class="kw">const</span> pass <span class="op">=</span> <span class="kw">new</span> <span class="at">PassThrough</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb16-3" title="3"><span class="kw">const</span> writable <span class="op">=</span> <span class="kw">new</span> <span class="at">Writable</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb16-4" title="4"></a>
<a class="sourceLine" id="cb16-5" title="5"><span class="va">pass</span>.<span class="at">pipe</span>(writable)<span class="op">;</span></a>
<a class="sourceLine" id="cb16-6" title="6"><span class="va">pass</span>.<span class="at">unpipe</span>(writable)<span class="op">;</span></a>
<a class="sourceLine" id="cb16-7" title="7"><span class="co">// readableFlowing is now false.</span></a>
<a class="sourceLine" id="cb16-8" title="8"></a>
<a class="sourceLine" id="cb16-9" title="9"><span class="va">pass</span>.<span class="at">on</span>(<span class="st">&#39;data&#39;</span><span class="op">,</span> (chunk) <span class="kw">=&gt;</span> <span class="op">{</span> <span class="va">console</span>.<span class="at">log</span>(<span class="va">chunk</span>.<span class="at">toString</span>())<span class="op">;</span> <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb16-10" title="10"><span class="va">pass</span>.<span class="at">write</span>(<span class="st">&#39;ok&#39;</span>)<span class="op">;</span>  <span class="co">// Will not emit &#39;data&#39;.</span></a>
<a class="sourceLine" id="cb16-11" title="11"><span class="va">pass</span>.<span class="at">resume</span>()<span class="op">;</span>     <span class="co">// Must be called to make stream emit &#39;data&#39;.</span></a></code></pre></div>
<p>While <code>readable.readableFlowing</code> is <code>false</code>, data may be accumulating within the stream’s internal buffer.</p>
<h4 id="choose-one-api-style">Choose one API style</h4>
<p>The <code>Readable</code> stream API evolved across multiple Node.js versions and provides multiple methods of consuming stream data. In general, developers should choose <em>one</em> of the methods of consuming data and <em>should never</em> use multiple methods to consume data from a single stream. Specifically, using a combination of <code>on('data')</code>, <code>on('readable')</code>, <code>pipe()</code>, or async iterators could lead to unintuitive behavior.</p>
<p>Use of the <code>readable.pipe()</code> method is recommended for most users as it has been implemented to provide the easiest way of consuming stream data. Developers that require more fine-grained control over the transfer and generation of data can use the <a href="events.md#events_class_eventemitter"><code>EventEmitter</code></a> and <code>readable.on('readable')</code>/<code>readable.read()</code> or the <code>readable.pause()</code>/<code>readable.resume()</code> APIs.</p>
<h4 id="class-stream.readable">Class: <code>stream.Readable</code></h4>
<!-- YAML
added: v0.9.4
-->
<!--type=class-->
<h5 id="event-close-1">Event: <code>'close'</code></h5>
<!-- YAML
added: v0.9.4
changes:
  - version: v10.0.0
    pr-url: https://github.com/nodejs/node/pull/18438
    description: Add `emitClose` option to specify if `'close'` is emitted on
                 destroy.
-->
<p>The <code>'close'</code> event is emitted when the stream and any of its underlying resources (a file descriptor, for example) have been closed. The event indicates that no more events will be emitted, and no further computation will occur.</p>
<p>A <a href="#stream_class_stream_readable"><code>Readable</code></a> stream will always emit the <code>'close'</code> event if it is created with the <code>emitClose</code> option.</p>
<h5 id="event-data">Event: <code>'data'</code></h5>
<!-- YAML
added: v0.9.4
-->
<ul>
<li><code>chunk</code> {Buffer|string|any} The chunk of data. For streams that are not operating in object mode, the chunk will be either a string or <code>Buffer</code>. For streams that are in object mode, the chunk can be any JavaScript value other than <code>null</code>.</li>
</ul>
<p>The <code>'data'</code> event is emitted whenever the stream is relinquishing ownership of a chunk of data to a consumer. This may occur whenever the stream is switched in flowing mode by calling <code>readable.pipe()</code>, <code>readable.resume()</code>, or by attaching a listener callback to the <code>'data'</code> event. The <code>'data'</code> event will also be emitted whenever the <code>readable.read()</code> method is called and a chunk of data is available to be returned.</p>
<p>Attaching a <code>'data'</code> event listener to a stream that has not been explicitly paused will switch the stream into flowing mode. Data will then be passed as soon as it is available.</p>
<p>The listener callback will be passed the chunk of data as a string if a default encoding has been specified for the stream using the <code>readable.setEncoding()</code> method; otherwise the data will be passed as a <code>Buffer</code>.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb17-1" title="1"><span class="kw">const</span> readable <span class="op">=</span> <span class="at">getReadableStreamSomehow</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb17-2" title="2"><span class="va">readable</span>.<span class="at">on</span>(<span class="st">&#39;data&#39;</span><span class="op">,</span> (chunk) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb17-3" title="3">  <span class="va">console</span>.<span class="at">log</span>(<span class="vs">`Received </span><span class="sc">${</span><span class="va">chunk</span>.<span class="at">length</span><span class="sc">}</span><span class="vs"> bytes of data.`</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb17-4" title="4"><span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<h5 id="event-end">Event: <code>'end'</code></h5>
<!-- YAML
added: v0.9.4
-->
<p>The <code>'end'</code> event is emitted when there is no more data to be consumed from the stream.</p>
<p>The <code>'end'</code> event <strong>will not be emitted</strong> unless the data is completely consumed. This can be accomplished by switching the stream into flowing mode, or by calling <a href="#stream_readable_read_size"><code>stream.read()</code></a> repeatedly until all data has been consumed.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb18-1" title="1"><span class="kw">const</span> readable <span class="op">=</span> <span class="at">getReadableStreamSomehow</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb18-2" title="2"><span class="va">readable</span>.<span class="at">on</span>(<span class="st">&#39;data&#39;</span><span class="op">,</span> (chunk) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb18-3" title="3">  <span class="va">console</span>.<span class="at">log</span>(<span class="vs">`Received </span><span class="sc">${</span><span class="va">chunk</span>.<span class="at">length</span><span class="sc">}</span><span class="vs"> bytes of data.`</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb18-4" title="4"><span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb18-5" title="5"><span class="va">readable</span>.<span class="at">on</span>(<span class="st">&#39;end&#39;</span><span class="op">,</span> () <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb18-6" title="6">  <span class="va">console</span>.<span class="at">log</span>(<span class="st">&#39;There will be no more data.&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb18-7" title="7"><span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<h5 id="event-error-1">Event: <code>'error'</code></h5>
<!-- YAML
added: v0.9.4
-->
<ul>
<li>{Error}</li>
</ul>
<p>The <code>'error'</code> event may be emitted by a <code>Readable</code> implementation at any time. Typically, this may occur if the underlying stream is unable to generate data due to an underlying internal failure, or when a stream implementation attempts to push an invalid chunk of data.</p>
<p>The listener callback will be passed a single <code>Error</code> object.</p>
<h5 id="event-pause">Event: <code>'pause'</code></h5>
<!-- YAML
added: v0.9.4
-->
<p>The <code>'pause'</code> event is emitted when <a href="#stream_readable_pause"><code>stream.pause()</code></a> is called and <code>readableFlowing</code> is not <code>false</code>.</p>
<h5 id="event-readable">Event: <code>'readable'</code></h5>
<!-- YAML
added: v0.9.4
changes:
  - version: v10.0.0
    pr-url: https://github.com/nodejs/node/pull/17979
    description: The `'readable'` is always emitted in the next tick after
                 `.push()` is called.
  - version: v10.0.0
    pr-url: https://github.com/nodejs/node/pull/18994
    description: Using `'readable'` requires calling `.read()`.
-->
<p>The <code>'readable'</code> event is emitted when there is data available to be read from the stream. In some cases, attaching a listener for the <code>'readable'</code> event will cause some amount of data to be read into an internal buffer.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb19-1" title="1"><span class="kw">const</span> readable <span class="op">=</span> <span class="at">getReadableStreamSomehow</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb19-2" title="2"><span class="va">readable</span>.<span class="at">on</span>(<span class="st">&#39;readable&#39;</span><span class="op">,</span> <span class="kw">function</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb19-3" title="3">  <span class="co">// There is some data to read now.</span></a>
<a class="sourceLine" id="cb19-4" title="4">  <span class="kw">let</span> data<span class="op">;</span></a>
<a class="sourceLine" id="cb19-5" title="5"></a>
<a class="sourceLine" id="cb19-6" title="6">  <span class="cf">while</span> (data <span class="op">=</span> <span class="kw">this</span>.<span class="at">read</span>()) <span class="op">{</span></a>
<a class="sourceLine" id="cb19-7" title="7">    <span class="va">console</span>.<span class="at">log</span>(data)<span class="op">;</span></a>
<a class="sourceLine" id="cb19-8" title="8">  <span class="op">}</span></a>
<a class="sourceLine" id="cb19-9" title="9"><span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<p>The <code>'readable'</code> event will also be emitted once the end of the stream data has been reached but before the <code>'end'</code> event is emitted.</p>
<p>Effectively, the <code>'readable'</code> event indicates that the stream has new information: either new data is available or the end of the stream has been reached. In the former case, <a href="#stream_readable_read_size"><code>stream.read()</code></a> will return the available data. In the latter case, <a href="#stream_readable_read_size"><code>stream.read()</code></a> will return <code>null</code>. For instance, in the following example, <code>foo.txt</code> is an empty file:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb20-1" title="1"><span class="kw">const</span> fs <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;fs&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb20-2" title="2"><span class="kw">const</span> rr <span class="op">=</span> <span class="va">fs</span>.<span class="at">createReadStream</span>(<span class="st">&#39;foo.txt&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb20-3" title="3"><span class="va">rr</span>.<span class="at">on</span>(<span class="st">&#39;readable&#39;</span><span class="op">,</span> () <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb20-4" title="4">  <span class="va">console</span>.<span class="at">log</span>(<span class="vs">`readable: </span><span class="sc">${</span><span class="va">rr</span>.<span class="at">read</span>()<span class="sc">}</span><span class="vs">`</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb20-5" title="5"><span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb20-6" title="6"><span class="va">rr</span>.<span class="at">on</span>(<span class="st">&#39;end&#39;</span><span class="op">,</span> () <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb20-7" title="7">  <span class="va">console</span>.<span class="at">log</span>(<span class="st">&#39;end&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb20-8" title="8"><span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<p>The output of running this script is:</p>
<pre class="console"><code>$ node test.js
readable: null
end</code></pre>
<p>In general, the <code>readable.pipe()</code> and <code>'data'</code> event mechanisms are easier to understand than the <code>'readable'</code> event. However, handling <code>'readable'</code> might result in increased throughput.</p>
<p>If both <code>'readable'</code> and <a href="#stream_event_data"><code>'data'</code></a> are used at the same time, <code>'readable'</code> takes precedence in controlling the flow, i.e. <code>'data'</code> will be emitted only when <a href="#stream_readable_read_size"><code>stream.read()</code></a> is called. The <code>readableFlowing</code> property would become <code>false</code>. If there are <code>'data'</code> listeners when <code>'readable'</code> is removed, the stream will start flowing, i.e. <code>'data'</code> events will be emitted without calling <code>.resume()</code>.</p>
<h5 id="event-resume">Event: <code>'resume'</code></h5>
<!-- YAML
added: v0.9.4
-->
<p>The <code>'resume'</code> event is emitted when <a href="#stream_readable_resume"><code>stream.resume()</code></a> is called and <code>readableFlowing</code> is not <code>true</code>.</p>
<h5 id="readable.destroyerror"><code>readable.destroy([error])</code></h5>
<!-- YAML
added: v8.0.0
changes:
  - version: v14.0.0
    pr-url: https://github.com/nodejs/node/pull/29197
    description: Work as a no-op on a stream that has already been destroyed.
-->
<ul>
<li><code>error</code> {Error} Error which will be passed as payload in <code>'error'</code> event</li>
<li>Returns: {this}</li>
</ul>
<p>Destroy the stream. Optionally emit an <code>'error'</code> event, and emit a <code>'close'</code> event (unless <code>emitClose</code> is set to <code>false</code>). After this call, the readable stream will release any internal resources and subsequent calls to <code>push()</code> will be ignored.</p>
<p>Once <code>destroy()</code> has been called any further calls will be a no-op and no further errors except from <code>_destroy()</code> may be emitted as <code>'error'</code>.</p>
<p>Implementors should not override this method, but instead implement <a href="#stream_readable_destroy_err_callback"><code>readable._destroy()</code></a>.</p>
<h5 id="readable.destroyed"><code>readable.destroyed</code></h5>
<!-- YAML
added: v8.0.0
-->
<ul>
<li>{boolean}</li>
</ul>
<p>Is <code>true</code> after <a href="#stream_readable_destroy_error"><code>readable.destroy()</code></a> has been called.</p>
<h5 id="readable.ispaused"><code>readable.isPaused()</code></h5>
<!-- YAML
added: v0.11.14
-->
<ul>
<li>Returns: {boolean}</li>
</ul>
<p>The <code>readable.isPaused()</code> method returns the current operating state of the <code>Readable</code>. This is used primarily by the mechanism that underlies the <code>readable.pipe()</code> method. In most typical cases, there will be no reason to use this method directly.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb22-1" title="1"><span class="kw">const</span> readable <span class="op">=</span> <span class="kw">new</span> <span class="va">stream</span>.<span class="at">Readable</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb22-2" title="2"></a>
<a class="sourceLine" id="cb22-3" title="3"><span class="va">readable</span>.<span class="at">isPaused</span>()<span class="op">;</span> <span class="co">// === false</span></a>
<a class="sourceLine" id="cb22-4" title="4"><span class="va">readable</span>.<span class="at">pause</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb22-5" title="5"><span class="va">readable</span>.<span class="at">isPaused</span>()<span class="op">;</span> <span class="co">// === true</span></a>
<a class="sourceLine" id="cb22-6" title="6"><span class="va">readable</span>.<span class="at">resume</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb22-7" title="7"><span class="va">readable</span>.<span class="at">isPaused</span>()<span class="op">;</span> <span class="co">// === false</span></a></code></pre></div>
<h5 id="readable.pause"><code>readable.pause()</code></h5>
<!-- YAML
added: v0.9.4
-->
<ul>
<li>Returns: {this}</li>
</ul>
<p>The <code>readable.pause()</code> method will cause a stream in flowing mode to stop emitting <a href="#stream_event_data"><code>'data'</code></a> events, switching out of flowing mode. Any data that becomes available will remain in the internal buffer.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb23-1" title="1"><span class="kw">const</span> readable <span class="op">=</span> <span class="at">getReadableStreamSomehow</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb23-2" title="2"><span class="va">readable</span>.<span class="at">on</span>(<span class="st">&#39;data&#39;</span><span class="op">,</span> (chunk) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb23-3" title="3">  <span class="va">console</span>.<span class="at">log</span>(<span class="vs">`Received </span><span class="sc">${</span><span class="va">chunk</span>.<span class="at">length</span><span class="sc">}</span><span class="vs"> bytes of data.`</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb23-4" title="4">  <span class="va">readable</span>.<span class="at">pause</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb23-5" title="5">  <span class="va">console</span>.<span class="at">log</span>(<span class="st">&#39;There will be no additional data for 1 second.&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb23-6" title="6">  <span class="at">setTimeout</span>(() <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb23-7" title="7">    <span class="va">console</span>.<span class="at">log</span>(<span class="st">&#39;Now data will start flowing again.&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb23-8" title="8">    <span class="va">readable</span>.<span class="at">resume</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb23-9" title="9">  <span class="op">},</span> <span class="dv">1000</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb23-10" title="10"><span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<p>The <code>readable.pause()</code> method has no effect if there is a <code>'readable'</code> event listener.</p>
<h5 id="readable.pipedestination-options"><code>readable.pipe(destination[, options])</code></h5>
<!-- YAML
added: v0.9.4
-->
<ul>
<li><code>destination</code> {stream.Writable} The destination for writing data</li>
<li><code>options</code> {Object} Pipe options
<ul>
<li><code>end</code> {boolean} End the writer when the reader ends. <strong>Default:</strong> <code>true</code>.</li>
</ul></li>
<li>Returns: {stream.Writable} The <em>destination</em>, allowing for a chain of pipes if it is a <a href="#stream_class_stream_duplex"><code>Duplex</code></a> or a <a href="#stream_class_stream_transform"><code>Transform</code></a> stream</li>
</ul>
<p>The <code>readable.pipe()</code> method attaches a <a href="#stream_class_stream_writable"><code>Writable</code></a> stream to the <code>readable</code>, causing it to switch automatically into flowing mode and push all of its data to the attached <a href="#stream_class_stream_writable"><code>Writable</code></a>. The flow of data will be automatically managed so that the destination <code>Writable</code> stream is not overwhelmed by a faster <code>Readable</code> stream.</p>
<p>The following example pipes all of the data from the <code>readable</code> into a file named <code>file.txt</code>:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb24-1" title="1"><span class="kw">const</span> fs <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;fs&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb24-2" title="2"><span class="kw">const</span> readable <span class="op">=</span> <span class="at">getReadableStreamSomehow</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb24-3" title="3"><span class="kw">const</span> writable <span class="op">=</span> <span class="va">fs</span>.<span class="at">createWriteStream</span>(<span class="st">&#39;file.txt&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb24-4" title="4"><span class="co">// All the data from readable goes into &#39;file.txt&#39;.</span></a>
<a class="sourceLine" id="cb24-5" title="5"><span class="va">readable</span>.<span class="at">pipe</span>(writable)<span class="op">;</span></a></code></pre></div>
<p>It is possible to attach multiple <code>Writable</code> streams to a single <code>Readable</code> stream.</p>
<p>The <code>readable.pipe()</code> method returns a reference to the <em>destination</em> stream making it possible to set up chains of piped streams:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb25-1" title="1"><span class="kw">const</span> fs <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;fs&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb25-2" title="2"><span class="kw">const</span> r <span class="op">=</span> <span class="va">fs</span>.<span class="at">createReadStream</span>(<span class="st">&#39;file.txt&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb25-3" title="3"><span class="kw">const</span> z <span class="op">=</span> <span class="va">zlib</span>.<span class="at">createGzip</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb25-4" title="4"><span class="kw">const</span> w <span class="op">=</span> <span class="va">fs</span>.<span class="at">createWriteStream</span>(<span class="st">&#39;file.txt.gz&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb25-5" title="5"><span class="va">r</span>.<span class="at">pipe</span>(z).<span class="at">pipe</span>(w)<span class="op">;</span></a></code></pre></div>
<p>By default, <a href="#stream_writable_end_chunk_encoding_callback"><code>stream.end()</code></a> is called on the destination <code>Writable</code> stream when the source <code>Readable</code> stream emits <a href="#stream_event_end"><code>'end'</code></a>, so that the destination is no longer writable. To disable this default behavior, the <code>end</code> option can be passed as <code>false</code>, causing the destination stream to remain open:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb26-1" title="1"><span class="va">reader</span>.<span class="at">pipe</span>(writer<span class="op">,</span> <span class="op">{</span> <span class="dt">end</span><span class="op">:</span> <span class="kw">false</span> <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb26-2" title="2"><span class="va">reader</span>.<span class="at">on</span>(<span class="st">&#39;end&#39;</span><span class="op">,</span> () <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb26-3" title="3">  <span class="va">writer</span>.<span class="at">end</span>(<span class="st">&#39;Goodbye</span><span class="sc">\n</span><span class="st">&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb26-4" title="4"><span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<p>One important caveat is that if the <code>Readable</code> stream emits an error during processing, the <code>Writable</code> destination <em>is not closed</em> automatically. If an error occurs, it will be necessary to <em>manually</em> close each stream in order to prevent memory leaks.</p>
<p>The <a href="process.md#process_process_stderr"><code>process.stderr</code></a> and <a href="process.md#process_process_stdout"><code>process.stdout</code></a> <code>Writable</code> streams are never closed until the Node.js process exits, regardless of the specified options.</p>
<h5 id="readable.readsize"><code>readable.read([size])</code></h5>
<!-- YAML
added: v0.9.4
-->
<ul>
<li><code>size</code> {number} Optional argument to specify how much data to read.</li>
<li>Returns: {string|Buffer|null|any}</li>
</ul>
<p>The <code>readable.read()</code> method pulls some data out of the internal buffer and returns it. If no data available to be read, <code>null</code> is returned. By default, the data will be returned as a <code>Buffer</code> object unless an encoding has been specified using the <code>readable.setEncoding()</code> method or the stream is operating in object mode.</p>
<p>The optional <code>size</code> argument specifies a specific number of bytes to read. If <code>size</code> bytes are not available to be read, <code>null</code> will be returned <em>unless</em> the stream has ended, in which case all of the data remaining in the internal buffer will be returned.</p>
<p>If the <code>size</code> argument is not specified, all of the data contained in the internal buffer will be returned.</p>
<p>The <code>size</code> argument must be less than or equal to 1 GiB.</p>
<p>The <code>readable.read()</code> method should only be called on <code>Readable</code> streams operating in paused mode. In flowing mode, <code>readable.read()</code> is called automatically until the internal buffer is fully drained.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb27-1" title="1"><span class="kw">const</span> readable <span class="op">=</span> <span class="at">getReadableStreamSomehow</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb27-2" title="2"></a>
<a class="sourceLine" id="cb27-3" title="3"><span class="co">// &#39;readable&#39; may be triggered multiple times as data is buffered in</span></a>
<a class="sourceLine" id="cb27-4" title="4"><span class="va">readable</span>.<span class="at">on</span>(<span class="st">&#39;readable&#39;</span><span class="op">,</span> () <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb27-5" title="5">  <span class="kw">let</span> chunk<span class="op">;</span></a>
<a class="sourceLine" id="cb27-6" title="6">  <span class="va">console</span>.<span class="at">log</span>(<span class="st">&#39;Stream is readable (new data received in buffer)&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb27-7" title="7">  <span class="co">// Use a loop to make sure we read all currently available data</span></a>
<a class="sourceLine" id="cb27-8" title="8">  <span class="cf">while</span> (<span class="kw">null</span> <span class="op">!==</span> (chunk <span class="op">=</span> <span class="va">readable</span>.<span class="at">read</span>())) <span class="op">{</span></a>
<a class="sourceLine" id="cb27-9" title="9">    <span class="va">console</span>.<span class="at">log</span>(<span class="vs">`Read </span><span class="sc">${</span><span class="va">chunk</span>.<span class="at">length</span><span class="sc">}</span><span class="vs"> bytes of data...`</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb27-10" title="10">  <span class="op">}</span></a>
<a class="sourceLine" id="cb27-11" title="11"><span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb27-12" title="12"></a>
<a class="sourceLine" id="cb27-13" title="13"><span class="co">// &#39;end&#39; will be triggered once when there is no more data available</span></a>
<a class="sourceLine" id="cb27-14" title="14"><span class="va">readable</span>.<span class="at">on</span>(<span class="st">&#39;end&#39;</span><span class="op">,</span> () <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb27-15" title="15">  <span class="va">console</span>.<span class="at">log</span>(<span class="st">&#39;Reached end of stream.&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb27-16" title="16"><span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<p>Each call to <code>readable.read()</code> returns a chunk of data, or <code>null</code>. The chunks are not concatenated. A <code>while</code> loop is necessary to consume all data currently in the buffer. When reading a large file <code>.read()</code> may return <code>null</code>, having consumed all buffered content so far, but there is still more data to come not yet buffered. In this case a new <code>'readable'</code> event will be emitted when there is more data in the buffer. Finally the <code>'end'</code> event will be emitted when there is no more data to come.</p>
<p>Therefore to read a file’s whole contents from a <code>readable</code>, it is necessary to collect chunks across multiple <code>'readable'</code> events:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb28-1" title="1"><span class="kw">const</span> chunks <span class="op">=</span> []<span class="op">;</span></a>
<a class="sourceLine" id="cb28-2" title="2"></a>
<a class="sourceLine" id="cb28-3" title="3"><span class="va">readable</span>.<span class="at">on</span>(<span class="st">&#39;readable&#39;</span><span class="op">,</span> () <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb28-4" title="4">  <span class="kw">let</span> chunk<span class="op">;</span></a>
<a class="sourceLine" id="cb28-5" title="5">  <span class="cf">while</span> (<span class="kw">null</span> <span class="op">!==</span> (chunk <span class="op">=</span> <span class="va">readable</span>.<span class="at">read</span>())) <span class="op">{</span></a>
<a class="sourceLine" id="cb28-6" title="6">    <span class="va">chunks</span>.<span class="at">push</span>(chunk)<span class="op">;</span></a>
<a class="sourceLine" id="cb28-7" title="7">  <span class="op">}</span></a>
<a class="sourceLine" id="cb28-8" title="8"><span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb28-9" title="9"></a>
<a class="sourceLine" id="cb28-10" title="10"><span class="va">readable</span>.<span class="at">on</span>(<span class="st">&#39;end&#39;</span><span class="op">,</span> () <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb28-11" title="11">  <span class="kw">const</span> content <span class="op">=</span> <span class="va">chunks</span>.<span class="at">join</span>(<span class="st">&#39;&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb28-12" title="12"><span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<p>A <code>Readable</code> stream in object mode will always return a single item from a call to <a href="#stream_readable_read_size"><code>readable.read(size)</code></a>, regardless of the value of the <code>size</code> argument.</p>
<p>If the <code>readable.read()</code> method returns a chunk of data, a <code>'data'</code> event will also be emitted.</p>
<p>Calling <a href="#stream_readable_read_size"><code>stream.read([size])</code></a> after the <a href="#stream_event_end"><code>'end'</code></a> event has been emitted will return <code>null</code>. No runtime error will be raised.</p>
<h5 id="readable.readable"><code>readable.readable</code></h5>
<!-- YAML
added: v11.4.0
-->
<ul>
<li>{boolean}</li>
</ul>
<p>Is <code>true</code> if it is safe to call <a href="#stream_readable_read_size"><code>readable.read()</code></a>, which means the stream has not been destroyed or emitted <code>'error'</code> or <code>'end'</code>.</p>
<h5 id="readable.readableencoding"><code>readable.readableEncoding</code></h5>
<!-- YAML
added: v12.7.0
-->
<ul>
<li>{null|string}</li>
</ul>
<p>Getter for the property <code>encoding</code> of a given <code>Readable</code> stream. The <code>encoding</code> property can be set using the <a href="#stream_readable_setencoding_encoding"><code>readable.setEncoding()</code></a> method.</p>
<h5 id="readable.readableended"><code>readable.readableEnded</code></h5>
<!-- YAML
added: v12.9.0
-->
<ul>
<li>{boolean}</li>
</ul>
<p>Becomes <code>true</code> when <a href="#stream_event_end"><code>'end'</code></a> event is emitted.</p>
<h5 id="readable.readableflowing"><code>readable.readableFlowing</code></h5>
<!-- YAML
added: v9.4.0
-->
<ul>
<li>{boolean}</li>
</ul>
<p>This property reflects the current state of a <code>Readable</code> stream as described in the <a href="#stream_three_states">Three states</a> section.</p>
<h5 id="readable.readablehighwatermark"><code>readable.readableHighWaterMark</code></h5>
<!-- YAML
added: v9.3.0
-->
<ul>
<li>{number}</li>
</ul>
<p>Returns the value of <code>highWaterMark</code> passed when creating this <code>Readable</code>.</p>
<h5 id="readable.readablelength"><code>readable.readableLength</code></h5>
<!-- YAML
added: v9.4.0
-->
<ul>
<li>{number}</li>
</ul>
<p>This property contains the number of bytes (or objects) in the queue ready to be read. The value provides introspection data regarding the status of the <code>highWaterMark</code>.</p>
<h5 id="readable.readableobjectmode"><code>readable.readableObjectMode</code></h5>
<!-- YAML
added: v12.3.0
-->
<ul>
<li>{boolean}</li>
</ul>
<p>Getter for the property <code>objectMode</code> of a given <code>Readable</code> stream.</p>
<h5 id="readable.resume"><code>readable.resume()</code></h5>
<!-- YAML
added: v0.9.4
changes:
  - version: v10.0.0
    pr-url: https://github.com/nodejs/node/pull/18994
    description: The `resume()` has no effect if there is a `'readable'` event
                 listening.
-->
<ul>
<li>Returns: {this}</li>
</ul>
<p>The <code>readable.resume()</code> method causes an explicitly paused <code>Readable</code> stream to resume emitting <a href="#stream_event_data"><code>'data'</code></a> events, switching the stream into flowing mode.</p>
<p>The <code>readable.resume()</code> method can be used to fully consume the data from a stream without actually processing any of that data:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb29-1" title="1"><span class="at">getReadableStreamSomehow</span>()</a>
<a class="sourceLine" id="cb29-2" title="2">  .<span class="at">resume</span>()</a>
<a class="sourceLine" id="cb29-3" title="3">  .<span class="at">on</span>(<span class="st">&#39;end&#39;</span><span class="op">,</span> () <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb29-4" title="4">    <span class="va">console</span>.<span class="at">log</span>(<span class="st">&#39;Reached the end, but did not read anything.&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb29-5" title="5">  <span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<p>The <code>readable.resume()</code> method has no effect if there is a <code>'readable'</code> event listener.</p>
<h5 id="readable.setencodingencoding"><code>readable.setEncoding(encoding)</code></h5>
<!-- YAML
added: v0.9.4
-->
<ul>
<li><code>encoding</code> {string} The encoding to use.</li>
<li>Returns: {this}</li>
</ul>
<p>The <code>readable.setEncoding()</code> method sets the character encoding for data read from the <code>Readable</code> stream.</p>
<p>By default, no encoding is assigned and stream data will be returned as <code>Buffer</code> objects. Setting an encoding causes the stream data to be returned as strings of the specified encoding rather than as <code>Buffer</code> objects. For instance, calling <code>readable.setEncoding('utf8')</code> will cause the output data to be interpreted as UTF-8 data, and passed as strings. Calling <code>readable.setEncoding('hex')</code> will cause the data to be encoded in hexadecimal string format.</p>
<p>The <code>Readable</code> stream will properly handle multi-byte characters delivered through the stream that would otherwise become improperly decoded if simply pulled from the stream as <code>Buffer</code> objects.</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb30-1" title="1"><span class="kw">const</span> readable <span class="op">=</span> <span class="at">getReadableStreamSomehow</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb30-2" title="2"><span class="va">readable</span>.<span class="at">setEncoding</span>(<span class="st">&#39;utf8&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb30-3" title="3"><span class="va">readable</span>.<span class="at">on</span>(<span class="st">&#39;data&#39;</span><span class="op">,</span> (chunk) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb30-4" title="4">  <span class="va">assert</span>.<span class="at">equal</span>(<span class="kw">typeof</span> chunk<span class="op">,</span> <span class="st">&#39;string&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb30-5" title="5">  <span class="va">console</span>.<span class="at">log</span>(<span class="st">&#39;Got %d characters of string data:&#39;</span><span class="op">,</span> <span class="va">chunk</span>.<span class="at">length</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb30-6" title="6"><span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<h5 id="readable.unpipedestination"><code>readable.unpipe([destination])</code></h5>
<!-- YAML
added: v0.9.4
-->
<ul>
<li><code>destination</code> {stream.Writable} Optional specific stream to unpipe</li>
<li>Returns: {this}</li>
</ul>
<p>The <code>readable.unpipe()</code> method detaches a <code>Writable</code> stream previously attached using the <a href="#stream_readable_pipe_destination_options"><code>stream.pipe()</code></a> method.</p>
<p>If the <code>destination</code> is not specified, then <em>all</em> pipes are detached.</p>
<p>If the <code>destination</code> is specified, but no pipe is set up for it, then the method does nothing.</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb31-1" title="1"><span class="kw">const</span> fs <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;fs&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb31-2" title="2"><span class="kw">const</span> readable <span class="op">=</span> <span class="at">getReadableStreamSomehow</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb31-3" title="3"><span class="kw">const</span> writable <span class="op">=</span> <span class="va">fs</span>.<span class="at">createWriteStream</span>(<span class="st">&#39;file.txt&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb31-4" title="4"><span class="co">// All the data from readable goes into &#39;file.txt&#39;,</span></a>
<a class="sourceLine" id="cb31-5" title="5"><span class="co">// but only for the first second.</span></a>
<a class="sourceLine" id="cb31-6" title="6"><span class="va">readable</span>.<span class="at">pipe</span>(writable)<span class="op">;</span></a>
<a class="sourceLine" id="cb31-7" title="7"><span class="at">setTimeout</span>(() <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb31-8" title="8">  <span class="va">console</span>.<span class="at">log</span>(<span class="st">&#39;Stop writing to file.txt.&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb31-9" title="9">  <span class="va">readable</span>.<span class="at">unpipe</span>(writable)<span class="op">;</span></a>
<a class="sourceLine" id="cb31-10" title="10">  <span class="va">console</span>.<span class="at">log</span>(<span class="st">&#39;Manually close the file stream.&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb31-11" title="11">  <span class="va">writable</span>.<span class="at">end</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb31-12" title="12"><span class="op">},</span> <span class="dv">1000</span>)<span class="op">;</span></a></code></pre></div>
<h5 id="readable.unshiftchunk-encoding"><code>readable.unshift(chunk[, encoding])</code></h5>
<!-- YAML
added: v0.9.11
changes:
  - version: v8.0.0
    pr-url: https://github.com/nodejs/node/pull/11608
    description: The `chunk` argument can now be a `Uint8Array` instance.
-->
<ul>
<li><code>chunk</code> {Buffer|Uint8Array|string|null|any} Chunk of data to unshift onto the read queue. For streams not operating in object mode, <code>chunk</code> must be a string, <code>Buffer</code>, <code>Uint8Array</code> or <code>null</code>. For object mode streams, <code>chunk</code> may be any JavaScript value.</li>
<li><code>encoding</code> {string} Encoding of string chunks. Must be a valid <code>Buffer</code> encoding, such as <code>'utf8'</code> or <code>'ascii'</code>.</li>
</ul>
<p>Passing <code>chunk</code> as <code>null</code> signals the end of the stream (EOF) and behaves the same as <code>readable.push(null)</code>, after which no more data can be written. The EOF signal is put at the end of the buffer and any buffered data will still be flushed.</p>
<p>The <code>readable.unshift()</code> method pushes a chunk of data back into the internal buffer. This is useful in certain situations where a stream is being consumed by code that needs to “un-consume” some amount of data that it has optimistically pulled out of the source, so that the data can be passed on to some other party.</p>
<p>The <code>stream.unshift(chunk)</code> method cannot be called after the <a href="#stream_event_end"><code>'end'</code></a> event has been emitted or a runtime error will be thrown.</p>
<p>Developers using <code>stream.unshift()</code> often should consider switching to use of a <a href="#stream_class_stream_transform"><code>Transform</code></a> stream instead. See the <a href="#stream_api_for_stream_implementers">API for stream implementers</a> section for more information.</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb32-1" title="1"><span class="co">// Pull off a header delimited by \n\n.</span></a>
<a class="sourceLine" id="cb32-2" title="2"><span class="co">// Use unshift() if we get too much.</span></a>
<a class="sourceLine" id="cb32-3" title="3"><span class="co">// Call the callback with (error, header, stream).</span></a>
<a class="sourceLine" id="cb32-4" title="4"><span class="kw">const</span> <span class="op">{</span> StringDecoder <span class="op">}</span> <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;string_decoder&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb32-5" title="5"><span class="kw">function</span> <span class="at">parseHeader</span>(stream<span class="op">,</span> callback) <span class="op">{</span></a>
<a class="sourceLine" id="cb32-6" title="6">  <span class="va">stream</span>.<span class="at">on</span>(<span class="st">&#39;error&#39;</span><span class="op">,</span> callback)<span class="op">;</span></a>
<a class="sourceLine" id="cb32-7" title="7">  <span class="va">stream</span>.<span class="at">on</span>(<span class="st">&#39;readable&#39;</span><span class="op">,</span> onReadable)<span class="op">;</span></a>
<a class="sourceLine" id="cb32-8" title="8">  <span class="kw">const</span> decoder <span class="op">=</span> <span class="kw">new</span> <span class="at">StringDecoder</span>(<span class="st">&#39;utf8&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb32-9" title="9">  <span class="kw">let</span> header <span class="op">=</span> <span class="st">&#39;&#39;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb32-10" title="10">  <span class="kw">function</span> <span class="at">onReadable</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb32-11" title="11">    <span class="kw">let</span> chunk<span class="op">;</span></a>
<a class="sourceLine" id="cb32-12" title="12">    <span class="cf">while</span> (<span class="kw">null</span> <span class="op">!==</span> (chunk <span class="op">=</span> <span class="va">stream</span>.<span class="at">read</span>())) <span class="op">{</span></a>
<a class="sourceLine" id="cb32-13" title="13">      <span class="kw">const</span> str <span class="op">=</span> <span class="va">decoder</span>.<span class="at">write</span>(chunk)<span class="op">;</span></a>
<a class="sourceLine" id="cb32-14" title="14">      <span class="cf">if</span> (<span class="va">str</span>.<span class="at">match</span>(<span class="ss">/</span><span class="sc">\n\n</span><span class="ss">/</span>)) <span class="op">{</span></a>
<a class="sourceLine" id="cb32-15" title="15">        <span class="co">// Found the header boundary.</span></a>
<a class="sourceLine" id="cb32-16" title="16">        <span class="kw">const</span> split <span class="op">=</span> <span class="va">str</span>.<span class="at">split</span>(<span class="ss">/</span><span class="sc">\n\n</span><span class="ss">/</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb32-17" title="17">        header <span class="op">+=</span> <span class="va">split</span>.<span class="at">shift</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb32-18" title="18">        <span class="kw">const</span> remaining <span class="op">=</span> <span class="va">split</span>.<span class="at">join</span>(<span class="st">&#39;</span><span class="sc">\n\n</span><span class="st">&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb32-19" title="19">        <span class="kw">const</span> buf <span class="op">=</span> <span class="va">Buffer</span>.<span class="at">from</span>(remaining<span class="op">,</span> <span class="st">&#39;utf8&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb32-20" title="20">        <span class="va">stream</span>.<span class="at">removeListener</span>(<span class="st">&#39;error&#39;</span><span class="op">,</span> callback)<span class="op">;</span></a>
<a class="sourceLine" id="cb32-21" title="21">        <span class="co">// Remove the &#39;readable&#39; listener before unshifting.</span></a>
<a class="sourceLine" id="cb32-22" title="22">        <span class="va">stream</span>.<span class="at">removeListener</span>(<span class="st">&#39;readable&#39;</span><span class="op">,</span> onReadable)<span class="op">;</span></a>
<a class="sourceLine" id="cb32-23" title="23">        <span class="cf">if</span> (<span class="va">buf</span>.<span class="at">length</span>)</a>
<a class="sourceLine" id="cb32-24" title="24">          <span class="va">stream</span>.<span class="at">unshift</span>(buf)<span class="op">;</span></a>
<a class="sourceLine" id="cb32-25" title="25">        <span class="co">// Now the body of the message can be read from the stream.</span></a>
<a class="sourceLine" id="cb32-26" title="26">        <span class="at">callback</span>(<span class="kw">null</span><span class="op">,</span> header<span class="op">,</span> stream)<span class="op">;</span></a>
<a class="sourceLine" id="cb32-27" title="27">      <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb32-28" title="28">        <span class="co">// Still reading the header.</span></a>
<a class="sourceLine" id="cb32-29" title="29">        header <span class="op">+=</span> str<span class="op">;</span></a>
<a class="sourceLine" id="cb32-30" title="30">      <span class="op">}</span></a>
<a class="sourceLine" id="cb32-31" title="31">    <span class="op">}</span></a>
<a class="sourceLine" id="cb32-32" title="32">  <span class="op">}</span></a>
<a class="sourceLine" id="cb32-33" title="33"><span class="op">}</span></a></code></pre></div>
<p>Unlike <a href="#stream_readable_push_chunk_encoding"><code>stream.push(chunk)</code></a>, <code>stream.unshift(chunk)</code> will not end the reading process by resetting the internal reading state of the stream. This can cause unexpected results if <code>readable.unshift()</code> is called during a read (i.e. from within a <a href="#stream_readable_read_size_1"><code>stream._read()</code></a> implementation on a custom stream). Following the call to <code>readable.unshift()</code> with an immediate <a href="#stream_readable_push_chunk_encoding"><code>stream.push('')</code></a> will reset the reading state appropriately, however it is best to simply avoid calling <code>readable.unshift()</code> while in the process of performing a read.</p>
<h5 id="readable.wrapstream"><code>readable.wrap(stream)</code></h5>
<!-- YAML
added: v0.9.4
-->
<ul>
<li><code>stream</code> {Stream} An “old style” readable stream</li>
<li>Returns: {this}</li>
</ul>
<p>Prior to Node.js 0.10, streams did not implement the entire <code>stream</code> module API as it is currently defined. (See <a href="#stream_compatibility_with_older_node_js_versions">Compatibility</a> for more information.)</p>
<p>When using an older Node.js library that emits <a href="#stream_event_data"><code>'data'</code></a> events and has a <a href="#stream_readable_pause"><code>stream.pause()</code></a> method that is advisory only, the <code>readable.wrap()</code> method can be used to create a <a href="#stream_class_stream_readable"><code>Readable</code></a> stream that uses the old stream as its data source.</p>
<p>It will rarely be necessary to use <code>readable.wrap()</code> but the method has been provided as a convenience for interacting with older Node.js applications and libraries.</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb33-1" title="1"><span class="kw">const</span> <span class="op">{</span> OldReader <span class="op">}</span> <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;./old-api-module.js&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb33-2" title="2"><span class="kw">const</span> <span class="op">{</span> Readable <span class="op">}</span> <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;stream&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb33-3" title="3"><span class="kw">const</span> oreader <span class="op">=</span> <span class="kw">new</span> <span class="at">OldReader</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb33-4" title="4"><span class="kw">const</span> myReader <span class="op">=</span> <span class="kw">new</span> <span class="at">Readable</span>().<span class="at">wrap</span>(oreader)<span class="op">;</span></a>
<a class="sourceLine" id="cb33-5" title="5"></a>
<a class="sourceLine" id="cb33-6" title="6"><span class="va">myReader</span>.<span class="at">on</span>(<span class="st">&#39;readable&#39;</span><span class="op">,</span> () <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb33-7" title="7">  <span class="va">myReader</span>.<span class="at">read</span>()<span class="op">;</span> <span class="co">// etc.</span></a>
<a class="sourceLine" id="cb33-8" title="8"><span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<h5 id="readablesymbol.asynciterator"><code>readable[Symbol.asyncIterator]()</code></h5>
<!-- YAML
added: v10.0.0
changes:
  - version: v11.14.0
    pr-url: https://github.com/nodejs/node/pull/26989
    description: Symbol.asyncIterator support is no longer experimental.
-->
<ul>
<li>Returns: {AsyncIterator} to fully consume the stream.</li>
</ul>
<div class="sourceCode" id="cb34"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb34-1" title="1"><span class="kw">const</span> fs <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;fs&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb34-2" title="2"></a>
<a class="sourceLine" id="cb34-3" title="3"><span class="kw">async</span> <span class="kw">function</span> <span class="at">print</span>(readable) <span class="op">{</span></a>
<a class="sourceLine" id="cb34-4" title="4">  <span class="va">readable</span>.<span class="at">setEncoding</span>(<span class="st">&#39;utf8&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb34-5" title="5">  <span class="kw">let</span> data <span class="op">=</span> <span class="st">&#39;&#39;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb34-6" title="6">  <span class="cf">for</span> <span class="cf">await</span> (<span class="kw">const</span> chunk <span class="kw">of</span> readable) <span class="op">{</span></a>
<a class="sourceLine" id="cb34-7" title="7">    data <span class="op">+=</span> chunk<span class="op">;</span></a>
<a class="sourceLine" id="cb34-8" title="8">  <span class="op">}</span></a>
<a class="sourceLine" id="cb34-9" title="9">  <span class="va">console</span>.<span class="at">log</span>(data)<span class="op">;</span></a>
<a class="sourceLine" id="cb34-10" title="10"><span class="op">}</span></a>
<a class="sourceLine" id="cb34-11" title="11"></a>
<a class="sourceLine" id="cb34-12" title="12"><span class="at">print</span>(<span class="va">fs</span>.<span class="at">createReadStream</span>(<span class="st">&#39;file&#39;</span>)).<span class="at">catch</span>(<span class="va">console</span>.<span class="at">error</span>)<span class="op">;</span></a></code></pre></div>
<p>If the loop terminates with a <code>break</code>, <code>return</code>, or a <code>throw</code>, the stream will be destroyed. In other terms, iterating over a stream will consume the stream fully. The stream will be read in chunks of size equal to the <code>highWaterMark</code> option. In the code example above, data will be in a single chunk if the file has less then 64 KB of data because no <code>highWaterMark</code> option is provided to <a href="fs.md#fs_fs_createreadstream_path_options"><code>fs.createReadStream()</code></a>.</p>
<h5 id="readable.iteratoroptions"><code>readable.iterator([options])</code></h5>
<!-- YAML
added: v16.3.0
-->
<blockquote>
<p>Stability: 1 - Experimental</p>
</blockquote>
<ul>
<li><code>options</code> {Object}
<ul>
<li><code>destroyOnReturn</code> {boolean} When set to <code>false</code>, calling <code>return</code> on the async iterator, or exiting a <code>for await...of</code> iteration using a <code>break</code>, <code>return</code>, or <code>throw</code> will not destroy the stream. <strong>Default:</strong> <code>true</code>.</li>
</ul></li>
<li>Returns: {AsyncIterator} to consume the stream.</li>
</ul>
<p>The iterator created by this method gives users the option to cancel the destruction of the stream if the <code>for await...of</code> loop is exited by <code>return</code>, <code>break</code>, or <code>throw</code>, or if the iterator should destroy the stream if the stream emitted an error during iteration.</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb35-1" title="1"><span class="kw">const</span> <span class="op">{</span> Readable <span class="op">}</span> <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;stream&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb35-2" title="2"></a>
<a class="sourceLine" id="cb35-3" title="3"><span class="kw">async</span> <span class="kw">function</span> <span class="at">printIterator</span>(readable) <span class="op">{</span></a>
<a class="sourceLine" id="cb35-4" title="4">  <span class="cf">for</span> <span class="cf">await</span> (<span class="kw">const</span> chunk <span class="kw">of</span> <span class="va">readable</span>.<span class="at">iterator</span>(<span class="op">{</span> <span class="dt">destroyOnReturn</span><span class="op">:</span> <span class="kw">false</span> <span class="op">}</span>)) <span class="op">{</span></a>
<a class="sourceLine" id="cb35-5" title="5">    <span class="va">console</span>.<span class="at">log</span>(chunk)<span class="op">;</span> <span class="co">// 1</span></a>
<a class="sourceLine" id="cb35-6" title="6">    <span class="cf">break</span><span class="op">;</span></a>
<a class="sourceLine" id="cb35-7" title="7">  <span class="op">}</span></a>
<a class="sourceLine" id="cb35-8" title="8"></a>
<a class="sourceLine" id="cb35-9" title="9">  <span class="va">console</span>.<span class="at">log</span>(<span class="va">readable</span>.<span class="at">destroyed</span>)<span class="op">;</span> <span class="co">// false</span></a>
<a class="sourceLine" id="cb35-10" title="10"></a>
<a class="sourceLine" id="cb35-11" title="11">  <span class="cf">for</span> <span class="cf">await</span> (<span class="kw">const</span> chunk <span class="kw">of</span> <span class="va">readable</span>.<span class="at">iterator</span>(<span class="op">{</span> <span class="dt">destroyOnReturn</span><span class="op">:</span> <span class="kw">false</span> <span class="op">}</span>)) <span class="op">{</span></a>
<a class="sourceLine" id="cb35-12" title="12">    <span class="va">console</span>.<span class="at">log</span>(chunk)<span class="op">;</span> <span class="co">// Will print 2 and then 3</span></a>
<a class="sourceLine" id="cb35-13" title="13">  <span class="op">}</span></a>
<a class="sourceLine" id="cb35-14" title="14"></a>
<a class="sourceLine" id="cb35-15" title="15">  <span class="va">console</span>.<span class="at">log</span>(<span class="va">readable</span>.<span class="at">destroyed</span>)<span class="op">;</span> <span class="co">// True, stream was totally consumed</span></a>
<a class="sourceLine" id="cb35-16" title="16"><span class="op">}</span></a>
<a class="sourceLine" id="cb35-17" title="17"></a>
<a class="sourceLine" id="cb35-18" title="18"><span class="kw">async</span> <span class="kw">function</span> <span class="at">printSymbolAsyncIterator</span>(readable) <span class="op">{</span></a>
<a class="sourceLine" id="cb35-19" title="19">  <span class="cf">for</span> <span class="cf">await</span> (<span class="kw">const</span> chunk <span class="kw">of</span> readable) <span class="op">{</span></a>
<a class="sourceLine" id="cb35-20" title="20">    <span class="va">console</span>.<span class="at">log</span>(chunk)<span class="op">;</span> <span class="co">// 1</span></a>
<a class="sourceLine" id="cb35-21" title="21">    <span class="cf">break</span><span class="op">;</span></a>
<a class="sourceLine" id="cb35-22" title="22">  <span class="op">}</span></a>
<a class="sourceLine" id="cb35-23" title="23"></a>
<a class="sourceLine" id="cb35-24" title="24">  <span class="va">console</span>.<span class="at">log</span>(<span class="va">readable</span>.<span class="at">destroyed</span>)<span class="op">;</span> <span class="co">// true</span></a>
<a class="sourceLine" id="cb35-25" title="25"><span class="op">}</span></a>
<a class="sourceLine" id="cb35-26" title="26"></a>
<a class="sourceLine" id="cb35-27" title="27"><span class="kw">async</span> <span class="kw">function</span> <span class="at">showBoth</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb35-28" title="28">  <span class="cf">await</span> <span class="at">printIterator</span>(<span class="va">Readable</span>.<span class="at">from</span>([<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>]))<span class="op">;</span></a>
<a class="sourceLine" id="cb35-29" title="29">  <span class="cf">await</span> <span class="at">printSymbolAsyncIterator</span>(<span class="va">Readable</span>.<span class="at">from</span>([<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>]))<span class="op">;</span></a>
<a class="sourceLine" id="cb35-30" title="30"><span class="op">}</span></a>
<a class="sourceLine" id="cb35-31" title="31"></a>
<a class="sourceLine" id="cb35-32" title="32"><span class="at">showBoth</span>()<span class="op">;</span></a></code></pre></div>
<h3 id="duplex-and-transform-streams">Duplex and transform streams</h3>
<h4 id="class-stream.duplex">Class: <code>stream.Duplex</code></h4>
<!-- YAML
added: v0.9.4
changes:
  - version: v6.8.0
    pr-url: https://github.com/nodejs/node/pull/8834
    description: Instances of `Duplex` now return `true` when
                 checking `instanceof stream.Writable`.
-->
<!--type=class-->
<p>Duplex streams are streams that implement both the <a href="#stream_class_stream_readable"><code>Readable</code></a> and <a href="#stream_class_stream_writable"><code>Writable</code></a> interfaces.</p>
<p>Examples of <code>Duplex</code> streams include:</p>
<ul>
<li><a href="net.md#net_class_net_socket">TCP sockets</a></li>
<li><a href="zlib.md">zlib streams</a></li>
<li><a href="crypto.md">crypto streams</a></li>
</ul>
<h4 id="class-stream.transform">Class: <code>stream.Transform</code></h4>
<!-- YAML
added: v0.9.4
-->
<!--type=class-->
<p>Transform streams are <a href="#stream_class_stream_duplex"><code>Duplex</code></a> streams where the output is in some way related to the input. Like all <a href="#stream_class_stream_duplex"><code>Duplex</code></a> streams, <code>Transform</code> streams implement both the <a href="#stream_class_stream_readable"><code>Readable</code></a> and <a href="#stream_class_stream_writable"><code>Writable</code></a> interfaces.</p>
<p>Examples of <code>Transform</code> streams include:</p>
<ul>
<li><a href="zlib.md">zlib streams</a></li>
<li><a href="crypto.md">crypto streams</a></li>
</ul>
<h5 id="transform.destroyerror"><code>transform.destroy([error])</code></h5>
<!-- YAML
added: v8.0.0
changes:
  - version: v14.0.0
    pr-url: https://github.com/nodejs/node/pull/29197
    description: Work as a no-op on a stream that has already been destroyed.
-->
<ul>
<li><code>error</code> {Error}</li>
<li>Returns: {this}</li>
</ul>
<p>Destroy the stream, and optionally emit an <code>'error'</code> event. After this call, the transform stream would release any internal resources. Implementors should not override this method, but instead implement <a href="#stream_readable_destroy_err_callback"><code>readable._destroy()</code></a>. The default implementation of <code>_destroy()</code> for <code>Transform</code> also emit <code>'close'</code> unless <code>emitClose</code> is set in false.</p>
<p>Once <code>destroy()</code> has been called, any further calls will be a no-op and no further errors except from <code>_destroy()</code> may be emitted as <code>'error'</code>.</p>
<h3 id="stream.finishedstream-options-callback"><code>stream.finished(stream[, options], callback)</code></h3>
<!-- YAML
added: v10.0.0
changes:
  - version: v15.11.0
    pr-url: https://github.com/nodejs/node/pull/37354
    description: The `signal` option was added.
  - version: v14.0.0
    pr-url: https://github.com/nodejs/node/pull/32158
    description: The `finished(stream, cb)` will wait for the `'close'` event
                 before invoking the callback. The implementation tries to
                 detect legacy streams and only apply this behavior to streams
                 which are expected to emit `'close'`.
  - version: v14.0.0
    pr-url: https://github.com/nodejs/node/pull/31545
    description: Emitting `'close'` before `'end'` on a `Readable` stream
                 will cause an `ERR_STREAM_PREMATURE_CLOSE` error.
  - version: v14.0.0
    pr-url: https://github.com/nodejs/node/pull/31509
    description: Callback will be invoked on streams which have already
                 finished before the call to `finished(stream, cb)`.
-->
<ul>
<li><code>stream</code> {Stream} A readable and/or writable stream.</li>
<li><code>options</code> {Object}
<ul>
<li><code>error</code> {boolean} If set to <code>false</code>, then a call to <code>emit('error', err)</code> is not treated as finished. <strong>Default:</strong> <code>true</code>.</li>
<li><code>readable</code> {boolean} When set to <code>false</code>, the callback will be called when the stream ends even though the stream might still be readable. <strong>Default:</strong> <code>true</code>.</li>
<li><code>writable</code> {boolean} When set to <code>false</code>, the callback will be called when the stream ends even though the stream might still be writable. <strong>Default:</strong> <code>true</code>.</li>
<li><code>signal</code> {AbortSignal} allows aborting the wait for the stream finish. The underlying stream will <em>not</em> be aborted if the signal is aborted. The callback will get called with an <code>AbortError</code>. All registered listeners added by this function will also be removed.</li>
</ul></li>
<li><code>callback</code> {Function} A callback function that takes an optional error argument.</li>
<li>Returns: {Function} A cleanup function which removes all registered listeners.</li>
</ul>
<p>A function to get notified when a stream is no longer readable, writable or has experienced an error or a premature close event.</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb36-1" title="1"><span class="kw">const</span> <span class="op">{</span> finished <span class="op">}</span> <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;stream&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb36-2" title="2"></a>
<a class="sourceLine" id="cb36-3" title="3"><span class="kw">const</span> rs <span class="op">=</span> <span class="va">fs</span>.<span class="at">createReadStream</span>(<span class="st">&#39;archive.tar&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb36-4" title="4"></a>
<a class="sourceLine" id="cb36-5" title="5"><span class="at">finished</span>(rs<span class="op">,</span> (err) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb36-6" title="6">  <span class="cf">if</span> (err) <span class="op">{</span></a>
<a class="sourceLine" id="cb36-7" title="7">    <span class="va">console</span>.<span class="at">error</span>(<span class="st">&#39;Stream failed.&#39;</span><span class="op">,</span> err)<span class="op">;</span></a>
<a class="sourceLine" id="cb36-8" title="8">  <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb36-9" title="9">    <span class="va">console</span>.<span class="at">log</span>(<span class="st">&#39;Stream is done reading.&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb36-10" title="10">  <span class="op">}</span></a>
<a class="sourceLine" id="cb36-11" title="11"><span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb36-12" title="12"></a>
<a class="sourceLine" id="cb36-13" title="13"><span class="va">rs</span>.<span class="at">resume</span>()<span class="op">;</span> <span class="co">// Drain the stream.</span></a></code></pre></div>
<p>Especially useful in error handling scenarios where a stream is destroyed prematurely (like an aborted HTTP request), and will not emit <code>'end'</code> or <code>'finish'</code>.</p>
<p>The <code>finished</code> API provides promise version:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb37-1" title="1"><span class="kw">const</span> <span class="op">{</span> finished <span class="op">}</span> <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;stream/promises&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb37-2" title="2"></a>
<a class="sourceLine" id="cb37-3" title="3"><span class="kw">const</span> rs <span class="op">=</span> <span class="va">fs</span>.<span class="at">createReadStream</span>(<span class="st">&#39;archive.tar&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb37-4" title="4"></a>
<a class="sourceLine" id="cb37-5" title="5"><span class="kw">async</span> <span class="kw">function</span> <span class="at">run</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb37-6" title="6">  <span class="cf">await</span> <span class="at">finished</span>(rs)<span class="op">;</span></a>
<a class="sourceLine" id="cb37-7" title="7">  <span class="va">console</span>.<span class="at">log</span>(<span class="st">&#39;Stream is done reading.&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb37-8" title="8"><span class="op">}</span></a>
<a class="sourceLine" id="cb37-9" title="9"></a>
<a class="sourceLine" id="cb37-10" title="10"><span class="at">run</span>().<span class="at">catch</span>(<span class="va">console</span>.<span class="at">error</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb37-11" title="11"><span class="va">rs</span>.<span class="at">resume</span>()<span class="op">;</span> <span class="co">// Drain the stream.</span></a></code></pre></div>
<p><code>stream.finished()</code> leaves dangling event listeners (in particular <code>'error'</code>, <code>'end'</code>, <code>'finish'</code> and <code>'close'</code>) after <code>callback</code> has been invoked. The reason for this is so that unexpected <code>'error'</code> events (due to incorrect stream implementations) do not cause unexpected crashes. If this is unwanted behavior then the returned cleanup function needs to be invoked in the callback:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb38-1" title="1"><span class="kw">const</span> cleanup <span class="op">=</span> <span class="at">finished</span>(rs<span class="op">,</span> (err) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb38-2" title="2">  <span class="at">cleanup</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb38-3" title="3">  <span class="co">// ...</span></a>
<a class="sourceLine" id="cb38-4" title="4"><span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<h3 id="stream.pipelinesource-...transforms-destination-callback"><code>stream.pipeline(source[, ...transforms], destination, callback)</code></h3>
<h3 id="stream.pipelinestreams-callback"><code>stream.pipeline(streams, callback)</code></h3>
<!-- YAML
added: v10.0.0
changes:
  - version: v14.0.0
    pr-url: https://github.com/nodejs/node/pull/32158
    description: The `pipeline(..., cb)` will wait for the `'close'` event
                 before invoking the callback. The implementation tries to
                 detect legacy streams and only apply this behavior to streams
                 which are expected to emit `'close'`.
  - version: v13.10.0
    pr-url: https://github.com/nodejs/node/pull/31223
    description: Add support for async generators.
-->
<ul>
<li><code>streams</code> {Stream[]|Iterable[]|AsyncIterable[]|Function[]}</li>
<li><code>source</code> {Stream|Iterable|AsyncIterable|Function}
<ul>
<li>Returns: {Iterable|AsyncIterable}</li>
</ul></li>
<li><code>...transforms</code> {Stream|Function}
<ul>
<li><code>source</code> {AsyncIterable}</li>
<li>Returns: {AsyncIterable}</li>
</ul></li>
<li><code>destination</code> {Stream|Function}
<ul>
<li><code>source</code> {AsyncIterable}</li>
<li>Returns: {AsyncIterable|Promise}</li>
</ul></li>
<li><code>callback</code> {Function} Called when the pipeline is fully done.
<ul>
<li><code>err</code> {Error}</li>
<li><code>val</code> Resolved value of <code>Promise</code> returned by <code>destination</code>.</li>
</ul></li>
<li>Returns: {Stream}</li>
</ul>
<p>A module method to pipe between streams and generators forwarding errors and properly cleaning up and provide a callback when the pipeline is complete.</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb39-1" title="1"><span class="kw">const</span> <span class="op">{</span> pipeline <span class="op">}</span> <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;stream&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb39-2" title="2"><span class="kw">const</span> fs <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;fs&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb39-3" title="3"><span class="kw">const</span> zlib <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;zlib&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb39-4" title="4"></a>
<a class="sourceLine" id="cb39-5" title="5"><span class="co">// Use the pipeline API to easily pipe a series of streams</span></a>
<a class="sourceLine" id="cb39-6" title="6"><span class="co">// together and get notified when the pipeline is fully done.</span></a>
<a class="sourceLine" id="cb39-7" title="7"></a>
<a class="sourceLine" id="cb39-8" title="8"><span class="co">// A pipeline to gzip a potentially huge tar file efficiently:</span></a>
<a class="sourceLine" id="cb39-9" title="9"></a>
<a class="sourceLine" id="cb39-10" title="10"><span class="at">pipeline</span>(</a>
<a class="sourceLine" id="cb39-11" title="11">  <span class="va">fs</span>.<span class="at">createReadStream</span>(<span class="st">&#39;archive.tar&#39;</span>)<span class="op">,</span></a>
<a class="sourceLine" id="cb39-12" title="12">  <span class="va">zlib</span>.<span class="at">createGzip</span>()<span class="op">,</span></a>
<a class="sourceLine" id="cb39-13" title="13">  <span class="va">fs</span>.<span class="at">createWriteStream</span>(<span class="st">&#39;archive.tar.gz&#39;</span>)<span class="op">,</span></a>
<a class="sourceLine" id="cb39-14" title="14">  (err) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb39-15" title="15">    <span class="cf">if</span> (err) <span class="op">{</span></a>
<a class="sourceLine" id="cb39-16" title="16">      <span class="va">console</span>.<span class="at">error</span>(<span class="st">&#39;Pipeline failed.&#39;</span><span class="op">,</span> err)<span class="op">;</span></a>
<a class="sourceLine" id="cb39-17" title="17">    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb39-18" title="18">      <span class="va">console</span>.<span class="at">log</span>(<span class="st">&#39;Pipeline succeeded.&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb39-19" title="19">    <span class="op">}</span></a>
<a class="sourceLine" id="cb39-20" title="20">  <span class="op">}</span></a>
<a class="sourceLine" id="cb39-21" title="21">)<span class="op">;</span></a></code></pre></div>
<p>The <code>pipeline</code> API provides a promise version, which can also receive an options argument as the last parameter with a <code>signal</code> {AbortSignal} property. When the signal is aborted, <code>destroy</code> will be called on the underlying pipeline, with an <code>AbortError</code>.</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb40-1" title="1"><span class="kw">const</span> <span class="op">{</span> pipeline <span class="op">}</span> <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;stream/promises&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb40-2" title="2"></a>
<a class="sourceLine" id="cb40-3" title="3"><span class="kw">async</span> <span class="kw">function</span> <span class="at">run</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb40-4" title="4">  <span class="cf">await</span> <span class="at">pipeline</span>(</a>
<a class="sourceLine" id="cb40-5" title="5">    <span class="va">fs</span>.<span class="at">createReadStream</span>(<span class="st">&#39;archive.tar&#39;</span>)<span class="op">,</span></a>
<a class="sourceLine" id="cb40-6" title="6">    <span class="va">zlib</span>.<span class="at">createGzip</span>()<span class="op">,</span></a>
<a class="sourceLine" id="cb40-7" title="7">    <span class="va">fs</span>.<span class="at">createWriteStream</span>(<span class="st">&#39;archive.tar.gz&#39;</span>)</a>
<a class="sourceLine" id="cb40-8" title="8">  )<span class="op">;</span></a>
<a class="sourceLine" id="cb40-9" title="9">  <span class="va">console</span>.<span class="at">log</span>(<span class="st">&#39;Pipeline succeeded.&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb40-10" title="10"><span class="op">}</span></a>
<a class="sourceLine" id="cb40-11" title="11"></a>
<a class="sourceLine" id="cb40-12" title="12"><span class="at">run</span>().<span class="at">catch</span>(<span class="va">console</span>.<span class="at">error</span>)<span class="op">;</span></a></code></pre></div>
<p>To use an <code>AbortSignal</code>, pass it inside an options object, as the last argument:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb41-1" title="1"><span class="kw">const</span> <span class="op">{</span> pipeline <span class="op">}</span> <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;stream/promises&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb41-2" title="2"></a>
<a class="sourceLine" id="cb41-3" title="3"><span class="kw">async</span> <span class="kw">function</span> <span class="at">run</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb41-4" title="4">  <span class="kw">const</span> ac <span class="op">=</span> <span class="kw">new</span> <span class="at">AbortController</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb41-5" title="5">  <span class="kw">const</span> options <span class="op">=</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb41-6" title="6">    <span class="dt">signal</span><span class="op">:</span> <span class="va">ac</span>.<span class="at">signal</span><span class="op">,</span></a>
<a class="sourceLine" id="cb41-7" title="7">  <span class="op">};</span></a>
<a class="sourceLine" id="cb41-8" title="8"></a>
<a class="sourceLine" id="cb41-9" title="9">  <span class="at">setTimeout</span>(() <span class="kw">=&gt;</span> <span class="va">ac</span>.<span class="at">abort</span>()<span class="op">,</span> <span class="dv">1</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb41-10" title="10">  <span class="cf">await</span> <span class="at">pipeline</span>(</a>
<a class="sourceLine" id="cb41-11" title="11">    <span class="va">fs</span>.<span class="at">createReadStream</span>(<span class="st">&#39;archive.tar&#39;</span>)<span class="op">,</span></a>
<a class="sourceLine" id="cb41-12" title="12">    <span class="va">zlib</span>.<span class="at">createGzip</span>()<span class="op">,</span></a>
<a class="sourceLine" id="cb41-13" title="13">    <span class="va">fs</span>.<span class="at">createWriteStream</span>(<span class="st">&#39;archive.tar.gz&#39;</span>)<span class="op">,</span></a>
<a class="sourceLine" id="cb41-14" title="14">    options<span class="op">,</span></a>
<a class="sourceLine" id="cb41-15" title="15">  )<span class="op">;</span></a>
<a class="sourceLine" id="cb41-16" title="16"><span class="op">}</span></a>
<a class="sourceLine" id="cb41-17" title="17"></a>
<a class="sourceLine" id="cb41-18" title="18"><span class="at">run</span>().<span class="at">catch</span>(<span class="va">console</span>.<span class="at">error</span>)<span class="op">;</span> <span class="co">// AbortError</span></a></code></pre></div>
<p>The <code>pipeline</code> API also supports async generators:</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb42-1" title="1"><span class="kw">const</span> <span class="op">{</span> pipeline <span class="op">}</span> <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;stream/promises&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb42-2" title="2"><span class="kw">const</span> fs <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;fs&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb42-3" title="3"></a>
<a class="sourceLine" id="cb42-4" title="4"><span class="kw">async</span> <span class="kw">function</span> <span class="at">run</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb42-5" title="5">  <span class="cf">await</span> <span class="at">pipeline</span>(</a>
<a class="sourceLine" id="cb42-6" title="6">    <span class="va">fs</span>.<span class="at">createReadStream</span>(<span class="st">&#39;lowercase.txt&#39;</span>)<span class="op">,</span></a>
<a class="sourceLine" id="cb42-7" title="7">    <span class="kw">async</span> <span class="kw">function</span><span class="op">*</span> (source) <span class="op">{</span></a>
<a class="sourceLine" id="cb42-8" title="8">      <span class="va">source</span>.<span class="at">setEncoding</span>(<span class="st">&#39;utf8&#39;</span>)<span class="op">;</span>  <span class="co">// Work with strings rather than `Buffer`s.</span></a>
<a class="sourceLine" id="cb42-9" title="9">      <span class="cf">for</span> <span class="cf">await</span> (<span class="kw">const</span> chunk <span class="kw">of</span> source) <span class="op">{</span></a>
<a class="sourceLine" id="cb42-10" title="10">        <span class="kw">yield</span> <span class="va">chunk</span>.<span class="at">toUpperCase</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb42-11" title="11">      <span class="op">}</span></a>
<a class="sourceLine" id="cb42-12" title="12">    <span class="op">},</span></a>
<a class="sourceLine" id="cb42-13" title="13">    <span class="va">fs</span>.<span class="at">createWriteStream</span>(<span class="st">&#39;uppercase.txt&#39;</span>)</a>
<a class="sourceLine" id="cb42-14" title="14">  )<span class="op">;</span></a>
<a class="sourceLine" id="cb42-15" title="15">  <span class="va">console</span>.<span class="at">log</span>(<span class="st">&#39;Pipeline succeeded.&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb42-16" title="16"><span class="op">}</span></a>
<a class="sourceLine" id="cb42-17" title="17"></a>
<a class="sourceLine" id="cb42-18" title="18"><span class="at">run</span>().<span class="at">catch</span>(<span class="va">console</span>.<span class="at">error</span>)<span class="op">;</span></a></code></pre></div>
<p><code>stream.pipeline()</code> will call <code>stream.destroy(err)</code> on all streams except: * <code>Readable</code> streams which have emitted <code>'end'</code> or <code>'close'</code>. * <code>Writable</code> streams which have emitted <code>'finish'</code> or <code>'close'</code>.</p>
<p><code>stream.pipeline()</code> leaves dangling event listeners on the streams after the <code>callback</code> has been invoked. In the case of reuse of streams after failure, this can cause event listener leaks and swallowed errors.</p>
<h3 id="stream.compose...streams"><code>stream.compose(...streams)</code></h3>
<!-- YAML
added: REPLACEME
-->
<blockquote>
<p>Stability: 1 - <code>stream.compose</code> is experimental.</p>
</blockquote>
<ul>
<li><code>streams</code> {Stream[]|Iterable[]|AsyncIterable[]|Function[]}</li>
<li>Returns: {stream.Duplex}</li>
</ul>
<p>Combines two or more streams into a <code>Duplex</code> stream that writes to the first stream and reads from the last. Each provided stream is piped into the next, using <code>stream.pipeline</code>. If any of the streams error then all are destroyed, including the outer <code>Duplex</code> stream.</p>
<p>Because <code>stream.compose</code> returns a new stream that in turn can (and should) be piped into other streams, it enables composition. In contrast, when passing streams to <code>stream.pipeline</code>, typically the first stream is a readable stream and the last a writable stream, forming a closed circuit.</p>
<p>If passed a <code>Function</code> it must be a factory method taking a <code>source</code> <code>Iterable</code>.</p>
<pre class="mjs"><code>import { compose, Transform } from &#39;stream&#39;;

const removeSpaces = new Transform({
  transform(chunk, encoding, callback) {
    callback(null, String(chunk).replace(&#39; &#39;, &#39;&#39;));
  }
});

async function* toUpper(source) {
  for await (const chunk of source) {
    yield String(chunk).toUpperCase();
  }
}

let res = &#39;&#39;;
for await (const buf of compose(removeSpaces, toUpper).end(&#39;hello world&#39;)) {
  res += buf;
}

console.log(res); // prints &#39;HELLOWORLD&#39;</code></pre>
<p><code>stream.compose</code> can be used to convert async iterables, generators and functions into streams.</p>
<ul>
<li><code>AsyncIterable</code> converts into a readable <code>Duplex</code>. Cannot yield <code>null</code>.</li>
<li><code>AsyncGeneratorFunction</code> converts into a readable/writable transform <code>Duplex</code>. Must take a source <code>AsyncIterable</code> as first parameter. Cannot yield <code>null</code>.</li>
<li><code>AsyncFunction</code> converts into a writable <code>Duplex</code>. Must return either <code>null</code> or <code>undefined</code>.</li>
</ul>
<pre class="mjs"><code>import { compose } from &#39;stream&#39;;
import { finished } from &#39;stream/promises&#39;;

// Convert AsyncIterable into readable Duplex.
const s1 = compose(async function*() {
  yield &#39;Hello&#39;;
  yield &#39;World&#39;;
}());

// Convert AsyncGenerator into transform Duplex.
const s2 = compose(async function*(source) {
  for await (const chunk of source) {
    yield String(chunk).toUpperCase();
  }
});

let res = &#39;&#39;;

// Convert AsyncFunction into writable Duplex.
const s3 = compose(async function(source) {
  for await (const chunk of source) {
    res += chunk;
  }
});

await finished(compose(s1, s2, s3));

console.log(res); // prints &#39;HELLOWORLD&#39;</code></pre>
<h3 id="stream.readable.fromiterable-options"><code>stream.Readable.from(iterable, [options])</code></h3>
<!-- YAML
added:
  - v12.3.0
  - v10.17.0
-->
<ul>
<li><code>iterable</code> {Iterable} Object implementing the <code>Symbol.asyncIterator</code> or <code>Symbol.iterator</code> iterable protocol. Emits an ‘error’ event if a null value is passed.</li>
<li><code>options</code> {Object} Options provided to <code>new stream.Readable([options])</code>. By default, <code>Readable.from()</code> will set <code>options.objectMode</code> to <code>true</code>, unless this is explicitly opted out by setting <code>options.objectMode</code> to <code>false</code>.</li>
<li>Returns: {stream.Readable}</li>
</ul>
<p>A utility method for creating readable streams out of iterators.</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb45-1" title="1"><span class="kw">const</span> <span class="op">{</span> Readable <span class="op">}</span> <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;stream&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb45-2" title="2"></a>
<a class="sourceLine" id="cb45-3" title="3"><span class="kw">async</span> <span class="kw">function</span> <span class="op">*</span> <span class="at">generate</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb45-4" title="4">  <span class="kw">yield</span> <span class="st">&#39;hello&#39;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb45-5" title="5">  <span class="kw">yield</span> <span class="st">&#39;streams&#39;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb45-6" title="6"><span class="op">}</span></a>
<a class="sourceLine" id="cb45-7" title="7"></a>
<a class="sourceLine" id="cb45-8" title="8"><span class="kw">const</span> readable <span class="op">=</span> <span class="va">Readable</span>.<span class="at">from</span>(<span class="at">generate</span>())<span class="op">;</span></a>
<a class="sourceLine" id="cb45-9" title="9"></a>
<a class="sourceLine" id="cb45-10" title="10"><span class="va">readable</span>.<span class="at">on</span>(<span class="st">&#39;data&#39;</span><span class="op">,</span> (chunk) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb45-11" title="11">  <span class="va">console</span>.<span class="at">log</span>(chunk)<span class="op">;</span></a>
<a class="sourceLine" id="cb45-12" title="12"><span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<p>Calling <code>Readable.from(string)</code> or <code>Readable.from(buffer)</code> will not have the strings or buffers be iterated to match the other streams semantics for performance reasons.</p>
<h3 id="stream.readable.fromwebreadablestream-options"><code>stream.Readable.fromWeb(readableStream[, options])</code></h3>
<!-- YAML
added: REPLACEME
-->
<blockquote>
<p>Stability: 1 - Experimental</p>
</blockquote>
<ul>
<li><code>readableStream</code> {ReadableStream}</li>
<li><code>options</code> {Object}
<ul>
<li><code>encoding</code> {string}</li>
<li><code>highWaterMark</code> {number}</li>
<li><code>objectModel</code> {boolean}</li>
<li><code>signal</code> {AbortSignal}</li>
</ul></li>
<li>Returns: {stream.Readable}</li>
</ul>
<h3 id="stream.readable.towebstreamreadable"><code>stream.Readable.toWeb(streamReadable)</code></h3>
<!-- YAML
added: REPLACEME
-->
<blockquote>
<p>Stability: 1 - Experimental</p>
</blockquote>
<ul>
<li><code>streamReadable</code> {stream.Readable}</li>
<li>Returns: {ReadableStream}</li>
</ul>
<h3 id="stream.writable.fromwebwritablestream-options"><code>stream.Writable.fromWeb(writableStream[, options])</code></h3>
<!-- YAML
added: REPLACEME
-->
<blockquote>
<p>Stability: 1 - Experimental</p>
</blockquote>
<ul>
<li><code>writableStream</code> {WritableStream}</li>
<li><code>options</code> {Object}
<ul>
<li><code>decodeStrings</code> {boolean}</li>
<li><code>highWaterMark</code> {number}</li>
<li><code>objectMode</code> {boolean}</li>
<li><code>signal</code> {AbortSignal}</li>
</ul></li>
<li>Returns: {stream.Writable}</li>
</ul>
<h3 id="stream.writable.towebstreamwritable"><code>stream.Writable.toWeb(streamWritable)</code></h3>
<!-- YAML
added: REPLACEME
-->
<blockquote>
<p>Stability: 1 - Experimental</p>
</blockquote>
<ul>
<li><code>streamWritable</code> {stream.Writable}</li>
<li>Returns: {WritableStream}</li>
</ul>
<h3 id="stream.duplex.fromwebpair-options"><code>stream.Duplex.fromWeb(pair[, options])</code></h3>
<!-- YAML
added: REPLACEME
-->
<blockquote>
<p>Stability: 1 - Experimental</p>
</blockquote>
<ul>
<li><code>pair</code> {Object}
<ul>
<li><code>readable</code> {ReadableStream}</li>
<li><code>writable</code> {WritableStream}</li>
</ul></li>
<li><code>options</code> {Object}
<ul>
<li><code>allowHalfOpen</code> {boolean}</li>
<li><code>decodeStrings</code> {boolean}</li>
<li><code>encoding</code> {string}</li>
<li><code>highWaterMark</code> {number}</li>
<li><code>objectMode</code> {boolean}</li>
<li><code>signal</code> {AbortSignal}</li>
</ul></li>
<li>Returns: {stream.Duplex}</li>
</ul>
<h3 id="stream.duplex.towebstreamduplex"><code>stream.Duplex.toWeb(streamDuplex)</code></h3>
<!-- YAML
added: REPLACEME
-->
<blockquote>
<p>Stability: 1 - Experimental</p>
</blockquote>
<ul>
<li><code>streamDuplex</code> {stream.Duplex}</li>
<li>Returns: {Object}
<ul>
<li><code>readable</code> {ReadableStream}</li>
<li><code>writable</code> {WritableStream}</li>
</ul></li>
</ul>
<h3 id="stream.addabortsignalsignal-stream"><code>stream.addAbortSignal(signal, stream)</code></h3>
<!-- YAML
added: v15.4.0
-->
<ul>
<li><code>signal</code> {AbortSignal} A signal representing possible cancellation</li>
<li><code>stream</code> {Stream} a stream to attach a signal to</li>
</ul>
<p>Attaches an AbortSignal to a readable or writeable stream. This lets code control stream destruction using an <code>AbortController</code>.</p>
<p>Calling <code>abort</code> on the <code>AbortController</code> corresponding to the passed <code>AbortSignal</code> will behave the same way as calling <code>.destroy(new AbortError())</code> on the stream.</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb46-1" title="1"><span class="kw">const</span> fs <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;fs&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb46-2" title="2"></a>
<a class="sourceLine" id="cb46-3" title="3"><span class="kw">const</span> controller <span class="op">=</span> <span class="kw">new</span> <span class="at">AbortController</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb46-4" title="4"><span class="kw">const</span> read <span class="op">=</span> <span class="at">addAbortSignal</span>(</a>
<a class="sourceLine" id="cb46-5" title="5">  <span class="va">controller</span>.<span class="at">signal</span><span class="op">,</span></a>
<a class="sourceLine" id="cb46-6" title="6">  <span class="va">fs</span>.<span class="at">createReadStream</span>((<span class="st">&#39;object.json&#39;</span>))</a>
<a class="sourceLine" id="cb46-7" title="7">)<span class="op">;</span></a>
<a class="sourceLine" id="cb46-8" title="8"><span class="co">// Later, abort the operation closing the stream</span></a>
<a class="sourceLine" id="cb46-9" title="9"><span class="va">controller</span>.<span class="at">abort</span>()<span class="op">;</span></a></code></pre></div>
<p>Or using an <code>AbortSignal</code> with a readable stream as an async iterable:</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb47-1" title="1"><span class="kw">const</span> controller <span class="op">=</span> <span class="kw">new</span> <span class="at">AbortController</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb47-2" title="2"><span class="at">setTimeout</span>(() <span class="kw">=&gt;</span> <span class="va">controller</span>.<span class="at">abort</span>()<span class="op">,</span> <span class="dv">10</span>_000)<span class="op">;</span> <span class="co">// set a timeout</span></a>
<a class="sourceLine" id="cb47-3" title="3"><span class="kw">const</span> stream <span class="op">=</span> <span class="at">addAbortSignal</span>(</a>
<a class="sourceLine" id="cb47-4" title="4">  <span class="va">controller</span>.<span class="at">signal</span><span class="op">,</span></a>
<a class="sourceLine" id="cb47-5" title="5">  <span class="va">fs</span>.<span class="at">createReadStream</span>((<span class="st">&#39;object.json&#39;</span>))</a>
<a class="sourceLine" id="cb47-6" title="6">)<span class="op">;</span></a>
<a class="sourceLine" id="cb47-7" title="7">(<span class="kw">async</span> () <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb47-8" title="8">  <span class="cf">try</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb47-9" title="9">    <span class="cf">for</span> <span class="cf">await</span> (<span class="kw">const</span> chunk <span class="kw">of</span> stream) <span class="op">{</span></a>
<a class="sourceLine" id="cb47-10" title="10">      <span class="cf">await</span> <span class="at">process</span>(chunk)<span class="op">;</span></a>
<a class="sourceLine" id="cb47-11" title="11">    <span class="op">}</span></a>
<a class="sourceLine" id="cb47-12" title="12">  <span class="op">}</span> <span class="cf">catch</span> (e) <span class="op">{</span></a>
<a class="sourceLine" id="cb47-13" title="13">    <span class="cf">if</span> (<span class="va">e</span>.<span class="at">name</span> <span class="op">===</span> <span class="st">&#39;AbortError&#39;</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb47-14" title="14">      <span class="co">// The operation was cancelled</span></a>
<a class="sourceLine" id="cb47-15" title="15">    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb47-16" title="16">      <span class="cf">throw</span> e<span class="op">;</span></a>
<a class="sourceLine" id="cb47-17" title="17">    <span class="op">}</span></a>
<a class="sourceLine" id="cb47-18" title="18">  <span class="op">}</span></a>
<a class="sourceLine" id="cb47-19" title="19"><span class="op">}</span>)()<span class="op">;</span></a></code></pre></div>
<h2 id="api-for-stream-implementers">API for stream implementers</h2>
<!--type=misc-->
<p>The <code>stream</code> module API has been designed to make it possible to easily implement streams using JavaScript’s prototypal inheritance model.</p>
<p>First, a stream developer would declare a new JavaScript class that extends one of the four basic stream classes (<code>stream.Writable</code>, <code>stream.Readable</code>, <code>stream.Duplex</code>, or <code>stream.Transform</code>), making sure they call the appropriate parent class constructor:</p>
<!-- eslint-disable no-useless-constructor -->
<div class="sourceCode" id="cb48"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb48-1" title="1"><span class="kw">const</span> <span class="op">{</span> Writable <span class="op">}</span> <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;stream&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb48-2" title="2"></a>
<a class="sourceLine" id="cb48-3" title="3"><span class="kw">class</span> MyWritable <span class="kw">extends</span> Writable <span class="op">{</span></a>
<a class="sourceLine" id="cb48-4" title="4">  <span class="at">constructor</span>(<span class="op">{</span> highWaterMark<span class="op">,</span> ...<span class="at">options</span> <span class="op">}</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb48-5" title="5">    <span class="kw">super</span>(<span class="op">{</span> highWaterMark <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb48-6" title="6">    <span class="co">// ...</span></a>
<a class="sourceLine" id="cb48-7" title="7">  <span class="op">}</span></a>
<a class="sourceLine" id="cb48-8" title="8"><span class="op">}</span></a></code></pre></div>
<p>When extending streams, keep in mind what options the user can and should provide before forwarding these to the base constructor. For example, if the implementation makes assumptions in regard to the <code>autoDestroy</code> and <code>emitClose</code> options, do not allow the user to override these. Be explicit about what options are forwarded instead of implicitly forwarding all options.</p>
<p>The new stream class must then implement one or more specific methods, depending on the type of stream being created, as detailed in the chart below:</p>
<table>
<colgroup>
<col style="width: 22%" />
<col style="width: 14%" />
<col style="width: 62%" />
</colgroup>
<thead>
<tr class="header">
<th>Use-case</th>
<th>Class</th>
<th>Method(s) to implement</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Reading only</td>
<td><a href="#stream_class_stream_readable"><code>Readable</code></a></td>
<td><a href="#stream_readable_read_size_1"><code>_read()</code></a></td>
</tr>
<tr class="even">
<td>Writing only</td>
<td><a href="#stream_class_stream_writable"><code>Writable</code></a></td>
<td><a href="#stream_writable_write_chunk_encoding_callback_1"><code>_write()</code></a>, <a href="#stream_writable_writev_chunks_callback"><code>_writev()</code></a>, <a href="#stream_writable_final_callback"><code>_final()</code></a></td>
</tr>
<tr class="odd">
<td>Reading and writing</td>
<td><a href="#stream_class_stream_duplex"><code>Duplex</code></a></td>
<td><a href="#stream_readable_read_size_1"><code>_read()</code></a>, <a href="#stream_writable_write_chunk_encoding_callback_1"><code>_write()</code></a>, <a href="#stream_writable_writev_chunks_callback"><code>_writev()</code></a>, <a href="#stream_writable_final_callback"><code>_final()</code></a></td>
</tr>
<tr class="even">
<td>Operate on written data, then read the result</td>
<td><a href="#stream_class_stream_transform"><code>Transform</code></a></td>
<td><a href="#stream_transform_transform_chunk_encoding_callback"><code>_transform()</code></a>, <a href="#stream_transform_flush_callback"><code>_flush()</code></a>, <a href="#stream_writable_final_callback"><code>_final()</code></a></td>
</tr>
</tbody>
</table>
<p>The implementation code for a stream should <em>never</em> call the “public” methods of a stream that are intended for use by consumers (as described in the <a href="#stream_api_for_stream_consumers">API for stream consumers</a> section). Doing so may lead to adverse side effects in application code consuming the stream.</p>
<p>Avoid overriding public methods such as <code>write()</code>, <code>end()</code>, <code>cork()</code>, <code>uncork()</code>, <code>read()</code> and <code>destroy()</code>, or emitting internal events such as <code>'error'</code>, <code>'data'</code>, <code>'end'</code>, <code>'finish'</code> and <code>'close'</code> through <code>.emit()</code>. Doing so can break current and future stream invariants leading to behavior and/or compatibility issues with other streams, stream utilities, and user expectations.</p>
<h3 id="simplified-construction">Simplified construction</h3>
<!-- YAML
added: v1.2.0
-->
<p>For many simple cases, it is possible to create a stream without relying on inheritance. This can be accomplished by directly creating instances of the <code>stream.Writable</code>, <code>stream.Readable</code>, <code>stream.Duplex</code> or <code>stream.Transform</code> objects and passing appropriate methods as constructor options.</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb49-1" title="1"><span class="kw">const</span> <span class="op">{</span> Writable <span class="op">}</span> <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;stream&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb49-2" title="2"></a>
<a class="sourceLine" id="cb49-3" title="3"><span class="kw">const</span> myWritable <span class="op">=</span> <span class="kw">new</span> <span class="at">Writable</span>(<span class="op">{</span></a>
<a class="sourceLine" id="cb49-4" title="4">  <span class="at">construct</span>(callback) <span class="op">{</span></a>
<a class="sourceLine" id="cb49-5" title="5">    <span class="co">// Initialize state and load resources...</span></a>
<a class="sourceLine" id="cb49-6" title="6">  <span class="op">},</span></a>
<a class="sourceLine" id="cb49-7" title="7">  <span class="at">write</span>(chunk<span class="op">,</span> encoding<span class="op">,</span> callback) <span class="op">{</span></a>
<a class="sourceLine" id="cb49-8" title="8">    <span class="co">// ...</span></a>
<a class="sourceLine" id="cb49-9" title="9">  <span class="op">},</span></a>
<a class="sourceLine" id="cb49-10" title="10">  <span class="at">destroy</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb49-11" title="11">    <span class="co">// Free resources...</span></a>
<a class="sourceLine" id="cb49-12" title="12">  <span class="op">}</span></a>
<a class="sourceLine" id="cb49-13" title="13"><span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<h3 id="implementing-a-writable-stream">Implementing a writable stream</h3>
<p>The <code>stream.Writable</code> class is extended to implement a <a href="#stream_class_stream_writable"><code>Writable</code></a> stream.</p>
<p>Custom <code>Writable</code> streams <em>must</em> call the <code>new stream.Writable([options])</code> constructor and implement the <code>writable._write()</code> and/or <code>writable._writev()</code> method.</p>
<h4 id="new-stream.writableoptions"><code>new stream.Writable([options])</code></h4>
<!-- YAML
changes:
  - version: v15.5.0
    pr-url: https://github.com/nodejs/node/pull/36431
    description: support passing in an AbortSignal.
  - version: v14.0.0
    pr-url: https://github.com/nodejs/node/pull/30623
    description: Change `autoDestroy` option default to `true`.
  - version:
     - v11.2.0
     - v10.16.0
    pr-url: https://github.com/nodejs/node/pull/22795
    description: Add `autoDestroy` option to automatically `destroy()` the
                 stream when it emits `'finish'` or errors.
  - version: v10.0.0
    pr-url: https://github.com/nodejs/node/pull/18438
    description: Add `emitClose` option to specify if `'close'` is emitted on
                 destroy.
-->
<ul>
<li><code>options</code> {Object}
<ul>
<li><code>highWaterMark</code> {number} Buffer level when <a href="#stream_writable_write_chunk_encoding_callback"><code>stream.write()</code></a> starts returning <code>false</code>. <strong>Default:</strong> <code>16384</code> (16 KB), or <code>16</code> for <code>objectMode</code> streams.</li>
<li><code>decodeStrings</code> {boolean} Whether to encode <code>string</code>s passed to <a href="#stream_writable_write_chunk_encoding_callback"><code>stream.write()</code></a> to <code>Buffer</code>s (with the encoding specified in the <a href="#stream_writable_write_chunk_encoding_callback"><code>stream.write()</code></a> call) before passing them to <a href="#stream_writable_write_chunk_encoding_callback_1"><code>stream._write()</code></a>. Other types of data are not converted (i.e. <code>Buffer</code>s are not decoded into <code>string</code>s). Setting to false will prevent <code>string</code>s from being converted. <strong>Default:</strong> <code>true</code>.</li>
<li><code>defaultEncoding</code> {string} The default encoding that is used when no encoding is specified as an argument to <a href="#stream_writable_write_chunk_encoding_callback"><code>stream.write()</code></a>. <strong>Default:</strong> <code>'utf8'</code>.</li>
<li><code>objectMode</code> {boolean} Whether or not the <a href="#stream_writable_write_chunk_encoding_callback"><code>stream.write(anyObj)</code></a> is a valid operation. When set, it becomes possible to write JavaScript values other than string, <code>Buffer</code> or <code>Uint8Array</code> if supported by the stream implementation. <strong>Default:</strong> <code>false</code>.</li>
<li><code>emitClose</code> {boolean} Whether or not the stream should emit <code>'close'</code> after it has been destroyed. <strong>Default:</strong> <code>true</code>.</li>
<li><code>write</code> {Function} Implementation for the <a href="#stream_writable_write_chunk_encoding_callback_1"><code>stream._write()</code></a> method.</li>
<li><code>writev</code> {Function} Implementation for the <a href="#stream_writable_writev_chunks_callback"><code>stream._writev()</code></a> method.</li>
<li><code>destroy</code> {Function} Implementation for the <a href="#stream_writable_destroy_err_callback"><code>stream._destroy()</code></a> method.</li>
<li><code>final</code> {Function} Implementation for the <a href="#stream_writable_final_callback"><code>stream._final()</code></a> method.</li>
<li><code>construct</code> {Function} Implementation for the <a href="#stream_writable_construct_callback"><code>stream._construct()</code></a> method.</li>
<li><code>autoDestroy</code> {boolean} Whether this stream should automatically call <code>.destroy()</code> on itself after ending. <strong>Default:</strong> <code>true</code>.</li>
<li><code>signal</code> {AbortSignal} A signal representing possible cancellation.</li>
</ul></li>
</ul>
<!-- eslint-disable no-useless-constructor -->
<div class="sourceCode" id="cb50"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb50-1" title="1"><span class="kw">const</span> <span class="op">{</span> Writable <span class="op">}</span> <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;stream&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb50-2" title="2"></a>
<a class="sourceLine" id="cb50-3" title="3"><span class="kw">class</span> MyWritable <span class="kw">extends</span> Writable <span class="op">{</span></a>
<a class="sourceLine" id="cb50-4" title="4">  <span class="at">constructor</span>(options) <span class="op">{</span></a>
<a class="sourceLine" id="cb50-5" title="5">    <span class="co">// Calls the stream.Writable() constructor.</span></a>
<a class="sourceLine" id="cb50-6" title="6">    <span class="kw">super</span>(options)<span class="op">;</span></a>
<a class="sourceLine" id="cb50-7" title="7">    <span class="co">// ...</span></a>
<a class="sourceLine" id="cb50-8" title="8">  <span class="op">}</span></a>
<a class="sourceLine" id="cb50-9" title="9"><span class="op">}</span></a></code></pre></div>
<p>Or, when using pre-ES6 style constructors:</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb51-1" title="1"><span class="kw">const</span> <span class="op">{</span> Writable <span class="op">}</span> <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;stream&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb51-2" title="2"><span class="kw">const</span> util <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;util&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb51-3" title="3"></a>
<a class="sourceLine" id="cb51-4" title="4"><span class="kw">function</span> <span class="at">MyWritable</span>(options) <span class="op">{</span></a>
<a class="sourceLine" id="cb51-5" title="5">  <span class="cf">if</span> (<span class="op">!</span>(<span class="kw">this</span> <span class="kw">instanceof</span> MyWritable))</a>
<a class="sourceLine" id="cb51-6" title="6">    <span class="cf">return</span> <span class="kw">new</span> <span class="at">MyWritable</span>(options)<span class="op">;</span></a>
<a class="sourceLine" id="cb51-7" title="7">  <span class="va">Writable</span>.<span class="at">call</span>(<span class="kw">this</span><span class="op">,</span> options)<span class="op">;</span></a>
<a class="sourceLine" id="cb51-8" title="8"><span class="op">}</span></a>
<a class="sourceLine" id="cb51-9" title="9"><span class="va">util</span>.<span class="at">inherits</span>(MyWritable<span class="op">,</span> Writable)<span class="op">;</span></a></code></pre></div>
<p>Or, using the simplified constructor approach:</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb52-1" title="1"><span class="kw">const</span> <span class="op">{</span> Writable <span class="op">}</span> <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;stream&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb52-2" title="2"></a>
<a class="sourceLine" id="cb52-3" title="3"><span class="kw">const</span> myWritable <span class="op">=</span> <span class="kw">new</span> <span class="at">Writable</span>(<span class="op">{</span></a>
<a class="sourceLine" id="cb52-4" title="4">  <span class="at">write</span>(chunk<span class="op">,</span> encoding<span class="op">,</span> callback) <span class="op">{</span></a>
<a class="sourceLine" id="cb52-5" title="5">    <span class="co">// ...</span></a>
<a class="sourceLine" id="cb52-6" title="6">  <span class="op">},</span></a>
<a class="sourceLine" id="cb52-7" title="7">  <span class="at">writev</span>(chunks<span class="op">,</span> callback) <span class="op">{</span></a>
<a class="sourceLine" id="cb52-8" title="8">    <span class="co">// ...</span></a>
<a class="sourceLine" id="cb52-9" title="9">  <span class="op">}</span></a>
<a class="sourceLine" id="cb52-10" title="10"><span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<p>Calling <code>abort</code> on the <code>AbortController</code> corresponding to the passed <code>AbortSignal</code> will behave the same way as calling <code>.destroy(new AbortError())</code> on the writeable stream.</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb53-1" title="1"><span class="kw">const</span> <span class="op">{</span> Writable <span class="op">}</span> <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;stream&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb53-2" title="2"></a>
<a class="sourceLine" id="cb53-3" title="3"><span class="kw">const</span> controller <span class="op">=</span> <span class="kw">new</span> <span class="at">AbortController</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb53-4" title="4"><span class="kw">const</span> myWritable <span class="op">=</span> <span class="kw">new</span> <span class="at">Writable</span>(<span class="op">{</span></a>
<a class="sourceLine" id="cb53-5" title="5">  <span class="at">write</span>(chunk<span class="op">,</span> encoding<span class="op">,</span> callback) <span class="op">{</span></a>
<a class="sourceLine" id="cb53-6" title="6">    <span class="co">// ...</span></a>
<a class="sourceLine" id="cb53-7" title="7">  <span class="op">},</span></a>
<a class="sourceLine" id="cb53-8" title="8">  <span class="at">writev</span>(chunks<span class="op">,</span> callback) <span class="op">{</span></a>
<a class="sourceLine" id="cb53-9" title="9">    <span class="co">// ...</span></a>
<a class="sourceLine" id="cb53-10" title="10">  <span class="op">},</span></a>
<a class="sourceLine" id="cb53-11" title="11">  <span class="dt">signal</span><span class="op">:</span> <span class="va">controller</span>.<span class="at">signal</span></a>
<a class="sourceLine" id="cb53-12" title="12"><span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb53-13" title="13"><span class="co">// Later, abort the operation closing the stream</span></a>
<a class="sourceLine" id="cb53-14" title="14"><span class="va">controller</span>.<span class="at">abort</span>()<span class="op">;</span></a></code></pre></div>
<h4 id="writable._constructcallback"><code>writable._construct(callback)</code></h4>
<!-- YAML
added: v15.0.0
-->
<ul>
<li><code>callback</code> {Function} Call this function (optionally with an error argument) when the stream has finished initializing.</li>
</ul>
<p>The <code>_construct()</code> method MUST NOT be called directly. It may be implemented by child classes, and if so, will be called by the internal <code>Writable</code> class methods only.</p>
<p>This optional function will be called in a tick after the stream constructor has returned, delaying any <code>_write()</code>, <code>_final()</code> and <code>_destroy()</code> calls until <code>callback</code> is called. This is useful to initialize state or asynchronously initialize resources before the stream can be used.</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb54-1" title="1"><span class="kw">const</span> <span class="op">{</span> Writable <span class="op">}</span> <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;stream&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb54-2" title="2"><span class="kw">const</span> fs <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;fs&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb54-3" title="3"></a>
<a class="sourceLine" id="cb54-4" title="4"><span class="kw">class</span> WriteStream <span class="kw">extends</span> Writable <span class="op">{</span></a>
<a class="sourceLine" id="cb54-5" title="5">  <span class="at">constructor</span>(filename) <span class="op">{</span></a>
<a class="sourceLine" id="cb54-6" title="6">    <span class="kw">super</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb54-7" title="7">    <span class="kw">this</span>.<span class="at">filename</span> <span class="op">=</span> filename<span class="op">;</span></a>
<a class="sourceLine" id="cb54-8" title="8">  <span class="op">}</span></a>
<a class="sourceLine" id="cb54-9" title="9">  <span class="at">_construct</span>(callback) <span class="op">{</span></a>
<a class="sourceLine" id="cb54-10" title="10">    <span class="va">fs</span>.<span class="at">open</span>(<span class="kw">this</span>.<span class="at">filename</span><span class="op">,</span> (err<span class="op">,</span> fd) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb54-11" title="11">      <span class="cf">if</span> (err) <span class="op">{</span></a>
<a class="sourceLine" id="cb54-12" title="12">        <span class="at">callback</span>(err)<span class="op">;</span></a>
<a class="sourceLine" id="cb54-13" title="13">      <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb54-14" title="14">        <span class="kw">this</span>.<span class="at">fd</span> <span class="op">=</span> fd<span class="op">;</span></a>
<a class="sourceLine" id="cb54-15" title="15">        <span class="at">callback</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb54-16" title="16">      <span class="op">}</span></a>
<a class="sourceLine" id="cb54-17" title="17">    <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb54-18" title="18">  <span class="op">}</span></a>
<a class="sourceLine" id="cb54-19" title="19">  <span class="at">_write</span>(chunk<span class="op">,</span> encoding<span class="op">,</span> callback) <span class="op">{</span></a>
<a class="sourceLine" id="cb54-20" title="20">    <span class="va">fs</span>.<span class="at">write</span>(<span class="kw">this</span>.<span class="at">fd</span><span class="op">,</span> chunk<span class="op">,</span> callback)<span class="op">;</span></a>
<a class="sourceLine" id="cb54-21" title="21">  <span class="op">}</span></a>
<a class="sourceLine" id="cb54-22" title="22">  <span class="at">_destroy</span>(err<span class="op">,</span> callback) <span class="op">{</span></a>
<a class="sourceLine" id="cb54-23" title="23">    <span class="cf">if</span> (<span class="kw">this</span>.<span class="at">fd</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb54-24" title="24">      <span class="va">fs</span>.<span class="at">close</span>(<span class="kw">this</span>.<span class="at">fd</span><span class="op">,</span> (er) <span class="kw">=&gt;</span> <span class="at">callback</span>(er <span class="op">||</span> err))<span class="op">;</span></a>
<a class="sourceLine" id="cb54-25" title="25">    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb54-26" title="26">      <span class="at">callback</span>(err)<span class="op">;</span></a>
<a class="sourceLine" id="cb54-27" title="27">    <span class="op">}</span></a>
<a class="sourceLine" id="cb54-28" title="28">  <span class="op">}</span></a>
<a class="sourceLine" id="cb54-29" title="29"><span class="op">}</span></a></code></pre></div>
<h4 id="writable._writechunk-encoding-callback"><code>writable._write(chunk, encoding, callback)</code></h4>
<!-- YAML
changes:
  - version: v12.11.0
    pr-url: https://github.com/nodejs/node/pull/29639
    description: _write() is optional when providing _writev().
-->
<ul>
<li><code>chunk</code> {Buffer|string|any} The <code>Buffer</code> to be written, converted from the <code>string</code> passed to <a href="#stream_writable_write_chunk_encoding_callback"><code>stream.write()</code></a>. If the stream’s <code>decodeStrings</code> option is <code>false</code> or the stream is operating in object mode, the chunk will not be converted &amp; will be whatever was passed to <a href="#stream_writable_write_chunk_encoding_callback"><code>stream.write()</code></a>.</li>
<li><code>encoding</code> {string} If the chunk is a string, then <code>encoding</code> is the character encoding of that string. If chunk is a <code>Buffer</code>, or if the stream is operating in object mode, <code>encoding</code> may be ignored.</li>
<li><code>callback</code> {Function} Call this function (optionally with an error argument) when processing is complete for the supplied chunk.</li>
</ul>
<p>All <code>Writable</code> stream implementations must provide a <a href="#stream_writable_write_chunk_encoding_callback_1"><code>writable._write()</code></a> and/or <a href="#stream_writable_writev_chunks_callback"><code>writable._writev()</code></a> method to send data to the underlying resource.</p>
<p><a href="#stream_class_stream_transform"><code>Transform</code></a> streams provide their own implementation of the <a href="#stream_writable_write_chunk_encoding_callback_1"><code>writable._write()</code></a>.</p>
<p>This function MUST NOT be called by application code directly. It should be implemented by child classes, and called by the internal <code>Writable</code> class methods only.</p>
<p>The <code>callback</code> function must be called synchronously inside of <code>writable._write()</code> or asynchronously (i.e. different tick) to signal either that the write completed successfully or failed with an error. The first argument passed to the <code>callback</code> must be the <code>Error</code> object if the call failed or <code>null</code> if the write succeeded.</p>
<p>All calls to <code>writable.write()</code> that occur between the time <code>writable._write()</code> is called and the <code>callback</code> is called will cause the written data to be buffered. When the <code>callback</code> is invoked, the stream might emit a <a href="#stream_event_drain"><code>'drain'</code></a> event. If a stream implementation is capable of processing multiple chunks of data at once, the <code>writable._writev()</code> method should be implemented.</p>
<p>If the <code>decodeStrings</code> property is explicitly set to <code>false</code> in the constructor options, then <code>chunk</code> will remain the same object that is passed to <code>.write()</code>, and may be a string rather than a <code>Buffer</code>. This is to support implementations that have an optimized handling for certain string data encodings. In that case, the <code>encoding</code> argument will indicate the character encoding of the string. Otherwise, the <code>encoding</code> argument can be safely ignored.</p>
<p>The <code>writable._write()</code> method is prefixed with an underscore because it is internal to the class that defines it, and should never be called directly by user programs.</p>
<h4 id="writable._writevchunks-callback"><code>writable._writev(chunks, callback)</code></h4>
<ul>
<li><code>chunks</code> {Object[]} The data to be written. The value is an array of {Object} that each represent a discrete chunk of data to write. The properties of these objects are:
<ul>
<li><code>chunk</code> {Buffer|string} A buffer instance or string containing the data to be written. The <code>chunk</code> will be a string if the <code>Writable</code> was created with the <code>decodeStrings</code> option set to <code>false</code> and a string was passed to <code>write()</code>.</li>
<li><code>encoding</code> {string} The character encoding of the <code>chunk</code>. If <code>chunk</code> is a <code>Buffer</code>, the <code>encoding</code> will be <code>'buffer'</code>.</li>
</ul></li>
<li><code>callback</code> {Function} A callback function (optionally with an error argument) to be invoked when processing is complete for the supplied chunks.</li>
</ul>
<p>This function MUST NOT be called by application code directly. It should be implemented by child classes, and called by the internal <code>Writable</code> class methods only.</p>
<p>The <code>writable._writev()</code> method may be implemented in addition or alternatively to <code>writable._write()</code> in stream implementations that are capable of processing multiple chunks of data at once. If implemented and if there is buffered data from previous writes, <code>_writev()</code> will be called instead of <code>_write()</code>.</p>
<p>The <code>writable._writev()</code> method is prefixed with an underscore because it is internal to the class that defines it, and should never be called directly by user programs.</p>
<h4 id="writable._destroyerr-callback"><code>writable._destroy(err, callback)</code></h4>
<!-- YAML
added: v8.0.0
-->
<ul>
<li><code>err</code> {Error} A possible error.</li>
<li><code>callback</code> {Function} A callback function that takes an optional error argument.</li>
</ul>
<p>The <code>_destroy()</code> method is called by <a href="#stream_writable_destroy_error"><code>writable.destroy()</code></a>. It can be overridden by child classes but it <strong>must not</strong> be called directly.</p>
<h4 id="writable._finalcallback"><code>writable._final(callback)</code></h4>
<!-- YAML
added: v8.0.0
-->
<ul>
<li><code>callback</code> {Function} Call this function (optionally with an error argument) when finished writing any remaining data.</li>
</ul>
<p>The <code>_final()</code> method <strong>must not</strong> be called directly. It may be implemented by child classes, and if so, will be called by the internal <code>Writable</code> class methods only.</p>
<p>This optional function will be called before the stream closes, delaying the <code>'finish'</code> event until <code>callback</code> is called. This is useful to close resources or write buffered data before a stream ends.</p>
<h4 id="errors-while-writing">Errors while writing</h4>
<p>Errors occurring during the processing of the <a href="#stream_writable_write_chunk_encoding_callback_1"><code>writable._write()</code></a>, <a href="#stream_writable_writev_chunks_callback"><code>writable._writev()</code></a> and <a href="#stream_writable_final_callback"><code>writable._final()</code></a> methods must be propagated by invoking the callback and passing the error as the first argument. Throwing an <code>Error</code> from within these methods or manually emitting an <code>'error'</code> event results in undefined behavior.</p>
<p>If a <code>Readable</code> stream pipes into a <code>Writable</code> stream when <code>Writable</code> emits an error, the <code>Readable</code> stream will be unpiped.</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb55-1" title="1"><span class="kw">const</span> <span class="op">{</span> Writable <span class="op">}</span> <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;stream&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb55-2" title="2"></a>
<a class="sourceLine" id="cb55-3" title="3"><span class="kw">const</span> myWritable <span class="op">=</span> <span class="kw">new</span> <span class="at">Writable</span>(<span class="op">{</span></a>
<a class="sourceLine" id="cb55-4" title="4">  <span class="at">write</span>(chunk<span class="op">,</span> encoding<span class="op">,</span> callback) <span class="op">{</span></a>
<a class="sourceLine" id="cb55-5" title="5">    <span class="cf">if</span> (<span class="va">chunk</span>.<span class="at">toString</span>().<span class="at">indexOf</span>(<span class="st">&#39;a&#39;</span>) <span class="op">&gt;=</span> <span class="dv">0</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb55-6" title="6">      <span class="at">callback</span>(<span class="kw">new</span> <span class="at">Error</span>(<span class="st">&#39;chunk is invalid&#39;</span>))<span class="op">;</span></a>
<a class="sourceLine" id="cb55-7" title="7">    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb55-8" title="8">      <span class="at">callback</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb55-9" title="9">    <span class="op">}</span></a>
<a class="sourceLine" id="cb55-10" title="10">  <span class="op">}</span></a>
<a class="sourceLine" id="cb55-11" title="11"><span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<h4 id="an-example-writable-stream">An example writable stream</h4>
<p>The following illustrates a rather simplistic (and somewhat pointless) custom <code>Writable</code> stream implementation. While this specific <code>Writable</code> stream instance is not of any real particular usefulness, the example illustrates each of the required elements of a custom <a href="#stream_class_stream_writable"><code>Writable</code></a> stream instance:</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb56-1" title="1"><span class="kw">const</span> <span class="op">{</span> Writable <span class="op">}</span> <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;stream&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb56-2" title="2"></a>
<a class="sourceLine" id="cb56-3" title="3"><span class="kw">class</span> MyWritable <span class="kw">extends</span> Writable <span class="op">{</span></a>
<a class="sourceLine" id="cb56-4" title="4">  <span class="at">_write</span>(chunk<span class="op">,</span> encoding<span class="op">,</span> callback) <span class="op">{</span></a>
<a class="sourceLine" id="cb56-5" title="5">    <span class="cf">if</span> (<span class="va">chunk</span>.<span class="at">toString</span>().<span class="at">indexOf</span>(<span class="st">&#39;a&#39;</span>) <span class="op">&gt;=</span> <span class="dv">0</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb56-6" title="6">      <span class="at">callback</span>(<span class="kw">new</span> <span class="at">Error</span>(<span class="st">&#39;chunk is invalid&#39;</span>))<span class="op">;</span></a>
<a class="sourceLine" id="cb56-7" title="7">    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb56-8" title="8">      <span class="at">callback</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb56-9" title="9">    <span class="op">}</span></a>
<a class="sourceLine" id="cb56-10" title="10">  <span class="op">}</span></a>
<a class="sourceLine" id="cb56-11" title="11"><span class="op">}</span></a></code></pre></div>
<h4 id="decoding-buffers-in-a-writable-stream">Decoding buffers in a writable stream</h4>
<p>Decoding buffers is a common task, for instance, when using transformers whose input is a string. This is not a trivial process when using multi-byte characters encoding, such as UTF-8. The following example shows how to decode multi-byte strings using <code>StringDecoder</code> and <a href="#stream_class_stream_writable"><code>Writable</code></a>.</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb57-1" title="1"><span class="kw">const</span> <span class="op">{</span> Writable <span class="op">}</span> <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;stream&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb57-2" title="2"><span class="kw">const</span> <span class="op">{</span> StringDecoder <span class="op">}</span> <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;string_decoder&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb57-3" title="3"></a>
<a class="sourceLine" id="cb57-4" title="4"><span class="kw">class</span> StringWritable <span class="kw">extends</span> Writable <span class="op">{</span></a>
<a class="sourceLine" id="cb57-5" title="5">  <span class="at">constructor</span>(options) <span class="op">{</span></a>
<a class="sourceLine" id="cb57-6" title="6">    <span class="kw">super</span>(options)<span class="op">;</span></a>
<a class="sourceLine" id="cb57-7" title="7">    <span class="kw">this</span>.<span class="at">_decoder</span> <span class="op">=</span> <span class="kw">new</span> <span class="at">StringDecoder</span>(options <span class="op">&amp;&amp;</span> <span class="va">options</span>.<span class="at">defaultEncoding</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb57-8" title="8">    <span class="kw">this</span>.<span class="at">data</span> <span class="op">=</span> <span class="st">&#39;&#39;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb57-9" title="9">  <span class="op">}</span></a>
<a class="sourceLine" id="cb57-10" title="10">  <span class="at">_write</span>(chunk<span class="op">,</span> encoding<span class="op">,</span> callback) <span class="op">{</span></a>
<a class="sourceLine" id="cb57-11" title="11">    <span class="cf">if</span> (encoding <span class="op">===</span> <span class="st">&#39;buffer&#39;</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb57-12" title="12">      chunk <span class="op">=</span> <span class="kw">this</span>.<span class="va">_decoder</span>.<span class="at">write</span>(chunk)<span class="op">;</span></a>
<a class="sourceLine" id="cb57-13" title="13">    <span class="op">}</span></a>
<a class="sourceLine" id="cb57-14" title="14">    <span class="kw">this</span>.<span class="at">data</span> <span class="op">+=</span> chunk<span class="op">;</span></a>
<a class="sourceLine" id="cb57-15" title="15">    <span class="at">callback</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb57-16" title="16">  <span class="op">}</span></a>
<a class="sourceLine" id="cb57-17" title="17">  <span class="at">_final</span>(callback) <span class="op">{</span></a>
<a class="sourceLine" id="cb57-18" title="18">    <span class="kw">this</span>.<span class="at">data</span> <span class="op">+=</span> <span class="kw">this</span>.<span class="va">_decoder</span>.<span class="at">end</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb57-19" title="19">    <span class="at">callback</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb57-20" title="20">  <span class="op">}</span></a>
<a class="sourceLine" id="cb57-21" title="21"><span class="op">}</span></a>
<a class="sourceLine" id="cb57-22" title="22"></a>
<a class="sourceLine" id="cb57-23" title="23"><span class="kw">const</span> euro <span class="op">=</span> [[<span class="bn">0xE2</span><span class="op">,</span> <span class="bn">0x82</span>]<span class="op">,</span> [<span class="bn">0xAC</span>]].<span class="at">map</span>(<span class="va">Buffer</span>.<span class="at">from</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb57-24" title="24"><span class="kw">const</span> w <span class="op">=</span> <span class="kw">new</span> <span class="at">StringWritable</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb57-25" title="25"></a>
<a class="sourceLine" id="cb57-26" title="26"><span class="va">w</span>.<span class="at">write</span>(<span class="st">&#39;currency: &#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb57-27" title="27"><span class="va">w</span>.<span class="at">write</span>(euro[<span class="dv">0</span>])<span class="op">;</span></a>
<a class="sourceLine" id="cb57-28" title="28"><span class="va">w</span>.<span class="at">end</span>(euro[<span class="dv">1</span>])<span class="op">;</span></a>
<a class="sourceLine" id="cb57-29" title="29"></a>
<a class="sourceLine" id="cb57-30" title="30"><span class="va">console</span>.<span class="at">log</span>(<span class="va">w</span>.<span class="at">data</span>)<span class="op">;</span> <span class="co">// currency: €</span></a></code></pre></div>
<h3 id="implementing-a-readable-stream">Implementing a readable stream</h3>
<p>The <code>stream.Readable</code> class is extended to implement a <a href="#stream_class_stream_readable"><code>Readable</code></a> stream.</p>
<p>Custom <code>Readable</code> streams <em>must</em> call the <code>new stream.Readable([options])</code> constructor and implement the <a href="#stream_readable_read_size_1"><code>readable._read()</code></a> method.</p>
<h4 id="new-stream.readableoptions"><code>new stream.Readable([options])</code></h4>
<!-- YAML
changes:
  - version: v15.5.0
    pr-url: https://github.com/nodejs/node/pull/36431
    description: support passing in an AbortSignal.
  - version: v14.0.0
    pr-url: https://github.com/nodejs/node/pull/30623
    description: Change `autoDestroy` option default to `true`.
  - version:
     - v11.2.0
     - v10.16.0
    pr-url: https://github.com/nodejs/node/pull/22795
    description: Add `autoDestroy` option to automatically `destroy()` the
                 stream when it emits `'end'` or errors.
-->
<ul>
<li><code>options</code> {Object}
<ul>
<li><code>highWaterMark</code> {number} The maximum <a href="#stream_highwatermark_discrepancy_after_calling_readable_setencoding">number of bytes</a> to store in the internal buffer before ceasing to read from the underlying resource. <strong>Default:</strong> <code>16384</code> (16 KB), or <code>16</code> for <code>objectMode</code> streams.</li>
<li><code>encoding</code> {string} If specified, then buffers will be decoded to strings using the specified encoding. <strong>Default:</strong> <code>null</code>.</li>
<li><code>objectMode</code> {boolean} Whether this stream should behave as a stream of objects. Meaning that <a href="#stream_readable_read_size"><code>stream.read(n)</code></a> returns a single value instead of a <code>Buffer</code> of size <code>n</code>. <strong>Default:</strong> <code>false</code>.</li>
<li><code>emitClose</code> {boolean} Whether or not the stream should emit <code>'close'</code> after it has been destroyed. <strong>Default:</strong> <code>true</code>.</li>
<li><code>read</code> {Function} Implementation for the <a href="#stream_readable_read_size_1"><code>stream._read()</code></a> method.</li>
<li><code>destroy</code> {Function} Implementation for the <a href="#stream_readable_destroy_err_callback"><code>stream._destroy()</code></a> method.</li>
<li><code>construct</code> {Function} Implementation for the <a href="#stream_readable_construct_callback"><code>stream._construct()</code></a> method.</li>
<li><code>autoDestroy</code> {boolean} Whether this stream should automatically call <code>.destroy()</code> on itself after ending. <strong>Default:</strong> <code>true</code>.</li>
<li><code>signal</code> {AbortSignal} A signal representing possible cancellation.</li>
</ul></li>
</ul>
<!-- eslint-disable no-useless-constructor -->
<div class="sourceCode" id="cb58"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb58-1" title="1"><span class="kw">const</span> <span class="op">{</span> Readable <span class="op">}</span> <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;stream&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb58-2" title="2"></a>
<a class="sourceLine" id="cb58-3" title="3"><span class="kw">class</span> MyReadable <span class="kw">extends</span> Readable <span class="op">{</span></a>
<a class="sourceLine" id="cb58-4" title="4">  <span class="at">constructor</span>(options) <span class="op">{</span></a>
<a class="sourceLine" id="cb58-5" title="5">    <span class="co">// Calls the stream.Readable(options) constructor.</span></a>
<a class="sourceLine" id="cb58-6" title="6">    <span class="kw">super</span>(options)<span class="op">;</span></a>
<a class="sourceLine" id="cb58-7" title="7">    <span class="co">// ...</span></a>
<a class="sourceLine" id="cb58-8" title="8">  <span class="op">}</span></a>
<a class="sourceLine" id="cb58-9" title="9"><span class="op">}</span></a></code></pre></div>
<p>Or, when using pre-ES6 style constructors:</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb59-1" title="1"><span class="kw">const</span> <span class="op">{</span> Readable <span class="op">}</span> <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;stream&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb59-2" title="2"><span class="kw">const</span> util <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;util&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb59-3" title="3"></a>
<a class="sourceLine" id="cb59-4" title="4"><span class="kw">function</span> <span class="at">MyReadable</span>(options) <span class="op">{</span></a>
<a class="sourceLine" id="cb59-5" title="5">  <span class="cf">if</span> (<span class="op">!</span>(<span class="kw">this</span> <span class="kw">instanceof</span> MyReadable))</a>
<a class="sourceLine" id="cb59-6" title="6">    <span class="cf">return</span> <span class="kw">new</span> <span class="at">MyReadable</span>(options)<span class="op">;</span></a>
<a class="sourceLine" id="cb59-7" title="7">  <span class="va">Readable</span>.<span class="at">call</span>(<span class="kw">this</span><span class="op">,</span> options)<span class="op">;</span></a>
<a class="sourceLine" id="cb59-8" title="8"><span class="op">}</span></a>
<a class="sourceLine" id="cb59-9" title="9"><span class="va">util</span>.<span class="at">inherits</span>(MyReadable<span class="op">,</span> Readable)<span class="op">;</span></a></code></pre></div>
<p>Or, using the simplified constructor approach:</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb60-1" title="1"><span class="kw">const</span> <span class="op">{</span> Readable <span class="op">}</span> <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;stream&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb60-2" title="2"></a>
<a class="sourceLine" id="cb60-3" title="3"><span class="kw">const</span> myReadable <span class="op">=</span> <span class="kw">new</span> <span class="at">Readable</span>(<span class="op">{</span></a>
<a class="sourceLine" id="cb60-4" title="4">  <span class="at">read</span>(size) <span class="op">{</span></a>
<a class="sourceLine" id="cb60-5" title="5">    <span class="co">// ...</span></a>
<a class="sourceLine" id="cb60-6" title="6">  <span class="op">}</span></a>
<a class="sourceLine" id="cb60-7" title="7"><span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<p>Calling <code>abort</code> on the <code>AbortController</code> corresponding to the passed <code>AbortSignal</code> will behave the same way as calling <code>.destroy(new AbortError())</code> on the readable created.</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb61-1" title="1"><span class="kw">const</span> <span class="op">{</span> Readable <span class="op">}</span> <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;stream&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb61-2" title="2"><span class="kw">const</span> controller <span class="op">=</span> <span class="kw">new</span> <span class="at">AbortController</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb61-3" title="3"><span class="kw">const</span> read <span class="op">=</span> <span class="kw">new</span> <span class="at">Readable</span>(<span class="op">{</span></a>
<a class="sourceLine" id="cb61-4" title="4">  <span class="at">read</span>(size) <span class="op">{</span></a>
<a class="sourceLine" id="cb61-5" title="5">    <span class="co">// ...</span></a>
<a class="sourceLine" id="cb61-6" title="6">  <span class="op">},</span></a>
<a class="sourceLine" id="cb61-7" title="7">  <span class="dt">signal</span><span class="op">:</span> <span class="va">controller</span>.<span class="at">signal</span></a>
<a class="sourceLine" id="cb61-8" title="8"><span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb61-9" title="9"><span class="co">// Later, abort the operation closing the stream</span></a>
<a class="sourceLine" id="cb61-10" title="10"><span class="va">controller</span>.<span class="at">abort</span>()<span class="op">;</span></a></code></pre></div>
<h4 id="readable._constructcallback"><code>readable._construct(callback)</code></h4>
<!-- YAML
added: v15.0.0
-->
<ul>
<li><code>callback</code> {Function} Call this function (optionally with an error argument) when the stream has finished initializing.</li>
</ul>
<p>The <code>_construct()</code> method MUST NOT be called directly. It may be implemented by child classes, and if so, will be called by the internal <code>Readable</code> class methods only.</p>
<p>This optional function will be scheduled in the next tick by the stream constructor, delaying any <code>_read()</code> and <code>_destroy()</code> calls until <code>callback</code> is called. This is useful to initialize state or asynchronously initialize resources before the stream can be used.</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb62-1" title="1"><span class="kw">const</span> <span class="op">{</span> Readable <span class="op">}</span> <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;stream&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb62-2" title="2"><span class="kw">const</span> fs <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;fs&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb62-3" title="3"></a>
<a class="sourceLine" id="cb62-4" title="4"><span class="kw">class</span> ReadStream <span class="kw">extends</span> Readable <span class="op">{</span></a>
<a class="sourceLine" id="cb62-5" title="5">  <span class="at">constructor</span>(filename) <span class="op">{</span></a>
<a class="sourceLine" id="cb62-6" title="6">    <span class="kw">super</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb62-7" title="7">    <span class="kw">this</span>.<span class="at">filename</span> <span class="op">=</span> filename<span class="op">;</span></a>
<a class="sourceLine" id="cb62-8" title="8">    <span class="kw">this</span>.<span class="at">fd</span> <span class="op">=</span> <span class="kw">null</span><span class="op">;</span></a>
<a class="sourceLine" id="cb62-9" title="9">  <span class="op">}</span></a>
<a class="sourceLine" id="cb62-10" title="10">  <span class="at">_construct</span>(callback) <span class="op">{</span></a>
<a class="sourceLine" id="cb62-11" title="11">    <span class="va">fs</span>.<span class="at">open</span>(<span class="kw">this</span>.<span class="at">filename</span><span class="op">,</span> (err<span class="op">,</span> fd) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb62-12" title="12">      <span class="cf">if</span> (err) <span class="op">{</span></a>
<a class="sourceLine" id="cb62-13" title="13">        <span class="at">callback</span>(err)<span class="op">;</span></a>
<a class="sourceLine" id="cb62-14" title="14">      <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb62-15" title="15">        <span class="kw">this</span>.<span class="at">fd</span> <span class="op">=</span> fd<span class="op">;</span></a>
<a class="sourceLine" id="cb62-16" title="16">        <span class="at">callback</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb62-17" title="17">      <span class="op">}</span></a>
<a class="sourceLine" id="cb62-18" title="18">    <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb62-19" title="19">  <span class="op">}</span></a>
<a class="sourceLine" id="cb62-20" title="20">  <span class="at">_read</span>(n) <span class="op">{</span></a>
<a class="sourceLine" id="cb62-21" title="21">    <span class="kw">const</span> buf <span class="op">=</span> <span class="va">Buffer</span>.<span class="at">alloc</span>(n)<span class="op">;</span></a>
<a class="sourceLine" id="cb62-22" title="22">    <span class="va">fs</span>.<span class="at">read</span>(<span class="kw">this</span>.<span class="at">fd</span><span class="op">,</span> buf<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> n<span class="op">,</span> <span class="kw">null</span><span class="op">,</span> (err<span class="op">,</span> bytesRead) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb62-23" title="23">      <span class="cf">if</span> (err) <span class="op">{</span></a>
<a class="sourceLine" id="cb62-24" title="24">        <span class="kw">this</span>.<span class="at">destroy</span>(err)<span class="op">;</span></a>
<a class="sourceLine" id="cb62-25" title="25">      <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb62-26" title="26">        <span class="kw">this</span>.<span class="at">push</span>(bytesRead <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">?</span> <span class="va">buf</span>.<span class="at">slice</span>(<span class="dv">0</span><span class="op">,</span> bytesRead) : <span class="kw">null</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb62-27" title="27">      <span class="op">}</span></a>
<a class="sourceLine" id="cb62-28" title="28">    <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb62-29" title="29">  <span class="op">}</span></a>
<a class="sourceLine" id="cb62-30" title="30">  <span class="at">_destroy</span>(err<span class="op">,</span> callback) <span class="op">{</span></a>
<a class="sourceLine" id="cb62-31" title="31">    <span class="cf">if</span> (<span class="kw">this</span>.<span class="at">fd</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb62-32" title="32">      <span class="va">fs</span>.<span class="at">close</span>(<span class="kw">this</span>.<span class="at">fd</span><span class="op">,</span> (er) <span class="kw">=&gt;</span> <span class="at">callback</span>(er <span class="op">||</span> err))<span class="op">;</span></a>
<a class="sourceLine" id="cb62-33" title="33">    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb62-34" title="34">      <span class="at">callback</span>(err)<span class="op">;</span></a>
<a class="sourceLine" id="cb62-35" title="35">    <span class="op">}</span></a>
<a class="sourceLine" id="cb62-36" title="36">  <span class="op">}</span></a>
<a class="sourceLine" id="cb62-37" title="37"><span class="op">}</span></a></code></pre></div>
<h4 id="readable._readsize"><code>readable._read(size)</code></h4>
<!-- YAML
added: v0.9.4
-->
<ul>
<li><code>size</code> {number} Number of bytes to read asynchronously</li>
</ul>
<p>This function MUST NOT be called by application code directly. It should be implemented by child classes, and called by the internal <code>Readable</code> class methods only.</p>
<p>All <code>Readable</code> stream implementations must provide an implementation of the <a href="#stream_readable_read_size_1"><code>readable._read()</code></a> method to fetch data from the underlying resource.</p>
<p>When <a href="#stream_readable_read_size_1"><code>readable._read()</code></a> is called, if data is available from the resource, the implementation should begin pushing that data into the read queue using the <a href="#stream_readable_push_chunk_encoding"><code>this.push(dataChunk)</code></a> method. <code>_read()</code> will be called again after each call to <a href="#stream_readable_push_chunk_encoding"><code>this.push(dataChunk)</code></a> once the stream is ready to accept more data. <code>_read()</code> may continue reading from the resource and pushing data until <code>readable.push()</code> returns <code>false</code>. Only when <code>_read()</code> is called again after it has stopped should it resume pushing additional data into the queue.</p>
<p>Once the <a href="#stream_readable_read_size_1"><code>readable._read()</code></a> method has been called, it will not be called again until more data is pushed through the <a href="#stream_readable_push_chunk_encoding"><code>readable.push()</code></a> method. Empty data such as empty buffers and strings will not cause <a href="#stream_readable_read_size_1"><code>readable._read()</code></a> to be called.</p>
<p>The <code>size</code> argument is advisory. For implementations where a “read” is a single operation that returns data can use the <code>size</code> argument to determine how much data to fetch. Other implementations may ignore this argument and simply provide data whenever it becomes available. There is no need to “wait” until <code>size</code> bytes are available before calling <a href="#stream_readable_push_chunk_encoding"><code>stream.push(chunk)</code></a>.</p>
<p>The <a href="#stream_readable_read_size_1"><code>readable._read()</code></a> method is prefixed with an underscore because it is internal to the class that defines it, and should never be called directly by user programs.</p>
<h4 id="readable._destroyerr-callback"><code>readable._destroy(err, callback)</code></h4>
<!-- YAML
added: v8.0.0
-->
<ul>
<li><code>err</code> {Error} A possible error.</li>
<li><code>callback</code> {Function} A callback function that takes an optional error argument.</li>
</ul>
<p>The <code>_destroy()</code> method is called by <a href="#stream_readable_destroy_error"><code>readable.destroy()</code></a>. It can be overridden by child classes but it <strong>must not</strong> be called directly.</p>
<h4 id="readable.pushchunk-encoding"><code>readable.push(chunk[, encoding])</code></h4>
<!-- YAML
changes:
  - version: v8.0.0
    pr-url: https://github.com/nodejs/node/pull/11608
    description: The `chunk` argument can now be a `Uint8Array` instance.
-->
<ul>
<li><code>chunk</code> {Buffer|Uint8Array|string|null|any} Chunk of data to push into the read queue. For streams not operating in object mode, <code>chunk</code> must be a string, <code>Buffer</code> or <code>Uint8Array</code>. For object mode streams, <code>chunk</code> may be any JavaScript value.</li>
<li><code>encoding</code> {string} Encoding of string chunks. Must be a valid <code>Buffer</code> encoding, such as <code>'utf8'</code> or <code>'ascii'</code>.</li>
<li>Returns: {boolean} <code>true</code> if additional chunks of data may continue to be pushed; <code>false</code> otherwise.</li>
</ul>
<p>When <code>chunk</code> is a <code>Buffer</code>, <code>Uint8Array</code> or <code>string</code>, the <code>chunk</code> of data will be added to the internal queue for users of the stream to consume. Passing <code>chunk</code> as <code>null</code> signals the end of the stream (EOF), after which no more data can be written.</p>
<p>When the <code>Readable</code> is operating in paused mode, the data added with <code>readable.push()</code> can be read out by calling the <a href="#stream_readable_read_size"><code>readable.read()</code></a> method when the <a href="#stream_event_readable"><code>'readable'</code></a> event is emitted.</p>
<p>When the <code>Readable</code> is operating in flowing mode, the data added with <code>readable.push()</code> will be delivered by emitting a <code>'data'</code> event.</p>
<p>The <code>readable.push()</code> method is designed to be as flexible as possible. For example, when wrapping a lower-level source that provides some form of pause/resume mechanism, and a data callback, the low-level source can be wrapped by the custom <code>Readable</code> instance:</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb63-1" title="1"><span class="co">// `_source` is an object with readStop() and readStart() methods,</span></a>
<a class="sourceLine" id="cb63-2" title="2"><span class="co">// and an `ondata` member that gets called when it has data, and</span></a>
<a class="sourceLine" id="cb63-3" title="3"><span class="co">// an `onend` member that gets called when the data is over.</span></a>
<a class="sourceLine" id="cb63-4" title="4"></a>
<a class="sourceLine" id="cb63-5" title="5"><span class="kw">class</span> SourceWrapper <span class="kw">extends</span> Readable <span class="op">{</span></a>
<a class="sourceLine" id="cb63-6" title="6">  <span class="at">constructor</span>(options) <span class="op">{</span></a>
<a class="sourceLine" id="cb63-7" title="7">    <span class="kw">super</span>(options)<span class="op">;</span></a>
<a class="sourceLine" id="cb63-8" title="8"></a>
<a class="sourceLine" id="cb63-9" title="9">    <span class="kw">this</span>.<span class="at">_source</span> <span class="op">=</span> <span class="at">getLowLevelSourceObject</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb63-10" title="10"></a>
<a class="sourceLine" id="cb63-11" title="11">    <span class="co">// Every time there&#39;s data, push it into the internal buffer.</span></a>
<a class="sourceLine" id="cb63-12" title="12">    <span class="kw">this</span>.<span class="va">_source</span>.<span class="at">ondata</span> <span class="op">=</span> (chunk) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb63-13" title="13">      <span class="co">// If push() returns false, then stop reading from source.</span></a>
<a class="sourceLine" id="cb63-14" title="14">      <span class="cf">if</span> (<span class="op">!</span><span class="kw">this</span>.<span class="at">push</span>(chunk))</a>
<a class="sourceLine" id="cb63-15" title="15">        <span class="kw">this</span>.<span class="va">_source</span>.<span class="at">readStop</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb63-16" title="16">    <span class="op">};</span></a>
<a class="sourceLine" id="cb63-17" title="17"></a>
<a class="sourceLine" id="cb63-18" title="18">    <span class="co">// When the source ends, push the EOF-signaling `null` chunk.</span></a>
<a class="sourceLine" id="cb63-19" title="19">    <span class="kw">this</span>.<span class="va">_source</span>.<span class="at">onend</span> <span class="op">=</span> () <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb63-20" title="20">      <span class="kw">this</span>.<span class="at">push</span>(<span class="kw">null</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb63-21" title="21">    <span class="op">};</span></a>
<a class="sourceLine" id="cb63-22" title="22">  <span class="op">}</span></a>
<a class="sourceLine" id="cb63-23" title="23">  <span class="co">// _read() will be called when the stream wants to pull more data in.</span></a>
<a class="sourceLine" id="cb63-24" title="24">  <span class="co">// The advisory size argument is ignored in this case.</span></a>
<a class="sourceLine" id="cb63-25" title="25">  <span class="at">_read</span>(size) <span class="op">{</span></a>
<a class="sourceLine" id="cb63-26" title="26">    <span class="kw">this</span>.<span class="va">_source</span>.<span class="at">readStart</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb63-27" title="27">  <span class="op">}</span></a>
<a class="sourceLine" id="cb63-28" title="28"><span class="op">}</span></a></code></pre></div>
<p>The <code>readable.push()</code> method is used to push the content into the internal buffer. It can be driven by the <a href="#stream_readable_read_size_1"><code>readable._read()</code></a> method.</p>
<p>For streams not operating in object mode, if the <code>chunk</code> parameter of <code>readable.push()</code> is <code>undefined</code>, it will be treated as empty string or buffer. See <a href="#stream_readable_push"><code>readable.push('')</code></a> for more information.</p>
<h4 id="errors-while-reading">Errors while reading</h4>
<p>Errors occurring during processing of the <a href="#stream_readable_read_size_1"><code>readable._read()</code></a> must be propagated through the <a href="#stream_readable_destroy_err_callback"><code>readable.destroy(err)</code></a> method. Throwing an <code>Error</code> from within <a href="#stream_readable_read_size_1"><code>readable._read()</code></a> or manually emitting an <code>'error'</code> event results in undefined behavior.</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb64-1" title="1"><span class="kw">const</span> <span class="op">{</span> Readable <span class="op">}</span> <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;stream&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb64-2" title="2"></a>
<a class="sourceLine" id="cb64-3" title="3"><span class="kw">const</span> myReadable <span class="op">=</span> <span class="kw">new</span> <span class="at">Readable</span>(<span class="op">{</span></a>
<a class="sourceLine" id="cb64-4" title="4">  <span class="at">read</span>(size) <span class="op">{</span></a>
<a class="sourceLine" id="cb64-5" title="5">    <span class="kw">const</span> err <span class="op">=</span> <span class="at">checkSomeErrorCondition</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb64-6" title="6">    <span class="cf">if</span> (err) <span class="op">{</span></a>
<a class="sourceLine" id="cb64-7" title="7">      <span class="kw">this</span>.<span class="at">destroy</span>(err)<span class="op">;</span></a>
<a class="sourceLine" id="cb64-8" title="8">    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb64-9" title="9">      <span class="co">// Do some work.</span></a>
<a class="sourceLine" id="cb64-10" title="10">    <span class="op">}</span></a>
<a class="sourceLine" id="cb64-11" title="11">  <span class="op">}</span></a>
<a class="sourceLine" id="cb64-12" title="12"><span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<h4 id="an-example-counting-stream">An example counting stream</h4>
<!--type=example-->
<p>The following is a basic example of a <code>Readable</code> stream that emits the numerals from 1 to 1,000,000 in ascending order, and then ends.</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb65-1" title="1"><span class="kw">const</span> <span class="op">{</span> Readable <span class="op">}</span> <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;stream&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb65-2" title="2"></a>
<a class="sourceLine" id="cb65-3" title="3"><span class="kw">class</span> Counter <span class="kw">extends</span> Readable <span class="op">{</span></a>
<a class="sourceLine" id="cb65-4" title="4">  <span class="at">constructor</span>(opt) <span class="op">{</span></a>
<a class="sourceLine" id="cb65-5" title="5">    <span class="kw">super</span>(opt)<span class="op">;</span></a>
<a class="sourceLine" id="cb65-6" title="6">    <span class="kw">this</span>.<span class="at">_max</span> <span class="op">=</span> <span class="dv">1000000</span><span class="op">;</span></a>
<a class="sourceLine" id="cb65-7" title="7">    <span class="kw">this</span>.<span class="at">_index</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></a>
<a class="sourceLine" id="cb65-8" title="8">  <span class="op">}</span></a>
<a class="sourceLine" id="cb65-9" title="9"></a>
<a class="sourceLine" id="cb65-10" title="10">  <span class="at">_read</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb65-11" title="11">    <span class="kw">const</span> i <span class="op">=</span> <span class="kw">this</span>.<span class="at">_index</span><span class="op">++;</span></a>
<a class="sourceLine" id="cb65-12" title="12">    <span class="cf">if</span> (i <span class="op">&gt;</span> <span class="kw">this</span>.<span class="at">_max</span>)</a>
<a class="sourceLine" id="cb65-13" title="13">      <span class="kw">this</span>.<span class="at">push</span>(<span class="kw">null</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb65-14" title="14">    <span class="cf">else</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb65-15" title="15">      <span class="kw">const</span> str <span class="op">=</span> <span class="at">String</span>(i)<span class="op">;</span></a>
<a class="sourceLine" id="cb65-16" title="16">      <span class="kw">const</span> buf <span class="op">=</span> <span class="va">Buffer</span>.<span class="at">from</span>(str<span class="op">,</span> <span class="st">&#39;ascii&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb65-17" title="17">      <span class="kw">this</span>.<span class="at">push</span>(buf)<span class="op">;</span></a>
<a class="sourceLine" id="cb65-18" title="18">    <span class="op">}</span></a>
<a class="sourceLine" id="cb65-19" title="19">  <span class="op">}</span></a>
<a class="sourceLine" id="cb65-20" title="20"><span class="op">}</span></a></code></pre></div>
<h3 id="implementing-a-duplex-stream">Implementing a duplex stream</h3>
<p>A <a href="#stream_class_stream_duplex"><code>Duplex</code></a> stream is one that implements both <a href="#stream_class_stream_readable"><code>Readable</code></a> and <a href="#stream_class_stream_writable"><code>Writable</code></a>, such as a TCP socket connection.</p>
<p>Because JavaScript does not have support for multiple inheritance, the <code>stream.Duplex</code> class is extended to implement a <a href="#stream_class_stream_duplex"><code>Duplex</code></a> stream (as opposed to extending the <code>stream.Readable</code> <em>and</em> <code>stream.Writable</code> classes).</p>
<p>The <code>stream.Duplex</code> class prototypically inherits from <code>stream.Readable</code> and parasitically from <code>stream.Writable</code>, but <code>instanceof</code> will work properly for both base classes due to overriding <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/hasInstance"><code>Symbol.hasInstance</code></a> on <code>stream.Writable</code>.</p>
<p>Custom <code>Duplex</code> streams <em>must</em> call the <code>new stream.Duplex([options])</code> constructor and implement <em>both</em> the <a href="#stream_readable_read_size_1"><code>readable._read()</code></a> and <code>writable._write()</code> methods.</p>
<h4 id="new-stream.duplexoptions"><code>new stream.Duplex(options)</code></h4>
<!-- YAML
changes:
  - version: v8.4.0
    pr-url: https://github.com/nodejs/node/pull/14636
    description: The `readableHighWaterMark` and `writableHighWaterMark` options
                 are supported now.
-->
<ul>
<li><code>options</code> {Object} Passed to both <code>Writable</code> and <code>Readable</code> constructors. Also has the following fields:
<ul>
<li><code>allowHalfOpen</code> {boolean} If set to <code>false</code>, then the stream will automatically end the writable side when the readable side ends. <strong>Default:</strong> <code>true</code>.</li>
<li><code>readable</code> {boolean} Sets whether the <code>Duplex</code> should be readable. <strong>Default:</strong> <code>true</code>.</li>
<li><code>writable</code> {boolean} Sets whether the <code>Duplex</code> should be writable. <strong>Default:</strong> <code>true</code>.</li>
<li><code>readableObjectMode</code> {boolean} Sets <code>objectMode</code> for readable side of the stream. Has no effect if <code>objectMode</code> is <code>true</code>. <strong>Default:</strong> <code>false</code>.</li>
<li><code>writableObjectMode</code> {boolean} Sets <code>objectMode</code> for writable side of the stream. Has no effect if <code>objectMode</code> is <code>true</code>. <strong>Default:</strong> <code>false</code>.</li>
<li><code>readableHighWaterMark</code> {number} Sets <code>highWaterMark</code> for the readable side of the stream. Has no effect if <code>highWaterMark</code> is provided.</li>
<li><code>writableHighWaterMark</code> {number} Sets <code>highWaterMark</code> for the writable side of the stream. Has no effect if <code>highWaterMark</code> is provided.</li>
</ul></li>
</ul>
<!-- eslint-disable no-useless-constructor -->
<div class="sourceCode" id="cb66"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb66-1" title="1"><span class="kw">const</span> <span class="op">{</span> Duplex <span class="op">}</span> <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;stream&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb66-2" title="2"></a>
<a class="sourceLine" id="cb66-3" title="3"><span class="kw">class</span> MyDuplex <span class="kw">extends</span> Duplex <span class="op">{</span></a>
<a class="sourceLine" id="cb66-4" title="4">  <span class="at">constructor</span>(options) <span class="op">{</span></a>
<a class="sourceLine" id="cb66-5" title="5">    <span class="kw">super</span>(options)<span class="op">;</span></a>
<a class="sourceLine" id="cb66-6" title="6">    <span class="co">// ...</span></a>
<a class="sourceLine" id="cb66-7" title="7">  <span class="op">}</span></a>
<a class="sourceLine" id="cb66-8" title="8"><span class="op">}</span></a></code></pre></div>
<p>Or, when using pre-ES6 style constructors:</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb67-1" title="1"><span class="kw">const</span> <span class="op">{</span> Duplex <span class="op">}</span> <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;stream&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb67-2" title="2"><span class="kw">const</span> util <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;util&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb67-3" title="3"></a>
<a class="sourceLine" id="cb67-4" title="4"><span class="kw">function</span> <span class="at">MyDuplex</span>(options) <span class="op">{</span></a>
<a class="sourceLine" id="cb67-5" title="5">  <span class="cf">if</span> (<span class="op">!</span>(<span class="kw">this</span> <span class="kw">instanceof</span> MyDuplex))</a>
<a class="sourceLine" id="cb67-6" title="6">    <span class="cf">return</span> <span class="kw">new</span> <span class="at">MyDuplex</span>(options)<span class="op">;</span></a>
<a class="sourceLine" id="cb67-7" title="7">  <span class="va">Duplex</span>.<span class="at">call</span>(<span class="kw">this</span><span class="op">,</span> options)<span class="op">;</span></a>
<a class="sourceLine" id="cb67-8" title="8"><span class="op">}</span></a>
<a class="sourceLine" id="cb67-9" title="9"><span class="va">util</span>.<span class="at">inherits</span>(MyDuplex<span class="op">,</span> Duplex)<span class="op">;</span></a></code></pre></div>
<p>Or, using the simplified constructor approach:</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb68-1" title="1"><span class="kw">const</span> <span class="op">{</span> Duplex <span class="op">}</span> <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;stream&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb68-2" title="2"></a>
<a class="sourceLine" id="cb68-3" title="3"><span class="kw">const</span> myDuplex <span class="op">=</span> <span class="kw">new</span> <span class="at">Duplex</span>(<span class="op">{</span></a>
<a class="sourceLine" id="cb68-4" title="4">  <span class="at">read</span>(size) <span class="op">{</span></a>
<a class="sourceLine" id="cb68-5" title="5">    <span class="co">// ...</span></a>
<a class="sourceLine" id="cb68-6" title="6">  <span class="op">},</span></a>
<a class="sourceLine" id="cb68-7" title="7">  <span class="at">write</span>(chunk<span class="op">,</span> encoding<span class="op">,</span> callback) <span class="op">{</span></a>
<a class="sourceLine" id="cb68-8" title="8">    <span class="co">// ...</span></a>
<a class="sourceLine" id="cb68-9" title="9">  <span class="op">}</span></a>
<a class="sourceLine" id="cb68-10" title="10"><span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<p>When using pipeline:</p>
<div class="sourceCode" id="cb69"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb69-1" title="1"><span class="kw">const</span> <span class="op">{</span> Transform<span class="op">,</span> pipeline <span class="op">}</span> <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;stream&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb69-2" title="2"><span class="kw">const</span> fs <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;fs&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb69-3" title="3"></a>
<a class="sourceLine" id="cb69-4" title="4"><span class="at">pipeline</span>(</a>
<a class="sourceLine" id="cb69-5" title="5">  <span class="va">fs</span>.<span class="at">createReadStream</span>(<span class="st">&#39;object.json&#39;</span>)</a>
<a class="sourceLine" id="cb69-6" title="6">    .<span class="at">setEncoding</span>(<span class="st">&#39;utf8&#39;</span>)<span class="op">,</span></a>
<a class="sourceLine" id="cb69-7" title="7">  <span class="kw">new</span> <span class="at">Transform</span>(<span class="op">{</span></a>
<a class="sourceLine" id="cb69-8" title="8">    <span class="dt">decodeStrings</span><span class="op">:</span> <span class="kw">false</span><span class="op">,</span> <span class="co">// Accept string input rather than Buffers</span></a>
<a class="sourceLine" id="cb69-9" title="9">    <span class="at">construct</span>(callback) <span class="op">{</span></a>
<a class="sourceLine" id="cb69-10" title="10">      <span class="kw">this</span>.<span class="at">data</span> <span class="op">=</span> <span class="st">&#39;&#39;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb69-11" title="11">      <span class="at">callback</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb69-12" title="12">    <span class="op">},</span></a>
<a class="sourceLine" id="cb69-13" title="13">    <span class="at">transform</span>(chunk<span class="op">,</span> encoding<span class="op">,</span> callback) <span class="op">{</span></a>
<a class="sourceLine" id="cb69-14" title="14">      <span class="kw">this</span>.<span class="at">data</span> <span class="op">+=</span> chunk<span class="op">;</span></a>
<a class="sourceLine" id="cb69-15" title="15">      <span class="at">callback</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb69-16" title="16">    <span class="op">},</span></a>
<a class="sourceLine" id="cb69-17" title="17">    <span class="at">flush</span>(callback) <span class="op">{</span></a>
<a class="sourceLine" id="cb69-18" title="18">      <span class="cf">try</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb69-19" title="19">        <span class="co">// Make sure is valid json.</span></a>
<a class="sourceLine" id="cb69-20" title="20">        <span class="va">JSON</span>.<span class="at">parse</span>(<span class="kw">this</span>.<span class="at">data</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb69-21" title="21">        <span class="kw">this</span>.<span class="at">push</span>(<span class="kw">this</span>.<span class="at">data</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb69-22" title="22">      <span class="op">}</span> <span class="cf">catch</span> (err) <span class="op">{</span></a>
<a class="sourceLine" id="cb69-23" title="23">        <span class="at">callback</span>(err)<span class="op">;</span></a>
<a class="sourceLine" id="cb69-24" title="24">      <span class="op">}</span></a>
<a class="sourceLine" id="cb69-25" title="25">    <span class="op">}</span></a>
<a class="sourceLine" id="cb69-26" title="26">  <span class="op">}</span>)<span class="op">,</span></a>
<a class="sourceLine" id="cb69-27" title="27">  <span class="va">fs</span>.<span class="at">createWriteStream</span>(<span class="st">&#39;valid-object.json&#39;</span>)<span class="op">,</span></a>
<a class="sourceLine" id="cb69-28" title="28">  (err) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb69-29" title="29">    <span class="cf">if</span> (err) <span class="op">{</span></a>
<a class="sourceLine" id="cb69-30" title="30">      <span class="va">console</span>.<span class="at">error</span>(<span class="st">&#39;failed&#39;</span><span class="op">,</span> err)<span class="op">;</span></a>
<a class="sourceLine" id="cb69-31" title="31">    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb69-32" title="32">      <span class="va">console</span>.<span class="at">log</span>(<span class="st">&#39;completed&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb69-33" title="33">    <span class="op">}</span></a>
<a class="sourceLine" id="cb69-34" title="34">  <span class="op">}</span></a>
<a class="sourceLine" id="cb69-35" title="35">)<span class="op">;</span></a></code></pre></div>
<h4 id="an-example-duplex-stream">An example duplex stream</h4>
<p>The following illustrates a simple example of a <code>Duplex</code> stream that wraps a hypothetical lower-level source object to which data can be written, and from which data can be read, albeit using an API that is not compatible with Node.js streams. The following illustrates a simple example of a <code>Duplex</code> stream that buffers incoming written data via the <a href="#stream_class_stream_writable"><code>Writable</code></a> interface that is read back out via the <a href="#stream_class_stream_readable"><code>Readable</code></a> interface.</p>
<div class="sourceCode" id="cb70"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb70-1" title="1"><span class="kw">const</span> <span class="op">{</span> Duplex <span class="op">}</span> <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;stream&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb70-2" title="2"><span class="kw">const</span> kSource <span class="op">=</span> <span class="at">Symbol</span>(<span class="st">&#39;source&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb70-3" title="3"></a>
<a class="sourceLine" id="cb70-4" title="4"><span class="kw">class</span> MyDuplex <span class="kw">extends</span> Duplex <span class="op">{</span></a>
<a class="sourceLine" id="cb70-5" title="5">  <span class="at">constructor</span>(source<span class="op">,</span> options) <span class="op">{</span></a>
<a class="sourceLine" id="cb70-6" title="6">    <span class="kw">super</span>(options)<span class="op">;</span></a>
<a class="sourceLine" id="cb70-7" title="7">    <span class="kw">this</span>[kSource] <span class="op">=</span> source<span class="op">;</span></a>
<a class="sourceLine" id="cb70-8" title="8">  <span class="op">}</span></a>
<a class="sourceLine" id="cb70-9" title="9"></a>
<a class="sourceLine" id="cb70-10" title="10">  <span class="at">_write</span>(chunk<span class="op">,</span> encoding<span class="op">,</span> callback) <span class="op">{</span></a>
<a class="sourceLine" id="cb70-11" title="11">    <span class="co">// The underlying source only deals with strings.</span></a>
<a class="sourceLine" id="cb70-12" title="12">    <span class="cf">if</span> (<span class="va">Buffer</span>.<span class="at">isBuffer</span>(chunk))</a>
<a class="sourceLine" id="cb70-13" title="13">      chunk <span class="op">=</span> <span class="va">chunk</span>.<span class="at">toString</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb70-14" title="14">    <span class="kw">this</span>[kSource].<span class="at">writeSomeData</span>(chunk)<span class="op">;</span></a>
<a class="sourceLine" id="cb70-15" title="15">    <span class="at">callback</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb70-16" title="16">  <span class="op">}</span></a>
<a class="sourceLine" id="cb70-17" title="17"></a>
<a class="sourceLine" id="cb70-18" title="18">  <span class="at">_read</span>(size) <span class="op">{</span></a>
<a class="sourceLine" id="cb70-19" title="19">    <span class="kw">this</span>[kSource].<span class="at">fetchSomeData</span>(size<span class="op">,</span> (data<span class="op">,</span> encoding) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb70-20" title="20">      <span class="kw">this</span>.<span class="at">push</span>(<span class="va">Buffer</span>.<span class="at">from</span>(data<span class="op">,</span> encoding))<span class="op">;</span></a>
<a class="sourceLine" id="cb70-21" title="21">    <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb70-22" title="22">  <span class="op">}</span></a>
<a class="sourceLine" id="cb70-23" title="23"><span class="op">}</span></a></code></pre></div>
<p>The most important aspect of a <code>Duplex</code> stream is that the <code>Readable</code> and <code>Writable</code> sides operate independently of one another despite co-existing within a single object instance.</p>
<h4 id="object-mode-duplex-streams">Object mode duplex streams</h4>
<p>For <code>Duplex</code> streams, <code>objectMode</code> can be set exclusively for either the <code>Readable</code> or <code>Writable</code> side using the <code>readableObjectMode</code> and <code>writableObjectMode</code> options respectively.</p>
<p>In the following example, for instance, a new <code>Transform</code> stream (which is a type of <a href="#stream_class_stream_duplex"><code>Duplex</code></a> stream) is created that has an object mode <code>Writable</code> side that accepts JavaScript numbers that are converted to hexadecimal strings on the <code>Readable</code> side.</p>
<div class="sourceCode" id="cb71"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb71-1" title="1"><span class="kw">const</span> <span class="op">{</span> Transform <span class="op">}</span> <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;stream&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb71-2" title="2"></a>
<a class="sourceLine" id="cb71-3" title="3"><span class="co">// All Transform streams are also Duplex Streams.</span></a>
<a class="sourceLine" id="cb71-4" title="4"><span class="kw">const</span> myTransform <span class="op">=</span> <span class="kw">new</span> <span class="at">Transform</span>(<span class="op">{</span></a>
<a class="sourceLine" id="cb71-5" title="5">  <span class="dt">writableObjectMode</span><span class="op">:</span> <span class="kw">true</span><span class="op">,</span></a>
<a class="sourceLine" id="cb71-6" title="6"></a>
<a class="sourceLine" id="cb71-7" title="7">  <span class="at">transform</span>(chunk<span class="op">,</span> encoding<span class="op">,</span> callback) <span class="op">{</span></a>
<a class="sourceLine" id="cb71-8" title="8">    <span class="co">// Coerce the chunk to a number if necessary.</span></a>
<a class="sourceLine" id="cb71-9" title="9">    chunk <span class="op">|=</span> <span class="dv">0</span><span class="op">;</span></a>
<a class="sourceLine" id="cb71-10" title="10"></a>
<a class="sourceLine" id="cb71-11" title="11">    <span class="co">// Transform the chunk into something else.</span></a>
<a class="sourceLine" id="cb71-12" title="12">    <span class="kw">const</span> data <span class="op">=</span> <span class="va">chunk</span>.<span class="at">toString</span>(<span class="dv">16</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb71-13" title="13"></a>
<a class="sourceLine" id="cb71-14" title="14">    <span class="co">// Push the data onto the readable queue.</span></a>
<a class="sourceLine" id="cb71-15" title="15">    <span class="at">callback</span>(<span class="kw">null</span><span class="op">,</span> <span class="st">&#39;0&#39;</span>.<span class="at">repeat</span>(<span class="va">data</span>.<span class="at">length</span> <span class="op">%</span> <span class="dv">2</span>) <span class="op">+</span> data)<span class="op">;</span></a>
<a class="sourceLine" id="cb71-16" title="16">  <span class="op">}</span></a>
<a class="sourceLine" id="cb71-17" title="17"><span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb71-18" title="18"></a>
<a class="sourceLine" id="cb71-19" title="19"><span class="va">myTransform</span>.<span class="at">setEncoding</span>(<span class="st">&#39;ascii&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb71-20" title="20"><span class="va">myTransform</span>.<span class="at">on</span>(<span class="st">&#39;data&#39;</span><span class="op">,</span> (chunk) <span class="kw">=&gt;</span> <span class="va">console</span>.<span class="at">log</span>(chunk))<span class="op">;</span></a>
<a class="sourceLine" id="cb71-21" title="21"></a>
<a class="sourceLine" id="cb71-22" title="22"><span class="va">myTransform</span>.<span class="at">write</span>(<span class="dv">1</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb71-23" title="23"><span class="co">// Prints: 01</span></a>
<a class="sourceLine" id="cb71-24" title="24"><span class="va">myTransform</span>.<span class="at">write</span>(<span class="dv">10</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb71-25" title="25"><span class="co">// Prints: 0a</span></a>
<a class="sourceLine" id="cb71-26" title="26"><span class="va">myTransform</span>.<span class="at">write</span>(<span class="dv">100</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb71-27" title="27"><span class="co">// Prints: 64</span></a></code></pre></div>
<h3 id="implementing-a-transform-stream">Implementing a transform stream</h3>
<p>A <a href="#stream_class_stream_transform"><code>Transform</code></a> stream is a <a href="#stream_class_stream_duplex"><code>Duplex</code></a> stream where the output is computed in some way from the input. Examples include <a href="zlib.md">zlib</a> streams or <a href="crypto.md">crypto</a> streams that compress, encrypt, or decrypt data.</p>
<p>There is no requirement that the output be the same size as the input, the same number of chunks, or arrive at the same time. For example, a <code>Hash</code> stream will only ever have a single chunk of output which is provided when the input is ended. A <code>zlib</code> stream will produce output that is either much smaller or much larger than its input.</p>
<p>The <code>stream.Transform</code> class is extended to implement a <a href="#stream_class_stream_transform"><code>Transform</code></a> stream.</p>
<p>The <code>stream.Transform</code> class prototypically inherits from <code>stream.Duplex</code> and implements its own versions of the <code>writable._write()</code> and <a href="#stream_readable_read_size_1"><code>readable._read()</code></a> methods. Custom <code>Transform</code> implementations <em>must</em> implement the <a href="#stream_transform_transform_chunk_encoding_callback"><code>transform._transform()</code></a> method and <em>may</em> also implement the <a href="#stream_transform_flush_callback"><code>transform._flush()</code></a> method.</p>
<p>Care must be taken when using <code>Transform</code> streams in that data written to the stream can cause the <code>Writable</code> side of the stream to become paused if the output on the <code>Readable</code> side is not consumed.</p>
<h4 id="new-stream.transformoptions"><code>new stream.Transform([options])</code></h4>
<ul>
<li><code>options</code> {Object} Passed to both <code>Writable</code> and <code>Readable</code> constructors. Also has the following fields:
<ul>
<li><code>transform</code> {Function} Implementation for the <a href="#stream_transform_transform_chunk_encoding_callback"><code>stream._transform()</code></a> method.</li>
<li><code>flush</code> {Function} Implementation for the <a href="#stream_transform_flush_callback"><code>stream._flush()</code></a> method.</li>
</ul></li>
</ul>
<!-- eslint-disable no-useless-constructor -->
<div class="sourceCode" id="cb72"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb72-1" title="1"><span class="kw">const</span> <span class="op">{</span> Transform <span class="op">}</span> <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;stream&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb72-2" title="2"></a>
<a class="sourceLine" id="cb72-3" title="3"><span class="kw">class</span> MyTransform <span class="kw">extends</span> Transform <span class="op">{</span></a>
<a class="sourceLine" id="cb72-4" title="4">  <span class="at">constructor</span>(options) <span class="op">{</span></a>
<a class="sourceLine" id="cb72-5" title="5">    <span class="kw">super</span>(options)<span class="op">;</span></a>
<a class="sourceLine" id="cb72-6" title="6">    <span class="co">// ...</span></a>
<a class="sourceLine" id="cb72-7" title="7">  <span class="op">}</span></a>
<a class="sourceLine" id="cb72-8" title="8"><span class="op">}</span></a></code></pre></div>
<p>Or, when using pre-ES6 style constructors:</p>
<div class="sourceCode" id="cb73"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb73-1" title="1"><span class="kw">const</span> <span class="op">{</span> Transform <span class="op">}</span> <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;stream&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb73-2" title="2"><span class="kw">const</span> util <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;util&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb73-3" title="3"></a>
<a class="sourceLine" id="cb73-4" title="4"><span class="kw">function</span> <span class="at">MyTransform</span>(options) <span class="op">{</span></a>
<a class="sourceLine" id="cb73-5" title="5">  <span class="cf">if</span> (<span class="op">!</span>(<span class="kw">this</span> <span class="kw">instanceof</span> MyTransform))</a>
<a class="sourceLine" id="cb73-6" title="6">    <span class="cf">return</span> <span class="kw">new</span> <span class="at">MyTransform</span>(options)<span class="op">;</span></a>
<a class="sourceLine" id="cb73-7" title="7">  <span class="va">Transform</span>.<span class="at">call</span>(<span class="kw">this</span><span class="op">,</span> options)<span class="op">;</span></a>
<a class="sourceLine" id="cb73-8" title="8"><span class="op">}</span></a>
<a class="sourceLine" id="cb73-9" title="9"><span class="va">util</span>.<span class="at">inherits</span>(MyTransform<span class="op">,</span> Transform)<span class="op">;</span></a></code></pre></div>
<p>Or, using the simplified constructor approach:</p>
<div class="sourceCode" id="cb74"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb74-1" title="1"><span class="kw">const</span> <span class="op">{</span> Transform <span class="op">}</span> <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;stream&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb74-2" title="2"></a>
<a class="sourceLine" id="cb74-3" title="3"><span class="kw">const</span> myTransform <span class="op">=</span> <span class="kw">new</span> <span class="at">Transform</span>(<span class="op">{</span></a>
<a class="sourceLine" id="cb74-4" title="4">  <span class="at">transform</span>(chunk<span class="op">,</span> encoding<span class="op">,</span> callback) <span class="op">{</span></a>
<a class="sourceLine" id="cb74-5" title="5">    <span class="co">// ...</span></a>
<a class="sourceLine" id="cb74-6" title="6">  <span class="op">}</span></a>
<a class="sourceLine" id="cb74-7" title="7"><span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<h4 id="event-end-1">Event: <code>'end'</code></h4>
<p>The <a href="#stream_event_end"><code>'end'</code></a> event is from the <code>stream.Readable</code> class. The <code>'end'</code> event is emitted after all data has been output, which occurs after the callback in <a href="#stream_transform_flush_callback"><code>transform._flush()</code></a> has been called. In the case of an error, <code>'end'</code> should not be emitted.</p>
<h4 id="event-finish-1">Event: <code>'finish'</code></h4>
<p>The <a href="#stream_event_finish"><code>'finish'</code></a> event is from the <code>stream.Writable</code> class. The <code>'finish'</code> event is emitted after <a href="#stream_writable_end_chunk_encoding_callback"><code>stream.end()</code></a> is called and all chunks have been processed by <a href="#stream_transform_transform_chunk_encoding_callback"><code>stream._transform()</code></a>. In the case of an error, <code>'finish'</code> should not be emitted.</p>
<h4 id="transform._flushcallback"><code>transform._flush(callback)</code></h4>
<ul>
<li><code>callback</code> {Function} A callback function (optionally with an error argument and data) to be called when remaining data has been flushed.</li>
</ul>
<p>This function MUST NOT be called by application code directly. It should be implemented by child classes, and called by the internal <code>Readable</code> class methods only.</p>
<p>In some cases, a transform operation may need to emit an additional bit of data at the end of the stream. For example, a <code>zlib</code> compression stream will store an amount of internal state used to optimally compress the output. When the stream ends, however, that additional data needs to be flushed so that the compressed data will be complete.</p>
<p>Custom <a href="#stream_class_stream_transform"><code>Transform</code></a> implementations <em>may</em> implement the <code>transform._flush()</code> method. This will be called when there is no more written data to be consumed, but before the <a href="#stream_event_end"><code>'end'</code></a> event is emitted signaling the end of the <a href="#stream_class_stream_readable"><code>Readable</code></a> stream.</p>
<p>Within the <code>transform._flush()</code> implementation, the <code>transform.push()</code> method may be called zero or more times, as appropriate. The <code>callback</code> function must be called when the flush operation is complete.</p>
<p>The <code>transform._flush()</code> method is prefixed with an underscore because it is internal to the class that defines it, and should never be called directly by user programs.</p>
<h4 id="transform._transformchunk-encoding-callback"><code>transform._transform(chunk, encoding, callback)</code></h4>
<ul>
<li><code>chunk</code> {Buffer|string|any} The <code>Buffer</code> to be transformed, converted from the <code>string</code> passed to <a href="#stream_writable_write_chunk_encoding_callback"><code>stream.write()</code></a>. If the stream’s <code>decodeStrings</code> option is <code>false</code> or the stream is operating in object mode, the chunk will not be converted &amp; will be whatever was passed to <a href="#stream_writable_write_chunk_encoding_callback"><code>stream.write()</code></a>.</li>
<li><code>encoding</code> {string} If the chunk is a string, then this is the encoding type. If chunk is a buffer, then this is the special value <code>'buffer'</code>. Ignore it in that case.</li>
<li><code>callback</code> {Function} A callback function (optionally with an error argument and data) to be called after the supplied <code>chunk</code> has been processed.</li>
</ul>
<p>This function MUST NOT be called by application code directly. It should be implemented by child classes, and called by the internal <code>Readable</code> class methods only.</p>
<p>All <code>Transform</code> stream implementations must provide a <code>_transform()</code> method to accept input and produce output. The <code>transform._transform()</code> implementation handles the bytes being written, computes an output, then passes that output off to the readable portion using the <code>transform.push()</code> method.</p>
<p>The <code>transform.push()</code> method may be called zero or more times to generate output from a single input chunk, depending on how much is to be output as a result of the chunk.</p>
<p>It is possible that no output is generated from any given chunk of input data.</p>
<p>The <code>callback</code> function must be called only when the current chunk is completely consumed. The first argument passed to the <code>callback</code> must be an <code>Error</code> object if an error occurred while processing the input or <code>null</code> otherwise. If a second argument is passed to the <code>callback</code>, it will be forwarded on to the <code>transform.push()</code> method. In other words, the following are equivalent:</p>
<div class="sourceCode" id="cb75"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb75-1" title="1"><span class="va">transform</span>.<span class="va">prototype</span>.<span class="at">_transform</span> <span class="op">=</span> <span class="kw">function</span>(data<span class="op">,</span> encoding<span class="op">,</span> callback) <span class="op">{</span></a>
<a class="sourceLine" id="cb75-2" title="2">  <span class="kw">this</span>.<span class="at">push</span>(data)<span class="op">;</span></a>
<a class="sourceLine" id="cb75-3" title="3">  <span class="at">callback</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb75-4" title="4"><span class="op">};</span></a>
<a class="sourceLine" id="cb75-5" title="5"></a>
<a class="sourceLine" id="cb75-6" title="6"><span class="va">transform</span>.<span class="va">prototype</span>.<span class="at">_transform</span> <span class="op">=</span> <span class="kw">function</span>(data<span class="op">,</span> encoding<span class="op">,</span> callback) <span class="op">{</span></a>
<a class="sourceLine" id="cb75-7" title="7">  <span class="at">callback</span>(<span class="kw">null</span><span class="op">,</span> data)<span class="op">;</span></a>
<a class="sourceLine" id="cb75-8" title="8"><span class="op">};</span></a></code></pre></div>
<p>The <code>transform._transform()</code> method is prefixed with an underscore because it is internal to the class that defines it, and should never be called directly by user programs.</p>
<p><code>transform._transform()</code> is never called in parallel; streams implement a queue mechanism, and to receive the next chunk, <code>callback</code> must be called, either synchronously or asynchronously.</p>
<h4 id="class-stream.passthrough">Class: <code>stream.PassThrough</code></h4>
<p>The <code>stream.PassThrough</code> class is a trivial implementation of a <a href="#stream_class_stream_transform"><code>Transform</code></a> stream that simply passes the input bytes across to the output. Its purpose is primarily for examples and testing, but there are some use cases where <code>stream.PassThrough</code> is useful as a building block for novel sorts of streams.</p>
<h2 id="additional-notes">Additional notes</h2>
<!--type=misc-->
<h3 id="streams-compatibility-with-async-generators-and-async-iterators">Streams compatibility with async generators and async iterators</h3>
<p>With the support of async generators and iterators in JavaScript, async generators are effectively a first-class language-level stream construct at this point.</p>
<p>Some common interop cases of using Node.js streams with async generators and async iterators are provided below.</p>
<h4 id="consuming-readable-streams-with-async-iterators">Consuming readable streams with async iterators</h4>
<div class="sourceCode" id="cb76"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb76-1" title="1">(<span class="kw">async</span> <span class="kw">function</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb76-2" title="2">  <span class="cf">for</span> <span class="cf">await</span> (<span class="kw">const</span> chunk <span class="kw">of</span> readable) <span class="op">{</span></a>
<a class="sourceLine" id="cb76-3" title="3">    <span class="va">console</span>.<span class="at">log</span>(chunk)<span class="op">;</span></a>
<a class="sourceLine" id="cb76-4" title="4">  <span class="op">}</span></a>
<a class="sourceLine" id="cb76-5" title="5"><span class="op">}</span>)()<span class="op">;</span></a></code></pre></div>
<p>Async iterators register a permanent error handler on the stream to prevent any unhandled post-destroy errors.</p>
<h4 id="creating-readable-streams-with-async-generators">Creating readable streams with async generators</h4>
<p>A Node.js readable stream can be created from an asynchronous generator using the <code>Readable.from()</code> utility method:</p>
<div class="sourceCode" id="cb77"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb77-1" title="1"><span class="kw">const</span> <span class="op">{</span> Readable <span class="op">}</span> <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;stream&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb77-2" title="2"></a>
<a class="sourceLine" id="cb77-3" title="3"><span class="kw">async</span> <span class="kw">function</span> <span class="op">*</span> <span class="at">generate</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb77-4" title="4">  <span class="kw">yield</span> <span class="st">&#39;a&#39;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb77-5" title="5">  <span class="kw">yield</span> <span class="st">&#39;b&#39;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb77-6" title="6">  <span class="kw">yield</span> <span class="st">&#39;c&#39;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb77-7" title="7"><span class="op">}</span></a>
<a class="sourceLine" id="cb77-8" title="8"></a>
<a class="sourceLine" id="cb77-9" title="9"><span class="kw">const</span> readable <span class="op">=</span> <span class="va">Readable</span>.<span class="at">from</span>(<span class="at">generate</span>())<span class="op">;</span></a>
<a class="sourceLine" id="cb77-10" title="10"></a>
<a class="sourceLine" id="cb77-11" title="11"><span class="va">readable</span>.<span class="at">on</span>(<span class="st">&#39;data&#39;</span><span class="op">,</span> (chunk) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb77-12" title="12">  <span class="va">console</span>.<span class="at">log</span>(chunk)<span class="op">;</span></a>
<a class="sourceLine" id="cb77-13" title="13"><span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<h4 id="piping-to-writable-streams-from-async-iterators">Piping to writable streams from async iterators</h4>
<p>When writing to a writable stream from an async iterator, ensure correct handling of backpressure and errors. <a href="#stream_stream_pipeline_source_transforms_destination_callback"><code>stream.pipeline()</code></a> abstracts away the handling of backpressure and backpressure-related errors:</p>
<div class="sourceCode" id="cb78"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb78-1" title="1"><span class="kw">const</span> fs <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;fs&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb78-2" title="2"><span class="kw">const</span> <span class="op">{</span> pipeline <span class="op">}</span> <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;stream&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb78-3" title="3"><span class="kw">const</span> <span class="op">{</span> <span class="dt">pipeline</span><span class="op">:</span> pipelinePromise <span class="op">}</span> <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;stream/promises&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb78-4" title="4"></a>
<a class="sourceLine" id="cb78-5" title="5"><span class="kw">const</span> writable <span class="op">=</span> <span class="va">fs</span>.<span class="at">createWriteStream</span>(<span class="st">&#39;./file&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb78-6" title="6"></a>
<a class="sourceLine" id="cb78-7" title="7"><span class="co">// Callback Pattern</span></a>
<a class="sourceLine" id="cb78-8" title="8"><span class="at">pipeline</span>(iterator<span class="op">,</span> writable<span class="op">,</span> (err<span class="op">,</span> value) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb78-9" title="9">  <span class="cf">if</span> (err) <span class="op">{</span></a>
<a class="sourceLine" id="cb78-10" title="10">    <span class="va">console</span>.<span class="at">error</span>(err)<span class="op">;</span></a>
<a class="sourceLine" id="cb78-11" title="11">  <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb78-12" title="12">    <span class="va">console</span>.<span class="at">log</span>(value<span class="op">,</span> <span class="st">&#39;value returned&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb78-13" title="13">  <span class="op">}</span></a>
<a class="sourceLine" id="cb78-14" title="14"><span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb78-15" title="15"></a>
<a class="sourceLine" id="cb78-16" title="16"><span class="co">// Promise Pattern</span></a>
<a class="sourceLine" id="cb78-17" title="17"><span class="at">pipelinePromise</span>(iterator<span class="op">,</span> writable)</a>
<a class="sourceLine" id="cb78-18" title="18">  .<span class="at">then</span>((value) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb78-19" title="19">    <span class="va">console</span>.<span class="at">log</span>(value<span class="op">,</span> <span class="st">&#39;value returned&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb78-20" title="20">  <span class="op">}</span>)</a>
<a class="sourceLine" id="cb78-21" title="21">  .<span class="at">catch</span>(<span class="va">console</span>.<span class="at">error</span>)<span class="op">;</span></a></code></pre></div>
<!--type=misc-->
<h3 id="compatibility-with-older-node.js-versions">Compatibility with older Node.js versions</h3>
<!--type=misc-->
<p>Prior to Node.js 0.10, the <code>Readable</code> stream interface was simpler, but also less powerful and less useful.</p>
<ul>
<li>Rather than waiting for calls to the <a href="#stream_readable_read_size"><code>stream.read()</code></a> method, <a href="#stream_event_data"><code>'data'</code></a> events would begin emitting immediately. Applications that would need to perform some amount of work to decide how to handle data were required to store read data into buffers so the data would not be lost.</li>
<li>The <a href="#stream_readable_pause"><code>stream.pause()</code></a> method was advisory, rather than guaranteed. This meant that it was still necessary to be prepared to receive <a href="#stream_event_data"><code>'data'</code></a> events <em>even when the stream was in a paused state</em>.</li>
</ul>
<p>In Node.js 0.10, the <a href="#stream_class_stream_readable"><code>Readable</code></a> class was added. For backward compatibility with older Node.js programs, <code>Readable</code> streams switch into “flowing mode” when a <a href="#stream_event_data"><code>'data'</code></a> event handler is added, or when the <a href="#stream_readable_resume"><code>stream.resume()</code></a> method is called. The effect is that, even when not using the new <a href="#stream_readable_read_size"><code>stream.read()</code></a> method and <a href="#stream_event_readable"><code>'readable'</code></a> event, it is no longer necessary to worry about losing <a href="#stream_event_data"><code>'data'</code></a> chunks.</p>
<p>While most applications will continue to function normally, this introduces an edge case in the following conditions:</p>
<ul>
<li>No <a href="#stream_event_data"><code>'data'</code></a> event listener is added.</li>
<li>The <a href="#stream_readable_resume"><code>stream.resume()</code></a> method is never called.</li>
<li>The stream is not piped to any writable destination.</li>
</ul>
<p>For example, consider the following code:</p>
<div class="sourceCode" id="cb79"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb79-1" title="1"><span class="co">// </span><span class="al">WARNING</span><span class="co">!  BROKEN!</span></a>
<a class="sourceLine" id="cb79-2" title="2"><span class="va">net</span>.<span class="at">createServer</span>((socket) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb79-3" title="3"></a>
<a class="sourceLine" id="cb79-4" title="4">  <span class="co">// We add an &#39;end&#39; listener, but never consume the data.</span></a>
<a class="sourceLine" id="cb79-5" title="5">  <span class="va">socket</span>.<span class="at">on</span>(<span class="st">&#39;end&#39;</span><span class="op">,</span> () <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb79-6" title="6">    <span class="co">// It will never get here.</span></a>
<a class="sourceLine" id="cb79-7" title="7">    <span class="va">socket</span>.<span class="at">end</span>(<span class="st">&#39;The message was received but was not processed.</span><span class="sc">\n</span><span class="st">&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb79-8" title="8">  <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb79-9" title="9"></a>
<a class="sourceLine" id="cb79-10" title="10"><span class="op">}</span>).<span class="at">listen</span>(<span class="dv">1337</span>)<span class="op">;</span></a></code></pre></div>
<p>Prior to Node.js 0.10, the incoming message data would be simply discarded. However, in Node.js 0.10 and beyond, the socket remains paused forever.</p>
<p>The workaround in this situation is to call the <a href="#stream_readable_resume"><code>stream.resume()</code></a> method to begin the flow of data:</p>
<div class="sourceCode" id="cb80"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb80-1" title="1"><span class="co">// Workaround.</span></a>
<a class="sourceLine" id="cb80-2" title="2"><span class="va">net</span>.<span class="at">createServer</span>((socket) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb80-3" title="3">  <span class="va">socket</span>.<span class="at">on</span>(<span class="st">&#39;end&#39;</span><span class="op">,</span> () <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb80-4" title="4">    <span class="va">socket</span>.<span class="at">end</span>(<span class="st">&#39;The message was received but was not processed.</span><span class="sc">\n</span><span class="st">&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb80-5" title="5">  <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb80-6" title="6"></a>
<a class="sourceLine" id="cb80-7" title="7">  <span class="co">// Start the flow of data, discarding it.</span></a>
<a class="sourceLine" id="cb80-8" title="8">  <span class="va">socket</span>.<span class="at">resume</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb80-9" title="9"><span class="op">}</span>).<span class="at">listen</span>(<span class="dv">1337</span>)<span class="op">;</span></a></code></pre></div>
<p>In addition to new <code>Readable</code> streams switching into flowing mode, pre-0.10 style streams can be wrapped in a <code>Readable</code> class using the <a href="#stream_readable_wrap_stream"><code>readable.wrap()</code></a> method.</p>
<h3 id="readable.read0"><code>readable.read(0)</code></h3>
<p>There are some cases where it is necessary to trigger a refresh of the underlying readable stream mechanisms, without actually consuming any data. In such cases, it is possible to call <code>readable.read(0)</code>, which will always return <code>null</code>.</p>
<p>If the internal read buffer is below the <code>highWaterMark</code>, and the stream is not currently reading, then calling <code>stream.read(0)</code> will trigger a low-level <a href="#stream_readable_read_size_1"><code>stream._read()</code></a> call.</p>
<p>While most applications will almost never need to do this, there are situations within Node.js where this is done, particularly in the <code>Readable</code> stream class internals.</p>
<h3 id="readable.push"><code>readable.push('')</code></h3>
<p>Use of <code>readable.push('')</code> is not recommended.</p>
<p>Pushing a zero-byte string, <code>Buffer</code> or <code>Uint8Array</code> to a stream that is not in object mode has an interesting side effect. Because it <em>is</em> a call to <a href="#stream_readable_push_chunk_encoding"><code>readable.push()</code></a>, the call will end the reading process. However, because the argument is an empty string, no data is added to the readable buffer so there is nothing for a user to consume.</p>
<h3 id="highwatermark-discrepancy-after-calling-readable.setencoding"><code>highWaterMark</code> discrepancy after calling <code>readable.setEncoding()</code></h3>
<p>The use of <code>readable.setEncoding()</code> will change the behavior of how the <code>highWaterMark</code> operates in non-object mode.</p>
<p>Typically, the size of the current buffer is measured against the <code>highWaterMark</code> in <em>bytes</em>. However, after <code>setEncoding()</code> is called, the comparison function will begin to measure the buffer’s size in <em>characters</em>.</p>
<p>This is not a problem in common cases with <code>latin1</code> or <code>ascii</code>. But it is advised to be mindful about this behavior when working with strings that could contain multi-byte characters.</p>
</body>
</html>
