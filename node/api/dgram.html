<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <meta charset="utf-8" />
    <meta name="generator" content="pandoc" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=yes"
    />
    <title>dgram</title>
    <style type="text/css">
      code {
        white-space: pre-wrap;
      }
      span.smallcaps {
        font-variant: small-caps;
      }
      span.underline {
        text-decoration: underline;
      }
      div.column {
        display: inline-block;
        vertical-align: top;
        width: 50%;
      }
    </style>
    <style type="text/css">
      a.sourceLine {
        display: inline-block;
        line-height: 1.25;
      }
      a.sourceLine {
        pointer-events: none;
        color: inherit;
        text-decoration: inherit;
      }
      a.sourceLine:empty {
        height: 1.2em;
      }
      .sourceCode {
        overflow: visible;
      }
      code.sourceCode {
        white-space: pre;
        position: relative;
      }
      div.sourceCode {
        margin: 1em 0;
      }
      pre.sourceCode {
        margin: 0;
      }
      @media screen {
        div.sourceCode {
          overflow: auto;
        }
      }
      @media print {
        code.sourceCode {
          white-space: pre-wrap;
        }
        a.sourceLine {
          text-indent: -1em;
          padding-left: 1em;
        }
      }
      pre.numberSource a.sourceLine {
        position: relative;
        left: -4em;
      }
      pre.numberSource a.sourceLine::before {
        content: attr(title);
        position: relative;
        left: -1em;
        text-align: right;
        vertical-align: baseline;
        border: none;
        pointer-events: all;
        display: inline-block;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        -khtml-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        padding: 0 4px;
        width: 4em;
        color: #aaaaaa;
      }
      pre.numberSource {
        margin-left: 3em;
        border-left: 1px solid #aaaaaa;
        padding-left: 4px;
      }
      div.sourceCode {
      }
      @media screen {
        a.sourceLine::before {
          text-decoration: underline;
        }
      }
      code span.al {
        color: #ff0000;
        font-weight: bold;
      } /* Alert */
      code span.an {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* Annotation */
      code span.at {
        color: #7d9029;
      } /* Attribute */
      code span.bn {
        color: #40a070;
      } /* BaseN */
      code span.bu {
      } /* BuiltIn */
      code span.cf {
        color: #007020;
        font-weight: bold;
      } /* ControlFlow */
      code span.ch {
        color: #4070a0;
      } /* Char */
      code span.cn {
        color: #880000;
      } /* Constant */
      code span.co {
        color: #60a0b0;
        font-style: italic;
      } /* Comment */
      code span.cv {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* CommentVar */
      code span.do {
        color: #ba2121;
        font-style: italic;
      } /* Documentation */
      code span.dt {
        color: #902000;
      } /* DataType */
      code span.dv {
        color: #40a070;
      } /* DecVal */
      code span.er {
        color: #ff0000;
        font-weight: bold;
      } /* Error */
      code span.ex {
      } /* Extension */
      code span.fl {
        color: #40a070;
      } /* Float */
      code span.fu {
        color: #06287e;
      } /* Function */
      code span.im {
      } /* Import */
      code span.in {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* Information */
      code span.kw {
        color: #007020;
        font-weight: bold;
      } /* Keyword */
      code span.op {
        color: #666666;
      } /* Operator */
      code span.ot {
        color: #007020;
      } /* Other */
      code span.pp {
        color: #bc7a00;
      } /* Preprocessor */
      code span.sc {
        color: #4070a0;
      } /* SpecialChar */
      code span.ss {
        color: #bb6688;
      } /* SpecialString */
      code span.st {
        color: #4070a0;
      } /* String */
      code span.va {
        color: #19177c;
      } /* Variable */
      code span.vs {
        color: #4070a0;
      } /* VerbatimString */
      code span.wa {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* Warning */
    </style>
  </head>
  <body>
    <h1 id="udpdatagram-sockets">UDP/datagram sockets</h1>
    <!--introduced_in=v0.10.0-->
    <blockquote>
      <p>Stability: 2 - Stable</p>
    </blockquote>
    <!-- name=dgram -->
    <!-- source_link=lib/dgram.js -->
    <p>
      The <code>dgram</code> module provides an implementation of UDP datagram
      sockets.
    </p>
    <pre class="mjs"><code>import dgram from &#39;dgram&#39;;

const server = dgram.createSocket(&#39;udp4&#39;);

server.on(&#39;error&#39;, (err) =&gt; {
  console.log(`server error:\n${err.stack}`);
  server.close();
});

server.on(&#39;message&#39;, (msg, rinfo) =&gt; {
  console.log(`server got: ${msg} from ${rinfo.address}:${rinfo.port}`);
});

server.on(&#39;listening&#39;, () =&gt; {
  const address = server.address();
  console.log(`server listening ${address.address}:${address.port}`);
});

server.bind(41234);
// Prints: server listening 0.0.0.0:41234</code></pre>
    <pre class="cjs"><code>const dgram = require(&#39;dgram&#39;);
const server = dgram.createSocket(&#39;udp4&#39;);

server.on(&#39;error&#39;, (err) =&gt; {
  console.log(`server error:\n${err.stack}`);
  server.close();
});

server.on(&#39;message&#39;, (msg, rinfo) =&gt; {
  console.log(`server got: ${msg} from ${rinfo.address}:${rinfo.port}`);
});

server.on(&#39;listening&#39;, () =&gt; {
  const address = server.address();
  console.log(`server listening ${address.address}:${address.port}`);
});

server.bind(41234);
// Prints: server listening 0.0.0.0:41234</code></pre>
    <h2 id="class-dgram.socket">Class: <code>dgram.Socket</code></h2>
    <!-- YAML
added: v0.1.99
-->
    <ul>
      <li>Extends: {EventEmitter}</li>
    </ul>
    <p>Encapsulates the datagram functionality.</p>
    <p>
      New instances of <code>dgram.Socket</code> are created using
      <a href="#dgram_dgram_createsocket_options_callback"
        ><code>dgram.createSocket()</code></a
      >. The <code>new</code> keyword is not to be used to create
      <code>dgram.Socket</code> instances.
    </p>
    <h3 id="event-close">Event: <code>'close'</code></h3>
    <!-- YAML
added: v0.1.99
-->
    <p>
      The <code>'close'</code> event is emitted after a socket is closed with
      <a href="#dgram_socket_close_callback"><code>close()</code></a
      >. Once triggered, no new <code>'message'</code> events will be emitted on
      this socket.
    </p>
    <h3 id="event-connect">Event: <code>'connect'</code></h3>
    <!-- YAML
added: v12.0.0
-->
    <p>
      The <code>'connect'</code> event is emitted after a socket is associated
      to a remote address as a result of a successful
      <a href="#dgram_socket_connect_port_address_callback"
        ><code>connect()</code></a
      >
      call.
    </p>
    <h3 id="event-error">Event: <code>'error'</code></h3>
    <!-- YAML
added: v0.1.99
-->
    <ul>
      <li><code>exception</code> {Error}</li>
    </ul>
    <p>
      The <code>'error'</code> event is emitted whenever any error occurs. The
      event handler function is passed a single <code>Error</code> object.
    </p>
    <h3 id="event-listening">Event: <code>'listening'</code></h3>
    <!-- YAML
added: v0.1.99
-->
    <p>
      The <code>'listening'</code> event is emitted once the
      <code>dgram.Socket</code> is addressable and can receive data. This
      happens either explicitly with <code>socket.bind()</code> or implicitly
      the first time data is sent using <code>socket.send()</code>. Until the
      <code>dgram.Socket</code> is listening, the underlying system resources do
      not exist and calls such as <code>socket.address()</code> and
      <code>socket.setTTL()</code> will fail.
    </p>
    <h3 id="event-message">Event: <code>'message'</code></h3>
    <!-- YAML
added: v0.1.99
-->
    <p>
      The <code>'message'</code> event is emitted when a new datagram is
      available on a socket. The event handler function is passed two arguments:
      <code>msg</code> and <code>rinfo</code>.
    </p>
    <ul>
      <li><code>msg</code> {Buffer} The message.</li>
      <li>
        <code>rinfo</code> {Object} Remote address information.
        <ul>
          <li><code>address</code> {string} The sender address.</li>
          <li>
            <code>family</code> {string} The address family (<code>'IPv4'</code>
            or <code>'IPv6'</code>).
          </li>
          <li><code>port</code> {number} The sender port.</li>
          <li><code>size</code> {number} The message size.</li>
        </ul>
      </li>
    </ul>
    <p>
      If the source address of the incoming packet is an IPv6 link-local
      address, the interface name is added to the <code>address</code>. For
      example, a packet received on the <code>en0</code> interface might have
      the address field set to <code>'fe80::2618:1234:ab11:3b9c%en0'</code>,
      where <code>'%en0'</code> is the interface name as a zone ID suffix.
    </p>
    <h3 id="socket.addmembershipmulticastaddress-multicastinterface">
      <code>socket.addMembership(multicastAddress[, multicastInterface])</code>
    </h3>
    <!-- YAML
added: v0.6.9
-->
    <ul>
      <li><code>multicastAddress</code> {string}</li>
      <li><code>multicastInterface</code> {string}</li>
    </ul>
    <p>
      Tells the kernel to join a multicast group at the given
      <code>multicastAddress</code> and <code>multicastInterface</code> using
      the <code>IP_ADD_MEMBERSHIP</code> socket option. If the
      <code>multicastInterface</code> argument is not specified, the operating
      system will choose one interface and will add membership to it. To add
      membership to every available interface, call
      <code>addMembership</code> multiple times, once per interface.
    </p>
    <p>
      When called on an unbound socket, this method will implicitly bind to a
      random port, listening on all interfaces.
    </p>
    <p>
      When sharing a UDP socket across multiple <code>cluster</code> workers,
      the <code>socket.addMembership()</code> function must be called only once
      or an <code>EADDRINUSE</code> error will occur:
    </p>
    <pre class="mjs"><code>import cluster from &#39;cluster&#39;;
import dgram from &#39;dgram&#39;;

if (cluster.isPrimary) {
  cluster.fork(); // Works ok.
  cluster.fork(); // Fails with EADDRINUSE.
} else {
  const s = dgram.createSocket(&#39;udp4&#39;);
  s.bind(1234, () =&gt; {
    s.addMembership(&#39;224.0.0.114&#39;);
  });
}</code></pre>
    <pre class="cjs"><code>const cluster = require(&#39;cluster&#39;);
const dgram = require(&#39;dgram&#39;);

if (cluster.isPrimary) {
  cluster.fork(); // Works ok.
  cluster.fork(); // Fails with EADDRINUSE.
} else {
  const s = dgram.createSocket(&#39;udp4&#39;);
  s.bind(1234, () =&gt; {
    s.addMembership(&#39;224.0.0.114&#39;);
  });
}</code></pre>
    <h3
      id="socket.addsourcespecificmembershipsourceaddress-groupaddress-multicastinterface"
    >
      <code
        >socket.addSourceSpecificMembership(sourceAddress, groupAddress[,
        multicastInterface])</code
      >
    </h3>
    <!-- YAML
added:
 - v13.1.0
 - v12.16.0
-->
    <ul>
      <li><code>sourceAddress</code> {string}</li>
      <li><code>groupAddress</code> {string}</li>
      <li><code>multicastInterface</code> {string}</li>
    </ul>
    <p>
      Tells the kernel to join a source-specific multicast channel at the given
      <code>sourceAddress</code> and <code>groupAddress</code>, using the
      <code>multicastInterface</code> with the
      <code>IP_ADD_SOURCE_MEMBERSHIP</code> socket option. If the
      <code>multicastInterface</code> argument is not specified, the operating
      system will choose one interface and will add membership to it. To add
      membership to every available interface, call
      <code>socket.addSourceSpecificMembership()</code> multiple times, once per
      interface.
    </p>
    <p>
      When called on an unbound socket, this method will implicitly bind to a
      random port, listening on all interfaces.
    </p>
    <h3 id="socket.address"><code>socket.address()</code></h3>
    <!-- YAML
added: v0.1.99
-->
    <ul>
      <li>Returns: {Object}</li>
    </ul>
    <p>
      Returns an object containing the address information for a socket. For UDP
      sockets, this object will contain <code>address</code>,
      <code>family</code> and <code>port</code> properties.
    </p>
    <p>This method throws <code>EBADF</code> if called on an unbound socket.</p>
    <h3 id="socket.bindport-address-callback">
      <code>socket.bind([port][, address][, callback])</code>
    </h3>
    <!-- YAML
added: v0.1.99
changes:
  - version: v0.9.1
    commit: 332fea5ac1816e498030109c4211bca24a7fa667
    description: The method was changed to an asynchronous execution model.
                 Legacy code would need to be changed to pass a callback
                 function to the method call.
-->
    <ul>
      <li><code>port</code> {integer}</li>
      <li><code>address</code> {string}</li>
      <li>
        <code>callback</code> {Function} with no parameters. Called when binding
        is complete.
      </li>
    </ul>
    <p>
      For UDP sockets, causes the <code>dgram.Socket</code> to listen for
      datagram messages on a named <code>port</code> and optional
      <code>address</code>. If <code>port</code> is not specified or is
      <code>0</code>, the operating system will attempt to bind to a random
      port. If <code>address</code> is not specified, the operating system will
      attempt to listen on all addresses. Once binding is complete, a
      <code>'listening'</code> event is emitted and the optional
      <code>callback</code> function is called.
    </p>
    <p>
      Specifying both a <code>'listening'</code> event listener and passing a
      <code>callback</code> to the <code>socket.bind()</code> method is not
      harmful but not very useful.
    </p>
    <p>
      A bound datagram socket keeps the Node.js process running to receive
      datagram messages.
    </p>
    <p>
      If binding fails, an <code>'error'</code> event is generated. In rare case
      (e.g. attempting to bind with a closed socket), an
      <a href="errors.md#errors_class_error"><code>Error</code></a> may be
      thrown.
    </p>
    <p>Example of a UDP server listening on port 41234:</p>
    <pre class="mjs"><code>import dgram from &#39;dgram&#39;;

const server = dgram.createSocket(&#39;udp4&#39;);

server.on(&#39;error&#39;, (err) =&gt; {
  console.log(`server error:\n${err.stack}`);
  server.close();
});

server.on(&#39;message&#39;, (msg, rinfo) =&gt; {
  console.log(`server got: ${msg} from ${rinfo.address}:${rinfo.port}`);
});

server.on(&#39;listening&#39;, () =&gt; {
  const address = server.address();
  console.log(`server listening ${address.address}:${address.port}`);
});

server.bind(41234);
// Prints: server listening 0.0.0.0:41234</code></pre>
    <pre class="cjs"><code>const dgram = require(&#39;dgram&#39;);
const server = dgram.createSocket(&#39;udp4&#39;);

server.on(&#39;error&#39;, (err) =&gt; {
  console.log(`server error:\n${err.stack}`);
  server.close();
});

server.on(&#39;message&#39;, (msg, rinfo) =&gt; {
  console.log(`server got: ${msg} from ${rinfo.address}:${rinfo.port}`);
});

server.on(&#39;listening&#39;, () =&gt; {
  const address = server.address();
  console.log(`server listening ${address.address}:${address.port}`);
});

server.bind(41234);
// Prints: server listening 0.0.0.0:41234</code></pre>
    <h3 id="socket.bindoptions-callback">
      <code>socket.bind(options[, callback])</code>
    </h3>
    <!-- YAML
added: v0.11.14
-->
    <ul>
      <li>
        <code>options</code> {Object} Required. Supports the following
        properties:
        <ul>
          <li><code>port</code> {integer}</li>
          <li><code>address</code> {string}</li>
          <li><code>exclusive</code> {boolean}</li>
          <li><code>fd</code> {integer}</li>
        </ul>
      </li>
      <li><code>callback</code> {Function}</li>
    </ul>
    <p>
      For UDP sockets, causes the <code>dgram.Socket</code> to listen for
      datagram messages on a named <code>port</code> and optional
      <code>address</code> that are passed as properties of an
      <code>options</code> object passed as the first argument. If
      <code>port</code> is not specified or is <code>0</code>, the operating
      system will attempt to bind to a random port. If <code>address</code> is
      not specified, the operating system will attempt to listen on all
      addresses. Once binding is complete, a <code>'listening'</code> event is
      emitted and the optional <code>callback</code> function is called.
    </p>
    <p>
      The <code>options</code> object may contain a <code>fd</code> property.
      When a <code>fd</code> greater than <code>0</code> is set, it will wrap
      around an existing socket with the given file descriptor. In this case,
      the properties of <code>port</code> and <code>address</code> will be
      ignored.
    </p>
    <p>
      Specifying both a <code>'listening'</code> event listener and passing a
      <code>callback</code> to the <code>socket.bind()</code> method is not
      harmful but not very useful.
    </p>
    <p>
      The <code>options</code> object may contain an additional
      <code>exclusive</code> property that is used when using
      <code>dgram.Socket</code> objects with the
      <a href="cluster.md"><code>cluster</code></a> module. When
      <code>exclusive</code> is set to <code>false</code> (the default), cluster
      workers will use the same underlying socket handle allowing connection
      handling duties to be shared. When <code>exclusive</code> is
      <code>true</code>, however, the handle is not shared and attempted port
      sharing results in an error.
    </p>
    <p>
      A bound datagram socket keeps the Node.js process running to receive
      datagram messages.
    </p>
    <p>
      If binding fails, an <code>'error'</code> event is generated. In rare case
      (e.g. attempting to bind with a closed socket), an
      <a href="errors.md#errors_class_error"><code>Error</code></a> may be
      thrown.
    </p>
    <p>An example socket listening on an exclusive port is shown below.</p>
    <div class="sourceCode" id="cb7">
      <pre
        class="sourceCode js"
      ><code class="sourceCode javascript"><a class="sourceLine" id="cb7-1" title="1"><span class="va">socket</span>.<span class="at">bind</span>(<span class="op">{</span></a>
<a class="sourceLine" id="cb7-2" title="2">  <span class="dt">address</span><span class="op">:</span> <span class="st">&#39;localhost&#39;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb7-3" title="3">  <span class="dt">port</span><span class="op">:</span> <span class="dv">8000</span><span class="op">,</span></a>
<a class="sourceLine" id="cb7-4" title="4">  <span class="dt">exclusive</span><span class="op">:</span> <span class="kw">true</span></a>
<a class="sourceLine" id="cb7-5" title="5"><span class="op">}</span>)<span class="op">;</span></a></code></pre>
    </div>
    <h3 id="socket.closecallback"><code>socket.close([callback])</code></h3>
    <!-- YAML
added: v0.1.99
-->
    <ul>
      <li>
        <code>callback</code> {Function} Called when the socket has been closed.
      </li>
    </ul>
    <p>
      Close the underlying socket and stop listening for data on it. If a
      callback is provided, it is added as a listener for the
      <a href="#dgram_event_close"><code>'close'</code></a> event.
    </p>
    <h3 id="socket.connectport-address-callback">
      <code>socket.connect(port[, address][, callback])</code>
    </h3>
    <!-- YAML
added: v12.0.0
-->
    <ul>
      <li><code>port</code> {integer}</li>
      <li><code>address</code> {string}</li>
      <li>
        <code>callback</code> {Function} Called when the connection is completed
        or on error.
      </li>
    </ul>
    <p>
      Associates the <code>dgram.Socket</code> to a remote address and port.
      Every message sent by this handle is automatically sent to that
      destination. Also, the socket will only receive messages from that remote
      peer. Trying to call <code>connect()</code> on an already connected socket
      will result in an
      <a href="errors.md#errors_err_socket_dgram_is_connected"
        ><code>ERR_SOCKET_DGRAM_IS_CONNECTED</code></a
      >
      exception. If <code>address</code> is not provided,
      <code>'127.0.0.1'</code> (for <code>udp4</code> sockets) or
      <code>'::1'</code> (for <code>udp6</code> sockets) will be used by
      default. Once the connection is complete, a <code>'connect'</code> event
      is emitted and the optional <code>callback</code> function is called. In
      case of failure, the <code>callback</code> is called or, failing this, an
      <code>'error'</code> event is emitted.
    </p>
    <h3 id="socket.disconnect"><code>socket.disconnect()</code></h3>
    <!-- YAML
added: v12.0.0
-->
    <p>
      A synchronous function that disassociates a connected
      <code>dgram.Socket</code> from its remote address. Trying to call
      <code>disconnect()</code> on an unbound or already disconnected socket
      will result in an
      <a href="errors.md#errors_err_socket_dgram_not_connected"
        ><code>ERR_SOCKET_DGRAM_NOT_CONNECTED</code></a
      >
      exception.
    </p>
    <h3 id="socket.dropmembershipmulticastaddress-multicastinterface">
      <code>socket.dropMembership(multicastAddress[, multicastInterface])</code>
    </h3>
    <!-- YAML
added: v0.6.9
-->
    <ul>
      <li><code>multicastAddress</code> {string}</li>
      <li><code>multicastInterface</code> {string}</li>
    </ul>
    <p>
      Instructs the kernel to leave a multicast group at
      <code>multicastAddress</code> using the
      <code>IP_DROP_MEMBERSHIP</code> socket option. This method is
      automatically called by the kernel when the socket is closed or the
      process terminates, so most apps will never have reason to call this.
    </p>
    <p>
      If <code>multicastInterface</code> is not specified, the operating system
      will attempt to drop membership on all valid interfaces.
    </p>
    <h3
      id="socket.dropsourcespecificmembershipsourceaddress-groupaddress-multicastinterface"
    >
      <code
        >socket.dropSourceSpecificMembership(sourceAddress, groupAddress[,
        multicastInterface])</code
      >
    </h3>
    <!-- YAML
added:
 - v13.1.0
 - v12.16.0
-->
    <ul>
      <li><code>sourceAddress</code> {string}</li>
      <li><code>groupAddress</code> {string}</li>
      <li><code>multicastInterface</code> {string}</li>
    </ul>
    <p>
      Instructs the kernel to leave a source-specific multicast channel at the
      given <code>sourceAddress</code> and <code>groupAddress</code> using the
      <code>IP_DROP_SOURCE_MEMBERSHIP</code> socket option. This method is
      automatically called by the kernel when the socket is closed or the
      process terminates, so most apps will never have reason to call this.
    </p>
    <p>
      If <code>multicastInterface</code> is not specified, the operating system
      will attempt to drop membership on all valid interfaces.
    </p>
    <h3 id="socket.getrecvbuffersize">
      <code>socket.getRecvBufferSize()</code>
    </h3>
    <!-- YAML
added: v8.7.0
-->
    <ul>
      <li>
        Returns: {number} the <code>SO_RCVBUF</code> socket receive buffer size
        in bytes.
      </li>
    </ul>
    <p>
      This method throws
      <a href="errors.md#errors_err_socket_buffer_size"
        ><code>ERR_SOCKET_BUFFER_SIZE</code></a
      >
      if called on an unbound socket.
    </p>
    <h3 id="socket.getsendbuffersize">
      <code>socket.getSendBufferSize()</code>
    </h3>
    <!-- YAML
added: v8.7.0
-->
    <ul>
      <li>
        Returns: {number} the <code>SO_SNDBUF</code> socket send buffer size in
        bytes.
      </li>
    </ul>
    <p>
      This method throws
      <a href="errors.md#errors_err_socket_buffer_size"
        ><code>ERR_SOCKET_BUFFER_SIZE</code></a
      >
      if called on an unbound socket.
    </p>
    <h3 id="socket.ref"><code>socket.ref()</code></h3>
    <!-- YAML
added: v0.9.1
-->
    <ul>
      <li>Returns: {dgram.Socket}</li>
    </ul>
    <p>
      By default, binding a socket will cause it to block the Node.js process
      from exiting as long as the socket is open. The
      <code>socket.unref()</code> method can be used to exclude the socket from
      the reference counting that keeps the Node.js process active. The
      <code>socket.ref()</code> method adds the socket back to the reference
      counting and restores the default behavior.
    </p>
    <p>
      Calling <code>socket.ref()</code> multiples times will have no additional
      effect.
    </p>
    <p>
      The <code>socket.ref()</code> method returns a reference to the socket so
      calls can be chained.
    </p>
    <h3 id="socket.remoteaddress"><code>socket.remoteAddress()</code></h3>
    <!-- YAML
added: v12.0.0
-->
    <ul>
      <li>Returns: {Object}</li>
    </ul>
    <p>
      Returns an object containing the <code>address</code>,
      <code>family</code>, and <code>port</code> of the remote endpoint. This
      method throws an
      <a href="errors.md#errors_err_socket_dgram_not_connected"
        ><code>ERR_SOCKET_DGRAM_NOT_CONNECTED</code></a
      >
      exception if the socket is not connected.
    </p>
    <h3 id="socket.sendmsg-offset-length-port-address-callback">
      <code
        >socket.send(msg[, offset, length][, port][, address][, callback])</code
      >
    </h3>
    <!-- YAML
added: v0.1.99
changes:
  - version:
    - v14.5.0
    - v12.19.0
    pr-url: https://github.com/nodejs/node/pull/22413
    description: The `msg` parameter can now be any `TypedArray` or `DataView`.
  - version: v12.0.0
    pr-url: https://github.com/nodejs/node/pull/26871
    description: Added support for sending data on connected sockets.
  - version: v8.0.0
    pr-url: https://github.com/nodejs/node/pull/11985
    description: The `msg` parameter can be an `Uint8Array` now.
  - version: v8.0.0
    pr-url: https://github.com/nodejs/node/pull/10473
    description: The `address` parameter is always optional now.
  - version: v6.0.0
    pr-url: https://github.com/nodejs/node/pull/5929
    description: On success, `callback` will now be called with an `error`
                 argument of `null` rather than `0`.
  - version: v5.7.0
    pr-url: https://github.com/nodejs/node/pull/4374
    description: The `msg` parameter can be an array now. Also, the `offset`
                 and `length` parameters are optional now.
-->
    <ul>
      <li>
        <code>msg</code> {Buffer|TypedArray|DataView|string|Array} Message to be
        sent.
      </li>
      <li>
        <code>offset</code> {integer} Offset in the buffer where the message
        starts.
      </li>
      <li><code>length</code> {integer} Number of bytes in the message.</li>
      <li><code>port</code> {integer} Destination port.</li>
      <li>
        <code>address</code> {string} Destination host name or IP address.
      </li>
      <li>
        <code>callback</code> {Function} Called when the message has been sent.
      </li>
    </ul>
    <p>
      Broadcasts a datagram on the socket. For connectionless sockets, the
      destination <code>port</code> and <code>address</code> must be specified.
      Connected sockets, on the other hand, will use their associated remote
      endpoint, so the <code>port</code> and <code>address</code> arguments must
      not be set.
    </p>
    <p>
      The <code>msg</code> argument contains the message to be sent. Depending
      on its type, different behavior can apply. If <code>msg</code> is a
      <code>Buffer</code>, any <code>TypedArray</code> or a
      <code>DataView</code>, the <code>offset</code> and
      <code>length</code> specify the offset within the
      <code>Buffer</code> where the message begins and the number of bytes in
      the message, respectively. If <code>msg</code> is a <code>String</code>,
      then it is automatically converted to a <code>Buffer</code> with
      <code>'utf8'</code> encoding. With messages that contain multi-byte
      characters, <code>offset</code> and <code>length</code> will be calculated
      with respect to
      <a href="buffer.md#buffer_static_method_buffer_bytelength_string_encoding"
        >byte length</a
      >
      and not the character position. If <code>msg</code> is an array,
      <code>offset</code> and <code>length</code> must not be specified.
    </p>
    <p>
      The <code>address</code> argument is a string. If the value of
      <code>address</code> is a host name, DNS will be used to resolve the
      address of the host. If <code>address</code> is not provided or otherwise
      falsy, <code>'127.0.0.1'</code> (for <code>udp4</code> sockets) or
      <code>'::1'</code> (for <code>udp6</code> sockets) will be used by
      default.
    </p>
    <p>
      If the socket has not been previously bound with a call to
      <code>bind</code>, the socket is assigned a random port number and is
      bound to the “all interfaces” address (<code>'0.0.0.0'</code> for
      <code>udp4</code> sockets, <code>'::0'</code> for
      <code>udp6</code> sockets.)
    </p>
    <p>
      An optional <code>callback</code> function may be specified to as a way of
      reporting DNS errors or for determining when it is safe to reuse the
      <code>buf</code> object. DNS lookups delay the time to send for at least
      one tick of the Node.js event loop.
    </p>
    <p>
      The only way to know for sure that the datagram has been sent is by using
      a <code>callback</code>. If an error occurs and a <code>callback</code> is
      given, the error will be passed as the first argument to the
      <code>callback</code>. If a <code>callback</code> is not given, the error
      is emitted as an <code>'error'</code> event on the
      <code>socket</code> object.
    </p>
    <p>
      Offset and length are optional but both <em>must</em> be set if either are
      used. They are supported only when the first argument is a
      <code>Buffer</code>, a <code>TypedArray</code>, or a
      <code>DataView</code>.
    </p>
    <p>
      This method throws
      <a href="errors.md#errors_err_socket_bad_port"
        ><code>ERR_SOCKET_BAD_PORT</code></a
      >
      if called on an unbound socket.
    </p>
    <p>Example of sending a UDP packet to a port on <code>localhost</code>;</p>
    <pre class="mjs"><code>import dgram from &#39;dgram&#39;;
import { Buffer } from &#39;buffer&#39;;

const message = Buffer.from(&#39;Some bytes&#39;);
const client = dgram.createSocket(&#39;udp4&#39;);
client.send(message, 41234, &#39;localhost&#39;, (err) =&gt; {
  client.close();
});</code></pre>
    <pre class="cjs"><code>const dgram = require(&#39;dgram&#39;);
const { Buffer } = require(&#39;buffer&#39;);

const message = Buffer.from(&#39;Some bytes&#39;);
const client = dgram.createSocket(&#39;udp4&#39;);
client.send(message, 41234, &#39;localhost&#39;, (err) =&gt; {
  client.close();
});</code></pre>
    <p>
      Example of sending a UDP packet composed of multiple buffers to a port on
      <code>127.0.0.1</code>;
    </p>
    <pre class="mjs"><code>import dgram from &#39;dgram&#39;;
import { Buffer } from &#39;buffer&#39;;

const buf1 = Buffer.from(&#39;Some &#39;);
const buf2 = Buffer.from(&#39;bytes&#39;);
const client = dgram.createSocket(&#39;udp4&#39;);
client.send([buf1, buf2], 41234, (err) =&gt; {
  client.close();
});</code></pre>
    <pre class="cjs"><code>const dgram = require(&#39;dgram&#39;);
const { Buffer } = require(&#39;buffer&#39;);

const buf1 = Buffer.from(&#39;Some &#39;);
const buf2 = Buffer.from(&#39;bytes&#39;);
const client = dgram.createSocket(&#39;udp4&#39;);
client.send([buf1, buf2], 41234, (err) =&gt; {
  client.close();
});</code></pre>
    <p>
      Sending multiple buffers might be faster or slower depending on the
      application and operating system. Run benchmarks to determine the optimal
      strategy on a case-by-case basis. Generally speaking, however, sending
      multiple buffers is faster.
    </p>
    <p>
      Example of sending a UDP packet using a socket connected to a port on
      <code>localhost</code>:
    </p>
    <pre class="mjs"><code>import dgram from &#39;dgram&#39;;
import { Buffer } from &#39;buffer&#39;;

const message = Buffer.from(&#39;Some bytes&#39;);
const client = dgram.createSocket(&#39;udp4&#39;);
client.connect(41234, &#39;localhost&#39;, (err) =&gt; {
  client.send(message, (err) =&gt; {
    client.close();
  });
});</code></pre>
    <pre class="cjs"><code>const dgram = require(&#39;dgram&#39;);
const { Buffer } = require(&#39;buffer&#39;);

const message = Buffer.from(&#39;Some bytes&#39;);
const client = dgram.createSocket(&#39;udp4&#39;);
client.connect(41234, &#39;localhost&#39;, (err) =&gt; {
  client.send(message, (err) =&gt; {
    client.close();
  });
});</code></pre>
    <h4 id="note-about-udp-datagram-size">Note about UDP datagram size</h4>
    <p>
      The maximum size of an IPv4/v6 datagram depends on the
      <code>MTU</code> (Maximum Transmission Unit) and on the
      <code>Payload Length</code> field size.
    </p>
    <ul>
      <li>
        <p>
          The <code>Payload Length</code> field is 16 bits wide, which means
          that a normal payload cannot exceed 64K octets including the internet
          header and data (65,507 bytes = 65,535 − 8 bytes UDP header − 20 bytes
          IP header); this is generally true for loopback interfaces, but such
          long datagram messages are impractical for most hosts and networks.
        </p>
      </li>
      <li>
        <p>
          The <code>MTU</code> is the largest size a given link layer technology
          can support for datagram messages. For any link, IPv4 mandates a
          minimum <code>MTU</code> of 68 octets, while the recommended
          <code>MTU</code> for IPv4 is 576 (typically recommended as the
          <code>MTU</code> for dial-up type applications), whether they arrive
          whole or in fragments.
        </p>
        <p>
          For IPv6, the minimum <code>MTU</code> is 1280 octets. However, the
          mandatory minimum fragment reassembly buffer size is 1500 octets. The
          value of 68 octets is very small, since most current link layer
          technologies, like Ethernet, have a minimum <code>MTU</code> of 1500.
        </p>
      </li>
    </ul>
    <p>
      It is impossible to know in advance the MTU of each link through which a
      packet might travel. Sending a datagram greater than the receiver
      <code>MTU</code> will not work because the packet will get silently
      dropped without informing the source that the data did not reach its
      intended recipient.
    </p>
    <h3 id="socket.setbroadcastflag"><code>socket.setBroadcast(flag)</code></h3>
    <!-- YAML
added: v0.6.9
-->
    <ul>
      <li><code>flag</code> {boolean}</li>
    </ul>
    <p>
      Sets or clears the <code>SO_BROADCAST</code> socket option. When set to
      <code>true</code>, UDP packets may be sent to a local interface’s
      broadcast address.
    </p>
    <p>This method throws <code>EBADF</code> if called on an unbound socket.</p>
    <h3 id="socket.setmulticastinterfacemulticastinterface">
      <code>socket.setMulticastInterface(multicastInterface)</code>
    </h3>
    <!-- YAML
added: v8.6.0
-->
    <ul>
      <li><code>multicastInterface</code> {string}</li>
    </ul>
    <p>
      <em
        >All references to scope in this section are referring to
        <a
          href="https://en.wikipedia.org/wiki/IPv6_address#Scoped_literal_IPv6_addresses"
          >IPv6 Zone Indices</a
        >, which are defined by
        <a href="https://tools.ietf.org/html/rfc4007">RFC 4007</a>. In string
        form, an IP with a scope index is written as
        <code>'IP%scope'</code> where scope is an interface name or interface
        number.</em
      >
    </p>
    <p>
      Sets the default outgoing multicast interface of the socket to a chosen
      interface or back to system interface selection. The
      <code>multicastInterface</code> must be a valid string representation of
      an IP from the socket’s family.
    </p>
    <p>
      For IPv4 sockets, this should be the IP configured for the desired
      physical interface. All packets sent to multicast on the socket will be
      sent on the interface determined by the most recent successful use of this
      call.
    </p>
    <p>
      For IPv6 sockets, <code>multicastInterface</code> should include a scope
      to indicate the interface as in the examples that follow. In IPv6,
      individual <code>send</code> calls can also use explicit scope in
      addresses, so only packets sent to a multicast address without specifying
      an explicit scope are affected by the most recent successful use of this
      call.
    </p>
    <p>This method throws <code>EBADF</code> if called on an unbound socket.</p>
    <h4 id="example-ipv6-outgoing-multicast-interface">
      Example: IPv6 outgoing multicast interface
    </h4>
    <p>On most systems, where scope format uses the interface name:</p>
    <div class="sourceCode" id="cb14">
      <pre
        class="sourceCode js"
      ><code class="sourceCode javascript"><a class="sourceLine" id="cb14-1" title="1"><span class="kw">const</span> socket <span class="op">=</span> <span class="va">dgram</span>.<span class="at">createSocket</span>(<span class="st">&#39;udp6&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb14-2" title="2"></a>
<a class="sourceLine" id="cb14-3" title="3"><span class="va">socket</span>.<span class="at">bind</span>(<span class="dv">1234</span><span class="op">,</span> () <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb14-4" title="4">  <span class="va">socket</span>.<span class="at">setMulticastInterface</span>(<span class="st">&#39;::%eth1&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb14-5" title="5"><span class="op">}</span>)<span class="op">;</span></a></code></pre>
    </div>
    <p>On Windows, where scope format uses an interface number:</p>
    <div class="sourceCode" id="cb15">
      <pre
        class="sourceCode js"
      ><code class="sourceCode javascript"><a class="sourceLine" id="cb15-1" title="1"><span class="kw">const</span> socket <span class="op">=</span> <span class="va">dgram</span>.<span class="at">createSocket</span>(<span class="st">&#39;udp6&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb15-2" title="2"></a>
<a class="sourceLine" id="cb15-3" title="3"><span class="va">socket</span>.<span class="at">bind</span>(<span class="dv">1234</span><span class="op">,</span> () <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb15-4" title="4">  <span class="va">socket</span>.<span class="at">setMulticastInterface</span>(<span class="st">&#39;::%2&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb15-5" title="5"><span class="op">}</span>)<span class="op">;</span></a></code></pre>
    </div>
    <h4 id="example-ipv4-outgoing-multicast-interface">
      Example: IPv4 outgoing multicast interface
    </h4>
    <p>All systems use an IP of the host on the desired physical interface:</p>
    <div class="sourceCode" id="cb16">
      <pre
        class="sourceCode js"
      ><code class="sourceCode javascript"><a class="sourceLine" id="cb16-1" title="1"><span class="kw">const</span> socket <span class="op">=</span> <span class="va">dgram</span>.<span class="at">createSocket</span>(<span class="st">&#39;udp4&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb16-2" title="2"></a>
<a class="sourceLine" id="cb16-3" title="3"><span class="va">socket</span>.<span class="at">bind</span>(<span class="dv">1234</span><span class="op">,</span> () <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb16-4" title="4">  <span class="va">socket</span>.<span class="at">setMulticastInterface</span>(<span class="st">&#39;10.0.0.2&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb16-5" title="5"><span class="op">}</span>)<span class="op">;</span></a></code></pre>
    </div>
    <h4 id="call-results">Call results</h4>
    <p>
      A call on a socket that is not ready to send or no longer open may throw a
      <em>Not running</em>
      <a href="errors.md#errors_class_error"><code>Error</code></a
      >.
    </p>
    <p>
      If <code>multicastInterface</code> can not be parsed into an IP then an
      <em>EINVAL</em>
      <a href="errors.md#errors_class_systemerror"><code>System Error</code></a>
      is thrown.
    </p>
    <p>
      On IPv4, if <code>multicastInterface</code> is a valid address but does
      not match any interface, or if the address does not match the family then
      a
      <a href="errors.md#errors_class_systemerror"><code>System Error</code></a>
      such as <code>EADDRNOTAVAIL</code> or <code>EPROTONOSUP</code> is thrown.
    </p>
    <p>
      On IPv6, most errors with specifying or omitting scope will result in the
      socket continuing to use (or returning to) the system’s default interface
      selection.
    </p>
    <p>
      A socket’s address family’s ANY address (IPv4 <code>'0.0.0.0'</code> or
      IPv6 <code>'::'</code>) can be used to return control of the sockets
      default outgoing interface to the system for future multicast packets.
    </p>
    <h3 id="socket.setmulticastloopbackflag">
      <code>socket.setMulticastLoopback(flag)</code>
    </h3>
    <!-- YAML
added: v0.3.8
-->
    <ul>
      <li><code>flag</code> {boolean}</li>
    </ul>
    <p>
      Sets or clears the <code>IP_MULTICAST_LOOP</code> socket option. When set
      to <code>true</code>, multicast packets will also be received on the local
      interface.
    </p>
    <p>This method throws <code>EBADF</code> if called on an unbound socket.</p>
    <h3 id="socket.setmulticastttlttl">
      <code>socket.setMulticastTTL(ttl)</code>
    </h3>
    <!-- YAML
added: v0.3.8
-->
    <ul>
      <li><code>ttl</code> {integer}</li>
    </ul>
    <p>
      Sets the <code>IP_MULTICAST_TTL</code> socket option. While TTL generally
      stands for “Time to Live”, in this context it specifies the number of IP
      hops that a packet is allowed to travel through, specifically for
      multicast traffic. Each router or gateway that forwards a packet
      decrements the TTL. If the TTL is decremented to 0 by a router, it will
      not be forwarded.
    </p>
    <p>
      The <code>ttl</code> argument may be between 0 and 255. The default on
      most systems is <code>1</code>.
    </p>
    <p>This method throws <code>EBADF</code> if called on an unbound socket.</p>
    <h3 id="socket.setrecvbuffersizesize">
      <code>socket.setRecvBufferSize(size)</code>
    </h3>
    <!-- YAML
added: v8.7.0
-->
    <ul>
      <li><code>size</code> {integer}</li>
    </ul>
    <p>
      Sets the <code>SO_RCVBUF</code> socket option. Sets the maximum socket
      receive buffer in bytes.
    </p>
    <p>
      This method throws
      <a href="errors.md#errors_err_socket_buffer_size"
        ><code>ERR_SOCKET_BUFFER_SIZE</code></a
      >
      if called on an unbound socket.
    </p>
    <h3 id="socket.setsendbuffersizesize">
      <code>socket.setSendBufferSize(size)</code>
    </h3>
    <!-- YAML
added: v8.7.0
-->
    <ul>
      <li><code>size</code> {integer}</li>
    </ul>
    <p>
      Sets the <code>SO_SNDBUF</code> socket option. Sets the maximum socket
      send buffer in bytes.
    </p>
    <p>
      This method throws
      <a href="errors.md#errors_err_socket_buffer_size"
        ><code>ERR_SOCKET_BUFFER_SIZE</code></a
      >
      if called on an unbound socket.
    </p>
    <h3 id="socket.setttlttl"><code>socket.setTTL(ttl)</code></h3>
    <!-- YAML
added: v0.1.101
-->
    <ul>
      <li><code>ttl</code> {integer}</li>
    </ul>
    <p>
      Sets the <code>IP_TTL</code> socket option. While TTL generally stands for
      “Time to Live”, in this context it specifies the number of IP hops that a
      packet is allowed to travel through. Each router or gateway that forwards
      a packet decrements the TTL. If the TTL is decremented to 0 by a router,
      it will not be forwarded. Changing TTL values is typically done for
      network probes or when multicasting.
    </p>
    <p>
      The <code>ttl</code> argument may be between between 1 and 255. The
      default on most systems is 64.
    </p>
    <p>This method throws <code>EBADF</code> if called on an unbound socket.</p>
    <h3 id="socket.unref"><code>socket.unref()</code></h3>
    <!-- YAML
added: v0.9.1
-->
    <ul>
      <li>Returns: {dgram.Socket}</li>
    </ul>
    <p>
      By default, binding a socket will cause it to block the Node.js process
      from exiting as long as the socket is open. The
      <code>socket.unref()</code> method can be used to exclude the socket from
      the reference counting that keeps the Node.js process active, allowing the
      process to exit even if the socket is still listening.
    </p>
    <p>
      Calling <code>socket.unref()</code> multiple times will have no addition
      effect.
    </p>
    <p>
      The <code>socket.unref()</code> method returns a reference to the socket
      so calls can be chained.
    </p>
    <h2 id="dgram-module-functions"><code>dgram</code> module functions</h2>
    <h3 id="dgram.createsocketoptions-callback">
      <code>dgram.createSocket(options[, callback])</code>
    </h3>
    <!-- YAML
added: v0.11.13
changes:
  - version: v15.8.0
    pr-url: https://github.com/nodejs/node/pull/37026
    description: AbortSignal support was added.
  - version: v11.4.0
    pr-url: https://github.com/nodejs/node/pull/23798
    description: The `ipv6Only` option is supported.
  - version: v8.7.0
    pr-url: https://github.com/nodejs/node/pull/13623
    description: The `recvBufferSize` and `sendBufferSize` options are
                 supported now.
  - version: v8.6.0
    pr-url: https://github.com/nodejs/node/pull/14560
    description: The `lookup` option is supported.
-->
    <ul>
      <li>
        <code>options</code> {Object} Available options are:
        <ul>
          <li>
            <code>type</code> {string} The family of socket. Must be either
            <code>'udp4'</code> or <code>'udp6'</code>. Required.
          </li>
          <li>
            <code>reuseAddr</code> {boolean} When <code>true</code>
            <a href="#dgram_socket_bind_port_address_callback"
              ><code>socket.bind()</code></a
            >
            will reuse the address, even if another process has already bound a
            socket on it. <strong>Default:</strong> <code>false</code>.
          </li>
          <li>
            <code>ipv6Only</code> {boolean} Setting <code>ipv6Only</code> to
            <code>true</code> will disable dual-stack support, i.e., binding to
            address <code>::</code> won’t make <code>0.0.0.0</code> be bound.
            <strong>Default:</strong> <code>false</code>.
          </li>
          <li>
            <code>recvBufferSize</code> {number} Sets the
            <code>SO_RCVBUF</code> socket value.
          </li>
          <li>
            <code>sendBufferSize</code> {number} Sets the
            <code>SO_SNDBUF</code> socket value.
          </li>
          <li>
            <code>lookup</code> {Function} Custom lookup function.
            <strong>Default:</strong>
            <a href="dns.md#dns_dns_lookup_hostname_options_callback"
              ><code>dns.lookup()</code></a
            >.
          </li>
          <li>
            <code>signal</code> {AbortSignal} An AbortSignal that may be used to
            close a socket.
          </li>
        </ul>
      </li>
      <li>
        <code>callback</code> {Function} Attached as a listener for
        <code>'message'</code> events. Optional.
      </li>
      <li>Returns: {dgram.Socket}</li>
    </ul>
    <p>
      Creates a <code>dgram.Socket</code> object. Once the socket is created,
      calling
      <a href="#dgram_socket_bind_port_address_callback"
        ><code>socket.bind()</code></a
      >
      will instruct the socket to begin listening for datagram messages. When
      <code>address</code> and <code>port</code> are not passed to
      <a href="#dgram_socket_bind_port_address_callback"
        ><code>socket.bind()</code></a
      >
      the method will bind the socket to the “all interfaces” address on a
      random port (it does the right thing for both <code>udp4</code> and
      <code>udp6</code> sockets). The bound address and port can be retrieved
      using
      <a href="#dgram_socket_address"><code>socket.address().address</code></a>
      and <a href="#dgram_socket_address"><code>socket.address().port</code></a
      >.
    </p>
    <p>
      If the <code>signal</code> option is enabled, calling
      <code>.abort()</code> on the corresponding <code>AbortController</code> is
      similar to calling <code>.close()</code> on the socket:
    </p>
    <div class="sourceCode" id="cb17">
      <pre
        class="sourceCode js"
      ><code class="sourceCode javascript"><a class="sourceLine" id="cb17-1" title="1"><span class="kw">const</span> controller <span class="op">=</span> <span class="kw">new</span> <span class="at">AbortController</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb17-2" title="2"><span class="kw">const</span> <span class="op">{</span> signal <span class="op">}</span> <span class="op">=</span> controller<span class="op">;</span></a>
<a class="sourceLine" id="cb17-3" title="3"><span class="kw">const</span> server <span class="op">=</span> <span class="va">dgram</span>.<span class="at">createSocket</span>(<span class="op">{</span> <span class="dt">type</span><span class="op">:</span> <span class="st">&#39;udp4&#39;</span><span class="op">,</span> signal <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb17-4" title="4"><span class="va">server</span>.<span class="at">on</span>(<span class="st">&#39;message&#39;</span><span class="op">,</span> (msg<span class="op">,</span> rinfo) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb17-5" title="5">  <span class="va">console</span>.<span class="at">log</span>(<span class="vs">`server got: </span><span class="sc">${</span>msg<span class="sc">}</span><span class="vs"> from </span><span class="sc">${</span><span class="va">rinfo</span>.<span class="at">address</span><span class="sc">}</span><span class="vs">:</span><span class="sc">${</span><span class="va">rinfo</span>.<span class="at">port</span><span class="sc">}</span><span class="vs">`</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb17-6" title="6"><span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb17-7" title="7"><span class="co">// Later, when you want to close the server.</span></a>
<a class="sourceLine" id="cb17-8" title="8"><span class="va">controller</span>.<span class="at">abort</span>()<span class="op">;</span></a></code></pre>
    </div>
    <h3 id="dgram.createsockettype-callback">
      <code>dgram.createSocket(type[, callback])</code>
    </h3>
    <!-- YAML
added: v0.1.99
-->
    <ul>
      <li>
        <code>type</code> {string} Either <code>'udp4'</code> or
        <code>'udp6'</code>.
      </li>
      <li>
        <code>callback</code> {Function} Attached as a listener to
        <code>'message'</code> events.
      </li>
      <li>Returns: {dgram.Socket}</li>
    </ul>
    <p>
      Creates a <code>dgram.Socket</code> object of the specified
      <code>type</code>.
    </p>
    <p>
      Once the socket is created, calling
      <a href="#dgram_socket_bind_port_address_callback"
        ><code>socket.bind()</code></a
      >
      will instruct the socket to begin listening for datagram messages. When
      <code>address</code> and <code>port</code> are not passed to
      <a href="#dgram_socket_bind_port_address_callback"
        ><code>socket.bind()</code></a
      >
      the method will bind the socket to the “all interfaces” address on a
      random port (it does the right thing for both <code>udp4</code> and
      <code>udp6</code> sockets). The bound address and port can be retrieved
      using
      <a href="#dgram_socket_address"><code>socket.address().address</code></a>
      and <a href="#dgram_socket_address"><code>socket.address().port</code></a
      >.
    </p>
  </body>
</html>
