<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <meta charset="utf-8" />
    <meta name="generator" content="pandoc" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=yes"
    />
    <title>async_context</title>
    <style type="text/css">
      code {
        white-space: pre-wrap;
      }
      span.smallcaps {
        font-variant: small-caps;
      }
      span.underline {
        text-decoration: underline;
      }
      div.column {
        display: inline-block;
        vertical-align: top;
        width: 50%;
      }
    </style>
    <style type="text/css">
      a.sourceLine {
        display: inline-block;
        line-height: 1.25;
      }
      a.sourceLine {
        pointer-events: none;
        color: inherit;
        text-decoration: inherit;
      }
      a.sourceLine:empty {
        height: 1.2em;
      }
      .sourceCode {
        overflow: visible;
      }
      code.sourceCode {
        white-space: pre;
        position: relative;
      }
      div.sourceCode {
        margin: 1em 0;
      }
      pre.sourceCode {
        margin: 0;
      }
      @media screen {
        div.sourceCode {
          overflow: auto;
        }
      }
      @media print {
        code.sourceCode {
          white-space: pre-wrap;
        }
        a.sourceLine {
          text-indent: -1em;
          padding-left: 1em;
        }
      }
      pre.numberSource a.sourceLine {
        position: relative;
        left: -4em;
      }
      pre.numberSource a.sourceLine::before {
        content: attr(title);
        position: relative;
        left: -1em;
        text-align: right;
        vertical-align: baseline;
        border: none;
        pointer-events: all;
        display: inline-block;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        -khtml-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        padding: 0 4px;
        width: 4em;
        color: #aaaaaa;
      }
      pre.numberSource {
        margin-left: 3em;
        border-left: 1px solid #aaaaaa;
        padding-left: 4px;
      }
      div.sourceCode {
      }
      @media screen {
        a.sourceLine::before {
          text-decoration: underline;
        }
      }
      code span.al {
        color: #ff0000;
        font-weight: bold;
      } /* Alert */
      code span.an {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* Annotation */
      code span.at {
        color: #7d9029;
      } /* Attribute */
      code span.bn {
        color: #40a070;
      } /* BaseN */
      code span.bu {
      } /* BuiltIn */
      code span.cf {
        color: #007020;
        font-weight: bold;
      } /* ControlFlow */
      code span.ch {
        color: #4070a0;
      } /* Char */
      code span.cn {
        color: #880000;
      } /* Constant */
      code span.co {
        color: #60a0b0;
        font-style: italic;
      } /* Comment */
      code span.cv {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* CommentVar */
      code span.do {
        color: #ba2121;
        font-style: italic;
      } /* Documentation */
      code span.dt {
        color: #902000;
      } /* DataType */
      code span.dv {
        color: #40a070;
      } /* DecVal */
      code span.er {
        color: #ff0000;
        font-weight: bold;
      } /* Error */
      code span.ex {
      } /* Extension */
      code span.fl {
        color: #40a070;
      } /* Float */
      code span.fu {
        color: #06287e;
      } /* Function */
      code span.im {
      } /* Import */
      code span.in {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* Information */
      code span.kw {
        color: #007020;
        font-weight: bold;
      } /* Keyword */
      code span.op {
        color: #666666;
      } /* Operator */
      code span.ot {
        color: #007020;
      } /* Other */
      code span.pp {
        color: #bc7a00;
      } /* Preprocessor */
      code span.sc {
        color: #4070a0;
      } /* SpecialChar */
      code span.ss {
        color: #bb6688;
      } /* SpecialString */
      code span.st {
        color: #4070a0;
      } /* String */
      code span.va {
        color: #19177c;
      } /* Variable */
      code span.vs {
        color: #4070a0;
      } /* VerbatimString */
      code span.wa {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* Warning */
    </style>
  </head>
  <body>
    <h1 id="asynchronous-context-tracking">Asynchronous Context Tracking</h1>
    <blockquote>
      <p>Stability: 2 - Stable</p>
    </blockquote>
    <!-- source_link=lib/async_hooks.js -->
    <h2 id="introduction">Introduction</h2>
    <p>
      These classes are used to associate state and propagate it throughout
      callbacks and promise chains. They allow storing data throughout the
      lifetime of a web request or any other asynchronous duration. It is
      similar to thread-local storage in other languages.
    </p>
    <p>
      The <code>AsyncLocalStorage</code> and <code>AsyncResource</code> classes
      are part of the <code>async_hooks</code> module:
    </p>
    <pre
      class="mjs"
    ><code>import async_hooks from &#39;async_hooks&#39;;</code></pre>
    <pre
      class="cjs"
    ><code>const async_hooks = require(&#39;async_hooks&#39;);</code></pre>
    <h2 id="class-asynclocalstorage">Class: <code>AsyncLocalStorage</code></h2>
    <!-- YAML
added:
 - v13.10.0
 - v12.17.0
changes:
 - version: v16.4.0
   pr-url: https://github.com/nodejs/node/pull/37675
   description: AsyncLocalStorage is now Stable. Previously, it had been Experimental.
-->
    <p>
      This class creates stores that stay coherent through asynchronous
      operations.
    </p>
    <p>
      While you can create your own implementation on top of the
      <code>async_hooks</code> module, <code>AsyncLocalStorage</code> should be
      preferred as it is a performant and memory safe implementation that
      involves significant optimizations that are non-obvious to implement.
    </p>
    <p>
      The following example uses <code>AsyncLocalStorage</code> to build a
      simple logger that assigns IDs to incoming HTTP requests and includes them
      in messages logged within each request.
    </p>
    <pre class="mjs"><code>import http from &#39;http&#39;;
import { AsyncLocalStorage } from &#39;async_hooks&#39;;

const asyncLocalStorage = new AsyncLocalStorage();

function logWithId(msg) {
  const id = asyncLocalStorage.getStore();
  console.log(`${id !== undefined ? id : &#39;-&#39;}:`, msg);
}

let idSeq = 0;
http.createServer((req, res) =&gt; {
  asyncLocalStorage.run(idSeq++, () =&gt; {
    logWithId(&#39;start&#39;);
    // Imagine any chain of async operations here
    setImmediate(() =&gt; {
      logWithId(&#39;finish&#39;);
      res.end();
    });
  });
}).listen(8080);

http.get(&#39;http://localhost:8080&#39;);
http.get(&#39;http://localhost:8080&#39;);
// Prints:
//   0: start
//   1: start
//   0: finish
//   1: finish</code></pre>
    <pre class="cjs"><code>const http = require(&#39;http&#39;);
const { AsyncLocalStorage } = require(&#39;async_hooks&#39;);

const asyncLocalStorage = new AsyncLocalStorage();

function logWithId(msg) {
  const id = asyncLocalStorage.getStore();
  console.log(`${id !== undefined ? id : &#39;-&#39;}:`, msg);
}

let idSeq = 0;
http.createServer((req, res) =&gt; {
  asyncLocalStorage.run(idSeq++, () =&gt; {
    logWithId(&#39;start&#39;);
    // Imagine any chain of async operations here
    setImmediate(() =&gt; {
      logWithId(&#39;finish&#39;);
      res.end();
    });
  });
}).listen(8080);

http.get(&#39;http://localhost:8080&#39;);
http.get(&#39;http://localhost:8080&#39;);
// Prints:
//   0: start
//   1: start
//   0: finish
//   1: finish</code></pre>
    <p>
      Each instance of <code>AsyncLocalStorage</code> maintains an independent
      storage context. Multiple instances can safely exist simultaneously
      without risk of interfering with each other data.
    </p>
    <h3 id="new-asynclocalstorage"><code>new AsyncLocalStorage()</code></h3>
    <!-- YAML
added:
 - v13.10.0
 - v12.17.0
-->
    <p>
      Creates a new instance of <code>AsyncLocalStorage</code>. Store is only
      provided within a <code>run()</code> call or after an
      <code>enterWith()</code> call.
    </p>
    <h3 id="asynclocalstorage.disable">
      <code>asyncLocalStorage.disable()</code>
    </h3>
    <!-- YAML
added:
 - v13.10.0
 - v12.17.0
-->
    <blockquote>
      <p>Stability: 1 - Experimental</p>
    </blockquote>
    <p>
      Disables the instance of <code>AsyncLocalStorage</code>. All subsequent
      calls to <code>asyncLocalStorage.getStore()</code> will return
      <code>undefined</code> until <code>asyncLocalStorage.run()</code> or
      <code>asyncLocalStorage.enterWith()</code> is called again.
    </p>
    <p>
      When calling <code>asyncLocalStorage.disable()</code>, all current
      contexts linked to the instance will be exited.
    </p>
    <p>
      Calling <code>asyncLocalStorage.disable()</code> is required before the
      <code>asyncLocalStorage</code> can be garbage collected. This does not
      apply to stores provided by the <code>asyncLocalStorage</code>, as those
      objects are garbage collected along with the corresponding async
      resources.
    </p>
    <p>
      Use this method when the <code>asyncLocalStorage</code> is not in use
      anymore in the current process.
    </p>
    <h3 id="asynclocalstorage.getstore">
      <code>asyncLocalStorage.getStore()</code>
    </h3>
    <!-- YAML
added:
 - v13.10.0
 - v12.17.0
-->
    <ul>
      <li>Returns: {any}</li>
    </ul>
    <p>
      Returns the current store. If called outside of an asynchronous context
      initialized by calling <code>asyncLocalStorage.run()</code> or
      <code>asyncLocalStorage.enterWith()</code>, it returns
      <code>undefined</code>.
    </p>
    <h3 id="asynclocalstorage.enterwithstore">
      <code>asyncLocalStorage.enterWith(store)</code>
    </h3>
    <!-- YAML
added:
 - v13.11.0
 - v12.17.0
-->
    <blockquote>
      <p>Stability: 1 - Experimental</p>
    </blockquote>
    <ul>
      <li><code>store</code> {any}</li>
    </ul>
    <p>
      Transitions into the context for the remainder of the current synchronous
      execution and then persists the store through any following asynchronous
      calls.
    </p>
    <p>Example:</p>
    <div class="sourceCode" id="cb5">
      <pre
        class="sourceCode js"
      ><code class="sourceCode javascript"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">const</span> store <span class="op">=</span> <span class="op">{</span> <span class="dt">id</span><span class="op">:</span> <span class="dv">1</span> <span class="op">};</span></a>
<a class="sourceLine" id="cb5-2" title="2"><span class="co">// Replaces previous store with the given store object</span></a>
<a class="sourceLine" id="cb5-3" title="3"><span class="va">asyncLocalStorage</span>.<span class="at">enterWith</span>(store)<span class="op">;</span></a>
<a class="sourceLine" id="cb5-4" title="4"><span class="va">asyncLocalStorage</span>.<span class="at">getStore</span>()<span class="op">;</span> <span class="co">// Returns the store object</span></a>
<a class="sourceLine" id="cb5-5" title="5"><span class="at">someAsyncOperation</span>(() <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb5-6" title="6">  <span class="va">asyncLocalStorage</span>.<span class="at">getStore</span>()<span class="op">;</span> <span class="co">// Returns the same object</span></a>
<a class="sourceLine" id="cb5-7" title="7"><span class="op">}</span>)<span class="op">;</span></a></code></pre>
    </div>
    <p>
      This transition will continue for the <em>entire</em> synchronous
      execution. This means that if, for example, the context is entered within
      an event handler subsequent event handlers will also run within that
      context unless specifically bound to another context with an
      <code>AsyncResource</code>. That is why <code>run()</code> should be
      preferred over <code>enterWith()</code> unless there are strong reasons to
      use the latter method.
    </p>
    <div class="sourceCode" id="cb6">
      <pre
        class="sourceCode js"
      ><code class="sourceCode javascript"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">const</span> store <span class="op">=</span> <span class="op">{</span> <span class="dt">id</span><span class="op">:</span> <span class="dv">1</span> <span class="op">};</span></a>
<a class="sourceLine" id="cb6-2" title="2"></a>
<a class="sourceLine" id="cb6-3" title="3"><span class="va">emitter</span>.<span class="at">on</span>(<span class="st">&#39;my-event&#39;</span><span class="op">,</span> () <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb6-4" title="4">  <span class="va">asyncLocalStorage</span>.<span class="at">enterWith</span>(store)<span class="op">;</span></a>
<a class="sourceLine" id="cb6-5" title="5"><span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb6-6" title="6"><span class="va">emitter</span>.<span class="at">on</span>(<span class="st">&#39;my-event&#39;</span><span class="op">,</span> () <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb6-7" title="7">  <span class="va">asyncLocalStorage</span>.<span class="at">getStore</span>()<span class="op">;</span> <span class="co">// Returns the same object</span></a>
<a class="sourceLine" id="cb6-8" title="8"><span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb6-9" title="9"></a>
<a class="sourceLine" id="cb6-10" title="10"><span class="va">asyncLocalStorage</span>.<span class="at">getStore</span>()<span class="op">;</span> <span class="co">// Returns undefined</span></a>
<a class="sourceLine" id="cb6-11" title="11"><span class="va">emitter</span>.<span class="at">emit</span>(<span class="st">&#39;my-event&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb6-12" title="12"><span class="va">asyncLocalStorage</span>.<span class="at">getStore</span>()<span class="op">;</span> <span class="co">// Returns the same object</span></a></code></pre>
    </div>
    <h3 id="asynclocalstorage.runstore-callback-...args">
      <code>asyncLocalStorage.run(store, callback[, ...args])</code>
    </h3>
    <!-- YAML
added:
 - v13.10.0
 - v12.17.0
-->
    <ul>
      <li><code>store</code> {any}</li>
      <li><code>callback</code> {Function}</li>
      <li><code>...args</code> {any}</li>
    </ul>
    <p>
      Runs a function synchronously within a context and returns its return
      value. The store is not accessible outside of the callback function or the
      asynchronous operations created within the callback.
    </p>
    <p>The optional <code>args</code> are passed to the callback function.</p>
    <p>
      If the callback function throws an error, the error is thrown by
      <code>run()</code> too. The stacktrace is not impacted by this call and
      the context is exited.
    </p>
    <p>Example:</p>
    <div class="sourceCode" id="cb7">
      <pre
        class="sourceCode js"
      ><code class="sourceCode javascript"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">const</span> store <span class="op">=</span> <span class="op">{</span> <span class="dt">id</span><span class="op">:</span> <span class="dv">2</span> <span class="op">};</span></a>
<a class="sourceLine" id="cb7-2" title="2"><span class="cf">try</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb7-3" title="3">  <span class="va">asyncLocalStorage</span>.<span class="at">run</span>(store<span class="op">,</span> () <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb7-4" title="4">    <span class="va">asyncLocalStorage</span>.<span class="at">getStore</span>()<span class="op">;</span> <span class="co">// Returns the store object</span></a>
<a class="sourceLine" id="cb7-5" title="5">    <span class="cf">throw</span> <span class="kw">new</span> <span class="at">Error</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb7-6" title="6">  <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb7-7" title="7"><span class="op">}</span> <span class="cf">catch</span> (e) <span class="op">{</span></a>
<a class="sourceLine" id="cb7-8" title="8">  <span class="va">asyncLocalStorage</span>.<span class="at">getStore</span>()<span class="op">;</span> <span class="co">// Returns undefined</span></a>
<a class="sourceLine" id="cb7-9" title="9">  <span class="co">// The error will be caught here</span></a>
<a class="sourceLine" id="cb7-10" title="10"><span class="op">}</span></a></code></pre>
    </div>
    <h3 id="asynclocalstorage.exitcallback-...args">
      <code>asyncLocalStorage.exit(callback[, ...args])</code>
    </h3>
    <!-- YAML
added:
 - v13.10.0
 - v12.17.0
-->
    <blockquote>
      <p>Stability: 1 - Experimental</p>
    </blockquote>
    <ul>
      <li><code>callback</code> {Function}</li>
      <li><code>...args</code> {any}</li>
    </ul>
    <p>
      Runs a function synchronously outside of a context and returns its return
      value. The store is not accessible within the callback function or the
      asynchronous operations created within the callback. Any
      <code>getStore()</code> call done within the callback function will always
      return <code>undefined</code>.
    </p>
    <p>The optional <code>args</code> are passed to the callback function.</p>
    <p>
      If the callback function throws an error, the error is thrown by
      <code>exit()</code> too. The stacktrace is not impacted by this call and
      the context is re-entered.
    </p>
    <p>Example:</p>
    <div class="sourceCode" id="cb8">
      <pre
        class="sourceCode js"
      ><code class="sourceCode javascript"><a class="sourceLine" id="cb8-1" title="1"><span class="co">// Within a call to run</span></a>
<a class="sourceLine" id="cb8-2" title="2"><span class="cf">try</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb8-3" title="3">  <span class="va">asyncLocalStorage</span>.<span class="at">getStore</span>()<span class="op">;</span> <span class="co">// Returns the store object or value</span></a>
<a class="sourceLine" id="cb8-4" title="4">  <span class="va">asyncLocalStorage</span>.<span class="at">exit</span>(() <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb8-5" title="5">    <span class="va">asyncLocalStorage</span>.<span class="at">getStore</span>()<span class="op">;</span> <span class="co">// Returns undefined</span></a>
<a class="sourceLine" id="cb8-6" title="6">    <span class="cf">throw</span> <span class="kw">new</span> <span class="at">Error</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb8-7" title="7">  <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb8-8" title="8"><span class="op">}</span> <span class="cf">catch</span> (e) <span class="op">{</span></a>
<a class="sourceLine" id="cb8-9" title="9">  <span class="va">asyncLocalStorage</span>.<span class="at">getStore</span>()<span class="op">;</span> <span class="co">// Returns the same object or value</span></a>
<a class="sourceLine" id="cb8-10" title="10">  <span class="co">// The error will be caught here</span></a>
<a class="sourceLine" id="cb8-11" title="11"><span class="op">}</span></a></code></pre>
    </div>
    <h3 id="usage-with-asyncawait">Usage with <code>async/await</code></h3>
    <p>
      If, within an async function, only one <code>await</code> call is to run
      within a context, the following pattern should be used:
    </p>
    <div class="sourceCode" id="cb9">
      <pre
        class="sourceCode js"
      ><code class="sourceCode javascript"><a class="sourceLine" id="cb9-1" title="1"><span class="kw">async</span> <span class="kw">function</span> <span class="at">fn</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb9-2" title="2">  <span class="cf">await</span> <span class="va">asyncLocalStorage</span>.<span class="at">run</span>(<span class="kw">new</span> <span class="at">Map</span>()<span class="op">,</span> () <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb9-3" title="3">    <span class="va">asyncLocalStorage</span>.<span class="at">getStore</span>().<span class="at">set</span>(<span class="st">&#39;key&#39;</span><span class="op">,</span> value)<span class="op">;</span></a>
<a class="sourceLine" id="cb9-4" title="4">    <span class="cf">return</span> <span class="at">foo</span>()<span class="op">;</span> <span class="co">// The return value of foo will be awaited</span></a>
<a class="sourceLine" id="cb9-5" title="5">  <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb9-6" title="6"><span class="op">}</span></a></code></pre>
    </div>
    <p>
      In this example, the store is only available in the callback function and
      the functions called by <code>foo</code>. Outside of <code>run</code>,
      calling <code>getStore</code> will return <code>undefined</code>.
    </p>
    <h3 id="troubleshooting-context-loss">Troubleshooting: Context loss</h3>
    <p>
      In most cases your application or library code should have no issues with
      <code>AsyncLocalStorage</code>. But in rare cases you may face situations
      when the current store is lost in one of the asynchronous operations. In
      those cases, consider the following options.
    </p>
    <p>
      If your code is callback-based, it is enough to promisify it with
      <a href="util.md#util_util_promisify_original"
        ><code>util.promisify()</code></a
      >, so it starts working with native promises.
    </p>
    <p>
      If you need to keep using callback-based API, or your code assumes a
      custom thenable implementation, use the
      <a href="#async_context_class_asyncresource"
        ><code>AsyncResource</code></a
      >
      class to associate the asynchronous operation with the correct execution
      context. To do so, you will need to identify the function call responsible
      for the context loss. You can do that by logging the content of
      <code>asyncLocalStorage.getStore()</code> after the calls you suspect are
      responsible for the loss. When the code logs <code>undefined</code>, the
      last callback called is probably responsible for the context loss.
    </p>
    <h2 id="class-asyncresource">Class: <code>AsyncResource</code></h2>
    <!-- YAML
changes:
 - version: v16.4.0
   pr-url: https://github.com/nodejs/node/pull/37675
   description: AsyncResource is now Stable. Previously, it had been Experimental.
-->
    <p>
      The class <code>AsyncResource</code> is designed to be extended by the
      embedder’s async resources. Using this, users can easily trigger the
      lifetime events of their own resources.
    </p>
    <p>
      The <code>init</code> hook will trigger when an
      <code>AsyncResource</code> is instantiated.
    </p>
    <p>The following is an overview of the <code>AsyncResource</code> API.</p>
    <pre
      class="mjs"
    ><code>import { AsyncResource, executionAsyncId } from &#39;async_hooks&#39;;

// AsyncResource() is meant to be extended. Instantiating a
// new AsyncResource() also triggers init. If triggerAsyncId is omitted then
// async_hook.executionAsyncId() is used.
const asyncResource = new AsyncResource(
  type, { triggerAsyncId: executionAsyncId(), requireManualDestroy: false }
);

// Run a function in the execution context of the resource. This will
// * establish the context of the resource
// * trigger the AsyncHooks before callbacks
// * call the provided function `fn` with the supplied arguments
// * trigger the AsyncHooks after callbacks
// * restore the original execution context
asyncResource.runInAsyncScope(fn, thisArg, ...args);

// Call AsyncHooks destroy callbacks.
asyncResource.emitDestroy();

// Return the unique ID assigned to the AsyncResource instance.
asyncResource.asyncId();

// Return the trigger ID for the AsyncResource instance.
asyncResource.triggerAsyncId();</code></pre>
    <pre
      class="cjs"
    ><code>const { AsyncResource, executionAsyncId } = require(&#39;async_hooks&#39;);

// AsyncResource() is meant to be extended. Instantiating a
// new AsyncResource() also triggers init. If triggerAsyncId is omitted then
// async_hook.executionAsyncId() is used.
const asyncResource = new AsyncResource(
  type, { triggerAsyncId: executionAsyncId(), requireManualDestroy: false }
);

// Run a function in the execution context of the resource. This will
// * establish the context of the resource
// * trigger the AsyncHooks before callbacks
// * call the provided function `fn` with the supplied arguments
// * trigger the AsyncHooks after callbacks
// * restore the original execution context
asyncResource.runInAsyncScope(fn, thisArg, ...args);

// Call AsyncHooks destroy callbacks.
asyncResource.emitDestroy();

// Return the unique ID assigned to the AsyncResource instance.
asyncResource.asyncId();

// Return the trigger ID for the AsyncResource instance.
asyncResource.triggerAsyncId();</code></pre>
    <h3 id="new-asyncresourcetype-options">
      <code>new AsyncResource(type[, options])</code>
    </h3>
    <ul>
      <li><code>type</code> {string} The type of async event.</li>
      <li>
        <code>options</code> {Object}
        <ul>
          <li>
            <code>triggerAsyncId</code> {number} The ID of the execution context
            that created this async event. <strong>Default:</strong>
            <code>executionAsyncId()</code>.
          </li>
          <li>
            <code>requireManualDestroy</code> {boolean} If set to
            <code>true</code>, disables <code>emitDestroy</code> when the object
            is garbage collected. This usually does not need to be set (even if
            <code>emitDestroy</code> is called manually), unless the resource’s
            <code>asyncId</code> is retrieved and the sensitive API’s
            <code>emitDestroy</code> is called with it. When set to
            <code>false</code>, the <code>emitDestroy</code> call on garbage
            collection will only take place if there is at least one active
            <code>destroy</code> hook. <strong>Default:</strong>
            <code>false</code>.
          </li>
        </ul>
      </li>
    </ul>
    <p>Example usage:</p>
    <div class="sourceCode" id="cb12">
      <pre
        class="sourceCode js"
      ><code class="sourceCode javascript"><a class="sourceLine" id="cb12-1" title="1"><span class="kw">class</span> DBQuery <span class="kw">extends</span> AsyncResource <span class="op">{</span></a>
<a class="sourceLine" id="cb12-2" title="2">  <span class="at">constructor</span>(db) <span class="op">{</span></a>
<a class="sourceLine" id="cb12-3" title="3">    <span class="kw">super</span>(<span class="st">&#39;DBQuery&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb12-4" title="4">    <span class="kw">this</span>.<span class="at">db</span> <span class="op">=</span> db<span class="op">;</span></a>
<a class="sourceLine" id="cb12-5" title="5">  <span class="op">}</span></a>
<a class="sourceLine" id="cb12-6" title="6"></a>
<a class="sourceLine" id="cb12-7" title="7">  <span class="at">getInfo</span>(query<span class="op">,</span> callback) <span class="op">{</span></a>
<a class="sourceLine" id="cb12-8" title="8">    <span class="kw">this</span>.<span class="va">db</span>.<span class="at">get</span>(query<span class="op">,</span> (err<span class="op">,</span> data) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb12-9" title="9">      <span class="kw">this</span>.<span class="at">runInAsyncScope</span>(callback<span class="op">,</span> <span class="kw">null</span><span class="op">,</span> err<span class="op">,</span> data)<span class="op">;</span></a>
<a class="sourceLine" id="cb12-10" title="10">    <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb12-11" title="11">  <span class="op">}</span></a>
<a class="sourceLine" id="cb12-12" title="12"></a>
<a class="sourceLine" id="cb12-13" title="13">  <span class="at">close</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb12-14" title="14">    <span class="kw">this</span>.<span class="at">db</span> <span class="op">=</span> <span class="kw">null</span><span class="op">;</span></a>
<a class="sourceLine" id="cb12-15" title="15">    <span class="kw">this</span>.<span class="at">emitDestroy</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb12-16" title="16">  <span class="op">}</span></a>
<a class="sourceLine" id="cb12-17" title="17"><span class="op">}</span></a></code></pre>
    </div>
    <h3 id="static-method-asyncresource.bindfn-type-thisarg">
      Static method: <code>AsyncResource.bind(fn[, type, [thisArg]])</code>
    </h3>
    <!-- YAML
added:
  - v14.8.0
  - v12.19.0
changes:
  - version: v16.0.0
    pr-url: https://github.com/nodejs/node/pull/36782
    description: Added optional thisArg.
-->
    <ul>
      <li>
        <code>fn</code> {Function} The function to bind to the current execution
        context.
      </li>
      <li>
        <code>type</code> {string} An optional name to associate with the
        underlying <code>AsyncResource</code>.
      </li>
      <li><code>thisArg</code> {any}</li>
    </ul>
    <p>Binds the given function to the current execution context.</p>
    <p>
      The returned function will have an <code>asyncResource</code> property
      referencing the <code>AsyncResource</code> to which the function is bound.
    </p>
    <h3 id="asyncresource.bindfn-thisarg">
      <code>asyncResource.bind(fn[, thisArg])</code>
    </h3>
    <!-- YAML
added:
  - v14.8.0
  - v12.19.0
changes:
  - version: v16.0.0
    pr-url: https://github.com/nodejs/node/pull/36782
    description: Added optional thisArg.
-->
    <ul>
      <li>
        <code>fn</code> {Function} The function to bind to the current
        <code>AsyncResource</code>.
      </li>
      <li><code>thisArg</code> {any}</li>
    </ul>
    <p>
      Binds the given function to execute to this <code>AsyncResource</code>’s
      scope.
    </p>
    <p>
      The returned function will have an <code>asyncResource</code> property
      referencing the <code>AsyncResource</code> to which the function is bound.
    </p>
    <h3 id="asyncresource.runinasyncscopefn-thisarg-...args">
      <code>asyncResource.runInAsyncScope(fn[, thisArg, ...args])</code>
    </h3>
    <!-- YAML
added: v9.6.0
-->
    <ul>
      <li>
        <code>fn</code> {Function} The function to call in the execution context
        of this async resource.
      </li>
      <li>
        <code>thisArg</code> {any} The receiver to be used for the function
        call.
      </li>
      <li>
        <code>...args</code> {any} Optional arguments to pass to the function.
      </li>
    </ul>
    <p>
      Call the provided function with the provided arguments in the execution
      context of the async resource. This will establish the context, trigger
      the AsyncHooks before callbacks, call the function, trigger the AsyncHooks
      after callbacks, and then restore the original execution context.
    </p>
    <h3 id="asyncresource.emitdestroy">
      <code>asyncResource.emitDestroy()</code>
    </h3>
    <ul>
      <li>
        Returns: {AsyncResource} A reference to <code>asyncResource</code>.
      </li>
    </ul>
    <p>
      Call all <code>destroy</code> hooks. This should only ever be called once.
      An error will be thrown if it is called more than once. This
      <strong>must</strong> be manually called. If the resource is left to be
      collected by the GC then the <code>destroy</code> hooks will never be
      called.
    </p>
    <h3 id="asyncresource.asyncid"><code>asyncResource.asyncId()</code></h3>
    <ul>
      <li>
        Returns: {number} The unique <code>asyncId</code> assigned to the
        resource.
      </li>
    </ul>
    <h3 id="asyncresource.triggerasyncid">
      <code>asyncResource.triggerAsyncId()</code>
    </h3>
    <ul>
      <li>
        Returns: {number} The same <code>triggerAsyncId</code> that is passed to
        the <code>AsyncResource</code> constructor.
      </li>
    </ul>
    <p>
      <a id="async-resource-worker-pool"></a> ### Using
      <code>AsyncResource</code> for a <code>Worker</code> thread pool
    </p>
    <p>
      The following example shows how to use the
      <code>AsyncResource</code> class to properly provide async tracking for a
      <a href="worker_threads.md#worker_threads_class_worker"
        ><code>Worker</code></a
      >
      pool. Other resource pools, such as database connection pools, can follow
      a similar model.
    </p>
    <p>
      Assuming that the task is adding two numbers, using a file named
      <code>task_processor.js</code> with the following content:
    </p>
    <pre class="mjs"><code>import { parentPort } from &#39;worker_threads&#39;;
parentPort.on(&#39;message&#39;, (task) =&gt; {
  parentPort.postMessage(task.a + task.b);
});</code></pre>
    <pre
      class="cjs"
    ><code>const { parentPort } = require(&#39;worker_threads&#39;);
parentPort.on(&#39;message&#39;, (task) =&gt; {
  parentPort.postMessage(task.a + task.b);
});</code></pre>
    <p>a Worker pool around it could use the following structure:</p>
    <pre class="mjs"><code>import { AsyncResource } from &#39;async_hooks&#39;;
import { EventEmitter } from &#39;events&#39;;
import path from &#39;path&#39;;
import { Worker } from &#39;worker_threads&#39;;

const kTaskInfo = Symbol(&#39;kTaskInfo&#39;);
const kWorkerFreedEvent = Symbol(&#39;kWorkerFreedEvent&#39;);

class WorkerPoolTaskInfo extends AsyncResource {
  constructor(callback) {
    super(&#39;WorkerPoolTaskInfo&#39;);
    this.callback = callback;
  }

  done(err, result) {
    this.runInAsyncScope(this.callback, null, err, result);
    this.emitDestroy();  // `TaskInfo`s are used only once.
  }
}

export default class WorkerPool extends EventEmitter {
  constructor(numThreads) {
    super();
    this.numThreads = numThreads;
    this.workers = [];
    this.freeWorkers = [];
    this.tasks = [];

    for (let i = 0; i &lt; numThreads; i++)
      this.addNewWorker();

    // Any time the kWorkerFreedEvent is emitted, dispatch
    // the next task pending in the queue, if any.
    this.on(kWorkerFreedEvent, () =&gt; {
      if (this.tasks.length &gt; 0) {
        const { task, callback } = this.tasks.shift();
        this.runTask(task, callback);
      }
    });
  }

  addNewWorker() {
    const worker = new Worker(new URL(&#39;task_processer.js&#39;, import.meta.url));
    worker.on(&#39;message&#39;, (result) =&gt; {
      // In case of success: Call the callback that was passed to `runTask`,
      // remove the `TaskInfo` associated with the Worker, and mark it as free
      // again.
      worker[kTaskInfo].done(null, result);
      worker[kTaskInfo] = null;
      this.freeWorkers.push(worker);
      this.emit(kWorkerFreedEvent);
    });
    worker.on(&#39;error&#39;, (err) =&gt; {
      // In case of an uncaught exception: Call the callback that was passed to
      // `runTask` with the error.
      if (worker[kTaskInfo])
        worker[kTaskInfo].done(err, null);
      else
        this.emit(&#39;error&#39;, err);
      // Remove the worker from the list and start a new Worker to replace the
      // current one.
      this.workers.splice(this.workers.indexOf(worker), 1);
      this.addNewWorker();
    });
    this.workers.push(worker);
    this.freeWorkers.push(worker);
    this.emit(kWorkerFreedEvent);
  }

  runTask(task, callback) {
    if (this.freeWorkers.length === 0) {
      // No free threads, wait until a worker thread becomes free.
      this.tasks.push({ task, callback });
      return;
    }

    const worker = this.freeWorkers.pop();
    worker[kTaskInfo] = new WorkerPoolTaskInfo(callback);
    worker.postMessage(task);
  }

  close() {
    for (const worker of this.workers) worker.terminate();
  }
}</code></pre>
    <pre
      class="cjs"
    ><code>const { AsyncResource } = require(&#39;async_hooks&#39;);
const { EventEmitter } = require(&#39;events&#39;);
const path = require(&#39;path&#39;);
const { Worker } = require(&#39;worker_threads&#39;);

const kTaskInfo = Symbol(&#39;kTaskInfo&#39;);
const kWorkerFreedEvent = Symbol(&#39;kWorkerFreedEvent&#39;);

class WorkerPoolTaskInfo extends AsyncResource {
  constructor(callback) {
    super(&#39;WorkerPoolTaskInfo&#39;);
    this.callback = callback;
  }

  done(err, result) {
    this.runInAsyncScope(this.callback, null, err, result);
    this.emitDestroy();  // `TaskInfo`s are used only once.
  }
}

class WorkerPool extends EventEmitter {
  constructor(numThreads) {
    super();
    this.numThreads = numThreads;
    this.workers = [];
    this.freeWorkers = [];
    this.tasks = [];

    for (let i = 0; i &lt; numThreads; i++)
      this.addNewWorker();

    // Any time the kWorkerFreedEvent is emitted, dispatch
    // the next task pending in the queue, if any.
    this.on(kWorkerFreedEvent, () =&gt; {
      if (this.tasks.length &gt; 0) {
        const { task, callback } = this.tasks.shift();
        this.runTask(task, callback);
      }
    });
  }

  addNewWorker() {
    const worker = new Worker(path.resolve(__dirname, &#39;task_processor.js&#39;));
    worker.on(&#39;message&#39;, (result) =&gt; {
      // In case of success: Call the callback that was passed to `runTask`,
      // remove the `TaskInfo` associated with the Worker, and mark it as free
      // again.
      worker[kTaskInfo].done(null, result);
      worker[kTaskInfo] = null;
      this.freeWorkers.push(worker);
      this.emit(kWorkerFreedEvent);
    });
    worker.on(&#39;error&#39;, (err) =&gt; {
      // In case of an uncaught exception: Call the callback that was passed to
      // `runTask` with the error.
      if (worker[kTaskInfo])
        worker[kTaskInfo].done(err, null);
      else
        this.emit(&#39;error&#39;, err);
      // Remove the worker from the list and start a new Worker to replace the
      // current one.
      this.workers.splice(this.workers.indexOf(worker), 1);
      this.addNewWorker();
    });
    this.workers.push(worker);
    this.freeWorkers.push(worker);
    this.emit(kWorkerFreedEvent);
  }

  runTask(task, callback) {
    if (this.freeWorkers.length === 0) {
      // No free threads, wait until a worker thread becomes free.
      this.tasks.push({ task, callback });
      return;
    }

    const worker = this.freeWorkers.pop();
    worker[kTaskInfo] = new WorkerPoolTaskInfo(callback);
    worker.postMessage(task);
  }

  close() {
    for (const worker of this.workers) worker.terminate();
  }
}

module.exports = WorkerPool;</code></pre>
    <p>
      Without the explicit tracking added by the
      <code>WorkerPoolTaskInfo</code> objects, it would appear that the
      callbacks are associated with the individual <code>Worker</code> objects.
      However, the creation of the <code>Worker</code>s is not associated with
      the creation of the tasks and does not provide information about when
      tasks were scheduled.
    </p>
    <p>This pool could be used as follows:</p>
    <pre class="mjs"><code>import WorkerPool from &#39;./worker_pool.js&#39;;
import os from &#39;os&#39;;

const pool = new WorkerPool(os.cpus().length);

let finished = 0;
for (let i = 0; i &lt; 10; i++) {
  pool.runTask({ a: 42, b: 100 }, (err, result) =&gt; {
    console.log(i, err, result);
    if (++finished === 10)
      pool.close();
  });
}</code></pre>
    <pre
      class="cjs"
    ><code>const WorkerPool = require(&#39;./worker_pool.js&#39;);
const os = require(&#39;os&#39;);

const pool = new WorkerPool(os.cpus().length);

let finished = 0;
for (let i = 0; i &lt; 10; i++) {
  pool.runTask({ a: 42, b: 100 }, (err, result) =&gt; {
    console.log(i, err, result);
    if (++finished === 10)
      pool.close();
  });
}</code></pre>
    <h3 id="integrating-asyncresource-with-eventemitter">
      Integrating <code>AsyncResource</code> with <code>EventEmitter</code>
    </h3>
    <p>
      Event listeners triggered by an
      <a href="events.md#events_class_eventemitter"
        ><code>EventEmitter</code></a
      >
      may be run in a different execution context than the one that was active
      when <code>eventEmitter.on()</code> was called.
    </p>
    <p>
      The following example shows how to use the
      <code>AsyncResource</code> class to properly associate an event listener
      with the correct execution context. The same approach can be applied to a
      <a href="stream.md#stream_stream"><code>Stream</code></a> or a similar
      event-driven class.
    </p>
    <pre class="mjs"><code>import { createServer } from &#39;http&#39;;
import { AsyncResource, executionAsyncId } from &#39;async_hooks&#39;;

const server = createServer((req, res) =&gt; {
  req.on(&#39;close&#39;, AsyncResource.bind(() =&gt; {
    // Execution context is bound to the current outer scope.
  }));
  req.on(&#39;close&#39;, () =&gt; {
    // Execution context is bound to the scope that caused &#39;close&#39; to emit.
  });
  res.end();
}).listen(3000);</code></pre>
    <pre class="cjs"><code>const { createServer } = require(&#39;http&#39;);
const { AsyncResource, executionAsyncId } = require(&#39;async_hooks&#39;);

const server = createServer((req, res) =&gt; {
  req.on(&#39;close&#39;, AsyncResource.bind(() =&gt; {
    // Execution context is bound to the current outer scope.
  }));
  req.on(&#39;close&#39;, () =&gt; {
    // Execution context is bound to the scope that caused &#39;close&#39; to emit.
  });
  res.end();
}).listen(3000);</code></pre>
  </body>
</html>
