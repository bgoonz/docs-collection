<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <meta charset="utf-8" />
    <meta name="generator" content="pandoc" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=yes"
    />
    <title>buffer</title>
    <style type="text/css">
      code {
        white-space: pre-wrap;
      }
      span.smallcaps {
        font-variant: small-caps;
      }
      span.underline {
        text-decoration: underline;
      }
      div.column {
        display: inline-block;
        vertical-align: top;
        width: 50%;
      }
    </style>
  </head>
  <body>
    <h1 id="buffer">Buffer</h1>
    <!--introduced_in=v0.1.90-->
    <blockquote>
      <p>Stability: 2 - Stable</p>
    </blockquote>
    <!-- source_link=lib/buffer.js -->
    <p>
      <code>Buffer</code> objects are used to represent a fixed-length sequence
      of bytes. Many Node.js APIs support <code>Buffer</code>s.
    </p>
    <p>
      The <code>Buffer</code> class is a subclass of JavaScript’s
      <a
        href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array"
        ><code>Uint8Array</code></a
      >
      class and extends it with methods that cover additional use cases. Node.js
      APIs accept plain
      <a
        href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array"
        ><code>Uint8Array</code></a
      >s wherever <code>Buffer</code>s are supported as well.
    </p>
    <p>
      While the <code>Buffer</code> class is available within the global scope,
      it is still recommended to explicitly reference it via an import or
      require statement.
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

// Creates a zero-filled Buffer of length 10.
const buf1 = Buffer.alloc(10);

// Creates a Buffer of length 10,
// filled with bytes which all have the value `1`.
const buf2 = Buffer.alloc(10, 1);

// Creates an uninitialized buffer of length 10.
// This is faster than calling Buffer.alloc() but the returned
// Buffer instance might contain old data that needs to be
// overwritten using fill(), write(), or other functions that fill the Buffer&#39;s
// contents.
const buf3 = Buffer.allocUnsafe(10);

// Creates a Buffer containing the bytes [1, 2, 3].
const buf4 = Buffer.from([1, 2, 3]);

// Creates a Buffer containing the bytes [1, 1, 1, 1] – the entries
// are all truncated using `(value &amp; 255)` to fit into the range 0–255.
const buf5 = Buffer.from([257, 257.5, -255, &#39;1&#39;]);

// Creates a Buffer containing the UTF-8-encoded bytes for the string &#39;tést&#39;:
// [0x74, 0xc3, 0xa9, 0x73, 0x74] (in hexadecimal notation)
// [116, 195, 169, 115, 116] (in decimal notation)
const buf6 = Buffer.from(&#39;tést&#39;);

// Creates a Buffer containing the Latin-1 bytes [0x74, 0xe9, 0x73, 0x74].
const buf7 = Buffer.from(&#39;tést&#39;, &#39;latin1&#39;);</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

// Creates a zero-filled Buffer of length 10.
const buf1 = Buffer.alloc(10);

// Creates a Buffer of length 10,
// filled with bytes which all have the value `1`.
const buf2 = Buffer.alloc(10, 1);

// Creates an uninitialized buffer of length 10.
// This is faster than calling Buffer.alloc() but the returned
// Buffer instance might contain old data that needs to be
// overwritten using fill(), write(), or other functions that fill the Buffer&#39;s
// contents.
const buf3 = Buffer.allocUnsafe(10);

// Creates a Buffer containing the bytes [1, 2, 3].
const buf4 = Buffer.from([1, 2, 3]);

// Creates a Buffer containing the bytes [1, 1, 1, 1] – the entries
// are all truncated using `(value &amp; 255)` to fit into the range 0–255.
const buf5 = Buffer.from([257, 257.5, -255, &#39;1&#39;]);

// Creates a Buffer containing the UTF-8-encoded bytes for the string &#39;tést&#39;:
// [0x74, 0xc3, 0xa9, 0x73, 0x74] (in hexadecimal notation)
// [116, 195, 169, 115, 116] (in decimal notation)
const buf6 = Buffer.from(&#39;tést&#39;);

// Creates a Buffer containing the Latin-1 bytes [0x74, 0xe9, 0x73, 0x74].
const buf7 = Buffer.from(&#39;tést&#39;, &#39;latin1&#39;);</code></pre>
    <h2 id="buffers-and-character-encodings">
      Buffers and character encodings
    </h2>
    <!-- YAML
changes:
  - version: v15.7.0
    pr-url: https://github.com/nodejs/node/pull/36952
    description: Introduced `base64url` encoding.
  - version: v6.4.0
    pr-url: https://github.com/nodejs/node/pull/7111
    description: Introduced `latin1` as an alias for `binary`.
  - version: v5.0.0
    pr-url: https://github.com/nodejs/node/pull/2859
    description: Removed the deprecated `raw` and `raws` encodings.
-->
    <p>
      When converting between <code>Buffer</code>s and strings, a character
      encoding may be specified. If no character encoding is specified, UTF-8
      will be used as the default.
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

const buf = Buffer.from(&#39;hello world&#39;, &#39;utf8&#39;);

console.log(buf.toString(&#39;hex&#39;));
// Prints: 68656c6c6f20776f726c64
console.log(buf.toString(&#39;base64&#39;));
// Prints: aGVsbG8gd29ybGQ=

console.log(Buffer.from(&#39;fhqwhgads&#39;, &#39;utf8&#39;));
// Prints: &lt;Buffer 66 68 71 77 68 67 61 64 73&gt;
console.log(Buffer.from(&#39;fhqwhgads&#39;, &#39;utf16le&#39;));
// Prints: &lt;Buffer 66 00 68 00 71 00 77 00 68 00 67 00 61 00 64 00 73 00&gt;</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

const buf = Buffer.from(&#39;hello world&#39;, &#39;utf8&#39;);

console.log(buf.toString(&#39;hex&#39;));
// Prints: 68656c6c6f20776f726c64
console.log(buf.toString(&#39;base64&#39;));
// Prints: aGVsbG8gd29ybGQ=

console.log(Buffer.from(&#39;fhqwhgads&#39;, &#39;utf8&#39;));
// Prints: &lt;Buffer 66 68 71 77 68 67 61 64 73&gt;
console.log(Buffer.from(&#39;fhqwhgads&#39;, &#39;utf16le&#39;));
// Prints: &lt;Buffer 66 00 68 00 71 00 77 00 68 00 67 00 61 00 64 00 73 00&gt;</code></pre>
    <p>
      Node.js buffers accept all case variations of encoding strings that they
      receive. For example, UTF-8 can be specified as <code>'utf8'</code>,
      <code>'UTF8'</code> or <code>'uTf8'</code>.
    </p>
    <p>
      The character encodings currently supported by Node.js are the following:
    </p>
    <ul>
      <li>
        <p>
          <code>'utf8'</code> (alias: <code>'utf-8'</code>): Multi-byte encoded
          Unicode characters. Many web pages and other document formats use
          <a href="https://en.wikipedia.org/wiki/UTF-8">UTF-8</a>. This is the
          default character encoding. When decoding a <code>Buffer</code> into a
          string that does not exclusively contain valid UTF-8 data, the Unicode
          replacement character <code>U+FFFD</code> � will be used to represent
          those errors.
        </p>
      </li>
      <li>
        <p>
          <code>'utf16le'</code> (alias: <code>'utf-16le'</code>): Multi-byte
          encoded Unicode characters. Unlike <code>'utf8'</code>, each character
          in the string will be encoded using either 2 or 4 bytes. Node.js only
          supports the
          <a href="https://en.wikipedia.org/wiki/Endianness">little-endian</a>
          variant of <a href="https://en.wikipedia.org/wiki/UTF-16">UTF-16</a>.
        </p>
      </li>
      <li>
        <p>
          <code>'latin1'</code>: Latin-1 stands for
          <a href="https://en.wikipedia.org/wiki/ISO-8859-1">ISO-8859-1</a>.
          This character encoding only supports the Unicode characters from
          <code>U+0000</code> to <code>U+00FF</code>. Each character is encoded
          using a single byte. Characters that do not fit into that range are
          truncated and will be mapped to characters in that range.
        </p>
      </li>
    </ul>
    <p>
      Converting a <code>Buffer</code> into a string using one of the above is
      referred to as decoding, and converting a string into a
      <code>Buffer</code> is referred to as encoding.
    </p>
    <p>
      Node.js also supports the following binary-to-text encodings. For
      binary-to-text encodings, the naming convention is reversed: Converting a
      <code>Buffer</code> into a string is typically referred to as encoding,
      and converting a string into a <code>Buffer</code> as decoding.
    </p>
    <ul>
      <li>
        <p>
          <code>'base64'</code>:
          <a href="https://en.wikipedia.org/wiki/Base64">Base64</a> encoding.
          When creating a <code>Buffer</code> from a string, this encoding will
          also correctly accept “URL and Filename Safe Alphabet” as specified in
          <a href="https://tools.ietf.org/html/rfc4648#section-5"
            >RFC 4648, Section 5</a
          >. Whitespace characters such as spaces, tabs, and new lines contained
          within the base64-encoded string are ignored.
        </p>
      </li>
      <li>
        <p>
          <code>'base64url'</code>:
          <a href="https://tools.ietf.org/html/rfc4648#section-5">base64url</a>
          encoding as specified in
          <a href="https://tools.ietf.org/html/rfc4648#section-5"
            >RFC 4648, Section 5</a
          >. When creating a <code>Buffer</code> from a string, this encoding
          will also correctly accept regular base64-encoded strings. When
          encoding a <code>Buffer</code> to a string, this encoding will omit
          padding.
        </p>
      </li>
      <li>
        <p>
          <code>'hex'</code>: Encode each byte as two hexadecimal characters.
          Data truncation may occur when decoding strings that do exclusively
          contain valid hexadecimal characters. See below for an example.
        </p>
      </li>
    </ul>
    <p>The following legacy character encodings are also supported:</p>
    <ul>
      <li>
        <p>
          <code>'ascii'</code>: For 7-bit
          <a href="https://en.wikipedia.org/wiki/ASCII">ASCII</a> data only.
          When encoding a string into a <code>Buffer</code>, this is equivalent
          to using <code>'latin1'</code>. When decoding a
          <code>Buffer</code> into a string, using this encoding will
          additionally unset the highest bit of each byte before decoding as
          <code>'latin1'</code>. Generally, there should be no reason to use
          this encoding, as <code>'utf8'</code> (or, if the data is known to
          always be ASCII-only, <code>'latin1'</code>) will be a better choice
          when encoding or decoding ASCII-only text. It is only provided for
          legacy compatibility.
        </p>
      </li>
      <li>
        <p>
          <code>'binary'</code>: Alias for <code>'latin1'</code>. See
          <a
            href="https://developer.mozilla.org/en-US/docs/Web/API/DOMString/Binary"
            >binary strings</a
          >
          for more background on this topic. The name of this encoding can be
          very misleading, as all of the encodings listed here convert between
          strings and binary data. For converting between strings and
          <code>Buffer</code>s, typically <code>'utf8'</code> is the right
          choice.
        </p>
      </li>
      <li>
        <p>
          <code>'ucs2'</code>, <code>'ucs-2'</code>: Aliases of
          <code>'utf16le'</code>. UCS-2 used to refer to a variant of UTF-16
          that did not support characters that had code points larger than
          U+FFFF. In Node.js, these code points are always supported.
        </p>
      </li>
    </ul>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

Buffer.from(&#39;1ag&#39;, &#39;hex&#39;);
// Prints &lt;Buffer 1a&gt;, data truncated when first non-hexadecimal value
// (&#39;g&#39;) encountered.

Buffer.from(&#39;1a7g&#39;, &#39;hex&#39;);
// Prints &lt;Buffer 1a&gt;, data truncated when data ends in single digit (&#39;7&#39;).

Buffer.from(&#39;1634&#39;, &#39;hex&#39;);
// Prints &lt;Buffer 16 34&gt;, all data represented.</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

Buffer.from(&#39;1ag&#39;, &#39;hex&#39;);
// Prints &lt;Buffer 1a&gt;, data truncated when first non-hexadecimal value
// (&#39;g&#39;) encountered.

Buffer.from(&#39;1a7g&#39;, &#39;hex&#39;);
// Prints &lt;Buffer 1a&gt;, data truncated when data ends in single digit (&#39;7&#39;).

Buffer.from(&#39;1634&#39;, &#39;hex&#39;);
// Prints &lt;Buffer 16 34&gt;, all data represented.</code></pre>
    <p>
      Modern Web browsers follow the
      <a href="https://encoding.spec.whatwg.org/">WHATWG Encoding Standard</a>
      which aliases both <code>'latin1'</code> and <code>'ISO-8859-1'</code> to
      <code>'win-1252'</code>. This means that while doing something like
      <code>http.get()</code>, if the returned charset is one of those listed in
      the WHATWG specification it is possible that the server actually returned
      <code>'win-1252'</code>-encoded data, and using
      <code>'latin1'</code> encoding may incorrectly decode the characters.
    </p>
    <h2 id="buffers-and-typedarrays">Buffers and TypedArrays</h2>
    <!-- YAML
changes:
  - version: v3.0.0
    pr-url: https://github.com/nodejs/node/pull/2002
    description: The `Buffer`s class now inherits from `Uint8Array`.
-->
    <p>
      <code>Buffer</code> instances are also JavaScript
      <a
        href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array"
        ><code>Uint8Array</code></a
      >
      and
      <a
        href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray"
        ><code>TypedArray</code></a
      >
      instances. All
      <a
        href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray"
        ><code>TypedArray</code></a
      >
      methods are available on <code>Buffer</code>s. There are, however, subtle
      incompatibilities between the <code>Buffer</code> API and the
      <a
        href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray"
        ><code>TypedArray</code></a
      >
      API.
    </p>
    <p>In particular:</p>
    <ul>
      <li>
        While
        <a
          href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/slice"
          ><code>TypedArray.prototype.slice()</code></a
        >
        creates a copy of part of the <code>TypedArray</code>,
        <a href="#buffer_buf_slice_start_end"
          ><code>Buffer.prototype.slice()</code></a
        >
        creates a view over the existing <code>Buffer</code> without copying.
        This behavior can be surprising, and only exists for legacy
        compatibility.
        <a
          href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/subarray"
          ><code>TypedArray.prototype.subarray()</code></a
        >
        can be used to achieve the behavior of
        <a href="#buffer_buf_slice_start_end"
          ><code>Buffer.prototype.slice()</code></a
        >
        on both <code>Buffer</code>s and other <code>TypedArray</code>s.
      </li>
      <li>
        <a href="#buffer_buf_tostring_encoding_start_end"
          ><code>buf.toString()</code></a
        >
        is incompatible with its <code>TypedArray</code> equivalent.
      </li>
      <li>
        A number of methods, e.g. <a
          href="#buffer_buf_indexof_value_byteoffset_encoding"
          ><code>buf.indexOf()</code></a
        >, support additional arguments.
      </li>
    </ul>
    <p>
      There are two ways to create new
      <a
        href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray"
        ><code>TypedArray</code></a
      >
      instances from a <code>Buffer</code>:
    </p>
    <ul>
      <li>
        Passing a <code>Buffer</code> to a
        <a
          href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray"
          ><code>TypedArray</code></a
        >
        constructor will copy the <code>Buffer</code>s contents, interpreted as
        an array of integers, and not as a byte sequence of the target type.
      </li>
    </ul>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

const buf = Buffer.from([1, 2, 3, 4]);
const uint32array = new Uint32Array(buf);

console.log(uint32array);

// Prints: Uint32Array(4) [ 1, 2, 3, 4 ]</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

const buf = Buffer.from([1, 2, 3, 4]);
const uint32array = new Uint32Array(buf);

console.log(uint32array);

// Prints: Uint32Array(4) [ 1, 2, 3, 4 ]</code></pre>
    <ul>
      <li>
        Passing the <code>Buffer</code>s underlying
        <a
          href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer"
          ><code>ArrayBuffer</code></a
        >
        will create a
        <a
          href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray"
          ><code>TypedArray</code></a
        >
        that shares its memory with the <code>Buffer</code>.
      </li>
    </ul>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

const buf = Buffer.from(&#39;hello&#39;, &#39;utf16le&#39;);
const uint16array = new Uint16Array(
  buf.buffer,
  buf.byteOffset,
  buf.length / Uint16Array.BYTES_PER_ELEMENT);

console.log(uint16array);

// Prints: Uint16Array(5) [ 104, 101, 108, 108, 111 ]</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

const buf = Buffer.from(&#39;hello&#39;, &#39;utf16le&#39;);
const uint16array = new Uint16Array(
  buf.buffer,
  buf.byteOffset,
  buf.length / Uint16Array.BYTES_PER_ELEMENT);

console.log(uint16array);

// Prints: Uint16Array(5) [ 104, 101, 108, 108, 111 ]</code></pre>
    <p>
      It is possible to create a new <code>Buffer</code> that shares the same
      allocated memory as a
      <a
        href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray"
        ><code>TypedArray</code></a
      >
      instance by using the <code>TypedArray</code> object’s
      <code>.buffer</code> property in the same way.
      <a href="#buffer_static_method_buffer_from_arraybuffer_byteoffset_length"
        ><code>Buffer.from()</code></a
      >
      behaves like <code>new Uint8Array()</code> in this context.
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

const arr = new Uint16Array(2);

arr[0] = 5000;
arr[1] = 4000;

// Copies the contents of `arr`.
const buf1 = Buffer.from(arr);

// Shares memory with `arr`.
const buf2 = Buffer.from(arr.buffer);

console.log(buf1);
// Prints: &lt;Buffer 88 a0&gt;
console.log(buf2);
// Prints: &lt;Buffer 88 13 a0 0f&gt;

arr[1] = 6000;

console.log(buf1);
// Prints: &lt;Buffer 88 a0&gt;
console.log(buf2);
// Prints: &lt;Buffer 88 13 70 17&gt;</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

const arr = new Uint16Array(2);

arr[0] = 5000;
arr[1] = 4000;

// Copies the contents of `arr`.
const buf1 = Buffer.from(arr);

// Shares memory with `arr`.
const buf2 = Buffer.from(arr.buffer);

console.log(buf1);
// Prints: &lt;Buffer 88 a0&gt;
console.log(buf2);
// Prints: &lt;Buffer 88 13 a0 0f&gt;

arr[1] = 6000;

console.log(buf1);
// Prints: &lt;Buffer 88 a0&gt;
console.log(buf2);
// Prints: &lt;Buffer 88 13 70 17&gt;</code></pre>
    <p>
      When creating a <code>Buffer</code> using a
      <a
        href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray"
        ><code>TypedArray</code></a
      >’s <code>.buffer</code>, it is possible to use only a portion of the
      underlying
      <a
        href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer"
        ><code>ArrayBuffer</code></a
      >
      by passing in <code>byteOffset</code> and <code>length</code> parameters.
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

const arr = new Uint16Array(20);
const buf = Buffer.from(arr.buffer, 0, 16);

console.log(buf.length);
// Prints: 16</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

const arr = new Uint16Array(20);
const buf = Buffer.from(arr.buffer, 0, 16);

console.log(buf.length);
// Prints: 16</code></pre>
    <p>
      The <code>Buffer.from()</code> and
      <a
        href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/from"
        ><code>TypedArray.from()</code></a
      >
      have different signatures and implementations. Specifically, the
      <a
        href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray"
        ><code>TypedArray</code></a
      >
      variants accept a second argument that is a mapping function that is
      invoked on every element of the typed array:
    </p>
    <ul>
      <li><code>TypedArray.from(source[, mapFn[, thisArg]])</code></li>
    </ul>
    <p>
      The <code>Buffer.from()</code> method, however, does not support the use
      of a mapping function:
    </p>
    <ul>
      <li>
        <a href="#buffer_static_method_buffer_from_array"
          ><code>Buffer.from(array)</code></a
        >
      </li>
      <li>
        <a href="#buffer_static_method_buffer_from_buffer"
          ><code>Buffer.from(buffer)</code></a
        >
      </li>
      <li>
        <a
          href="#buffer_static_method_buffer_from_arraybuffer_byteoffset_length"
          ><code>Buffer.from(arrayBuffer[, byteOffset[, length]])</code></a
        >
      </li>
      <li>
        <a href="#buffer_static_method_buffer_from_string_encoding"
          ><code>Buffer.from(string[, encoding])</code></a
        >
      </li>
    </ul>
    <h2 id="buffers-and-iteration">Buffers and iteration</h2>
    <p>
      <code>Buffer</code> instances can be iterated over using
      <code>for..of</code> syntax:
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

const buf = Buffer.from([1, 2, 3]);

for (const b of buf) {
  console.log(b);
}
// Prints:
//   1
//   2
//   3</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

const buf = Buffer.from([1, 2, 3]);

for (const b of buf) {
  console.log(b);
}
// Prints:
//   1
//   2
//   3</code></pre>
    <p>
      Additionally, the
      <a href="#buffer_buf_values"><code>buf.values()</code></a
      >, <a href="#buffer_buf_keys"><code>buf.keys()</code></a
      >, and
      <a href="#buffer_buf_entries"><code>buf.entries()</code></a> methods can
      be used to create iterators.
    </p>
    <h2 id="class-blob">Class: <code>Blob</code></h2>
    <!-- YAML
added: v15.7.0
-->
    <blockquote>
      <p>Stability: 1 - Experimental</p>
    </blockquote>
    <p>
      A
      <a href="https://developer.mozilla.org/en-US/docs/Web/API/Blob"
        ><code>Blob</code></a
      >
      encapsulates immutable, raw data that can be safely shared across multiple
      worker threads.
    </p>
    <h3 id="new-buffer.blobsources-options">
      <code>new buffer.Blob([sources[, options]])</code>
    </h3>
    <!-- YAML
added: v15.7.0
-->
    <ul>
      <li>
        <code>sources</code>
        {string[]|ArrayBuffer[]|TypedArray[]|DataView[]|Blob[]} An array of
        string, {ArrayBuffer}, {TypedArray}, {DataView}, or {Blob} objects, or
        any mix of such objects, that will be stored within the
        <code>Blob</code>.
      </li>
      <li>
        <code>options</code> {Object}
        <ul>
          <li>
            <code>encoding</code> {string} The character encoding to use for
            string sources. <strong>Default:</strong> <code>'utf8'</code>.
          </li>
          <li>
            <code>type</code> {string} The Blob content-type. The intent is for
            <code>type</code> to convey the MIME media type of the data, however
            no validation of the type format is performed.
          </li>
        </ul>
      </li>
    </ul>
    <p>
      Creates a new <code>Blob</code> object containing a concatenation of the
      given sources.
    </p>
    <p>
      {ArrayBuffer}, {TypedArray}, {DataView}, and {Buffer} sources are copied
      into the ‘Blob’ and can therefore be safely modified after the ‘Blob’ is
      created.
    </p>
    <p>String sources are also copied into the <code>Blob</code>.</p>
    <h3 id="blob.arraybuffer"><code>blob.arrayBuffer()</code></h3>
    <!-- YAML
added: v15.7.0
-->
    <ul>
      <li>Returns: {Promise}</li>
    </ul>
    <p>
      Returns a promise that fulfills with an {ArrayBuffer} containing a copy of
      the <code>Blob</code> data.
    </p>
    <h3 id="blob.size"><code>blob.size</code></h3>
    <!-- YAML
added: v15.7.0
-->
    <p>The total size of the <code>Blob</code> in bytes.</p>
    <h3 id="blob.slicestart-end-type">
      <code>blob.slice([start, [end, [type]]])</code>
    </h3>
    <!-- YAML
added: v15.7.0
-->
    <ul>
      <li><code>start</code> {number} The starting index.</li>
      <li><code>end</code> {number} The ending index.</li>
      <li>
        <code>type</code> {string} The content-type for the new
        <code>Blob</code>
      </li>
    </ul>
    <p>
      Creates and returns a new <code>Blob</code> containing a subset of this
      <code>Blob</code> objects data. The original <code>Blob</code> is not
      altered.
    </p>
    <h3 id="blob.text"><code>blob.text()</code></h3>
    <!-- YAML
added: v15.7.0
-->
    <ul>
      <li>Returns: {Promise}</li>
    </ul>
    <p>
      Returns a promise that resolves the contents of the
      <code>Blob</code> decoded as a UTF-8 string.
    </p>
    <h3 id="blob.type"><code>blob.type</code></h3>
    <!-- YAML
added: v15.7.0
-->
    <ul>
      <li>Type: {string}</li>
    </ul>
    <p>The content-type of the <code>Blob</code>.</p>
    <h3 id="blob-objects-and-messagechannel">
      <code>Blob</code> objects and <code>MessageChannel</code>
    </h3>
    <p>
      Once a {Blob} object is created, it can be sent via
      <code>MessagePort</code> to multiple destinations without transferring or
      immediately copying the data. The data contained by the
      <code>Blob</code> is copied only when the <code>arrayBuffer()</code> or
      <code>text()</code> methods are called.
    </p>
    <pre class="mjs"><code>import { Blob, Buffer } from &#39;buffer&#39;;
import { setTimeout as delay } from &#39;timers/promises&#39;;

const blob = new Blob([&#39;hello there&#39;]);

const mc1 = new MessageChannel();
const mc2 = new MessageChannel();

mc1.port1.onmessage = async ({ data }) =&gt; {
  console.log(await data.arrayBuffer());
  mc1.port1.close();
};

mc2.port1.onmessage = async ({ data }) =&gt; {
  await delay(1000);
  console.log(await data.arrayBuffer());
  mc2.port1.close();
};

mc1.port2.postMessage(blob);
mc2.port2.postMessage(blob);

// The Blob is still usable after posting.
data.text().then(console.log);</code></pre>
    <pre class="cjs"><code>const { Blob, Buffer } = require(&#39;buffer&#39;);
const { setTimeout: delay } = require(&#39;timers/promises&#39;);

const blob = new Blob([&#39;hello there&#39;]);

const mc1 = new MessageChannel();
const mc2 = new MessageChannel();

mc1.port1.onmessage = async ({ data }) =&gt; {
  console.log(await data.arrayBuffer());
  mc1.port1.close();
};

mc2.port1.onmessage = async ({ data }) =&gt; {
  await delay(1000);
  console.log(await data.arrayBuffer());
  mc2.port1.close();
};

mc1.port2.postMessage(blob);
mc2.port2.postMessage(blob);

// The Blob is still usable after posting.
data.text().then(console.log);</code></pre>
    <h2 id="class-buffer">Class: <code>Buffer</code></h2>
    <p>
      The <code>Buffer</code> class is a global type for dealing with binary
      data directly. It can be constructed in a variety of ways.
    </p>
    <h3 id="static-method-buffer.allocsize-fill-encoding">
      Static method: <code>Buffer.alloc(size[, fill[, encoding]])</code>
    </h3>
    <!-- YAML
added: v5.10.0
changes:
  - version: v15.0.0
    pr-url: https://github.com/nodejs/node/pull/34682
    description: Throw ERR_INVALID_ARG_VALUE instead of ERR_INVALID_OPT_VALUE
                 for invalid input arguments.
  - version: v10.0.0
    pr-url: https://github.com/nodejs/node/pull/18129
    description: Attempting to fill a non-zero length buffer with a zero length
                 buffer triggers a thrown exception.
  - version: v10.0.0
    pr-url: https://github.com/nodejs/node/pull/17427
    description: Specifying an invalid string for `fill` triggers a thrown
                 exception.
  - version: v8.9.3
    pr-url: https://github.com/nodejs/node/pull/17428
    description: Specifying an invalid string for `fill` now results in a
                 zero-filled buffer.
-->
    <ul>
      <li>
        <code>size</code> {integer} The desired length of the new
        <code>Buffer</code>.
      </li>
      <li>
        <code>fill</code> {string|Buffer|Uint8Array|integer} A value to pre-fill
        the new <code>Buffer</code> with. <strong>Default:</strong>
        <code>0</code>.
      </li>
      <li>
        <code>encoding</code> {string} If <code>fill</code> is a string, this is
        its encoding. <strong>Default:</strong> <code>'utf8'</code>.
      </li>
    </ul>
    <p>
      Allocates a new <code>Buffer</code> of <code>size</code> bytes. If
      <code>fill</code> is <code>undefined</code>, the <code>Buffer</code> will
      be zero-filled.
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

const buf = Buffer.alloc(5);

console.log(buf);
// Prints: &lt;Buffer 00 00 00 00 00&gt;</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

const buf = Buffer.alloc(5);

console.log(buf);
// Prints: &lt;Buffer 00 00 00 00 00&gt;</code></pre>
    <p>
      If <code>size</code> is larger than
      <a href="#buffer_buffer_constants_max_length"
        ><code>buffer.constants.MAX_LENGTH</code></a
      >
      or smaller than 0,
      <a href="errors.md#ERR_INVALID_ARG_VALUE"
        ><code>ERR_INVALID_ARG_VALUE</code></a
      >
      is thrown.
    </p>
    <p>
      If <code>fill</code> is specified, the allocated <code>Buffer</code> will
      be initialized by calling
      <a href="#buffer_buf_fill_value_offset_end_encoding"
        ><code>buf.fill(fill)</code></a
      >.
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

const buf = Buffer.alloc(5, &#39;a&#39;);

console.log(buf);
// Prints: &lt;Buffer 61 61 61 61 61&gt;</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

const buf = Buffer.alloc(5, &#39;a&#39;);

console.log(buf);
// Prints: &lt;Buffer 61 61 61 61 61&gt;</code></pre>
    <p>
      If both <code>fill</code> and <code>encoding</code> are specified, the
      allocated <code>Buffer</code> will be initialized by calling
      <a href="#buffer_buf_fill_value_offset_end_encoding"
        ><code>buf.fill(fill, encoding)</code></a
      >.
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

const buf = Buffer.alloc(11, &#39;aGVsbG8gd29ybGQ=&#39;, &#39;base64&#39;);

console.log(buf);
// Prints: &lt;Buffer 68 65 6c 6c 6f 20 77 6f 72 6c 64&gt;</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

const buf = Buffer.alloc(11, &#39;aGVsbG8gd29ybGQ=&#39;, &#39;base64&#39;);

console.log(buf);
// Prints: &lt;Buffer 68 65 6c 6c 6f 20 77 6f 72 6c 64&gt;</code></pre>
    <p>
      Calling
      <a href="#buffer_static_method_buffer_alloc_size_fill_encoding"
        ><code>Buffer.alloc()</code></a
      >
      can be measurably slower than the alternative
      <a href="#buffer_static_method_buffer_allocunsafe_size"
        ><code>Buffer.allocUnsafe()</code></a
      >
      but ensures that the newly created <code>Buffer</code> instance contents
      will never contain sensitive data from previous allocations, including
      data that might not have been allocated for <code>Buffer</code>s.
    </p>
    <p>
      A <code>TypeError</code> will be thrown if <code>size</code> is not a
      number.
    </p>
    <h3 id="static-method-buffer.allocunsafesize">
      Static method: <code>Buffer.allocUnsafe(size)</code>
    </h3>
    <!-- YAML
added: v5.10.0
changes:
  - version: v15.0.0
    pr-url: https://github.com/nodejs/node/pull/34682
    description: Throw ERR_INVALID_ARG_VALUE instead of ERR_INVALID_OPT_VALUE
                 for invalid input arguments.
  - version: v7.0.0
    pr-url: https://github.com/nodejs/node/pull/7079
    description: Passing a negative `size` will now throw an error.
-->
    <ul>
      <li>
        <code>size</code> {integer} The desired length of the new
        <code>Buffer</code>.
      </li>
    </ul>
    <p>
      Allocates a new <code>Buffer</code> of <code>size</code> bytes. If
      <code>size</code> is larger than
      <a href="#buffer_buffer_constants_max_length"
        ><code>buffer.constants.MAX_LENGTH</code></a
      >
      or smaller than 0,
      <a href="errors.md#ERR_INVALID_ARG_VALUE"
        ><code>ERR_INVALID_ARG_VALUE</code></a
      >
      is thrown.
    </p>
    <p>
      The underlying memory for <code>Buffer</code> instances created in this
      way is <em>not initialized</em>. The contents of the newly created
      <code>Buffer</code> are unknown and <em>may contain sensitive data</em>.
      Use
      <a href="#buffer_static_method_buffer_alloc_size_fill_encoding"
        ><code>Buffer.alloc()</code></a
      >
      instead to initialize <code>Buffer</code> instances with zeroes.
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

const buf = Buffer.allocUnsafe(10);

console.log(buf);
// Prints (contents may vary): &lt;Buffer a0 8b 28 3f 01 00 00 00 50 32&gt;

buf.fill(0);

console.log(buf);
// Prints: &lt;Buffer 00 00 00 00 00 00 00 00 00 00&gt;</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

const buf = Buffer.allocUnsafe(10);

console.log(buf);
// Prints (contents may vary): &lt;Buffer a0 8b 28 3f 01 00 00 00 50 32&gt;

buf.fill(0);

console.log(buf);
// Prints: &lt;Buffer 00 00 00 00 00 00 00 00 00 00&gt;</code></pre>
    <p>
      A <code>TypeError</code> will be thrown if <code>size</code> is not a
      number.
    </p>
    <p>
      The <code>Buffer</code> module pre-allocates an internal
      <code>Buffer</code> instance of size
      <a href="#buffer_class_property_buffer_poolsize"
        ><code>Buffer.poolSize</code></a
      >
      that is used as a pool for the fast allocation of new
      <code>Buffer</code> instances created using
      <a href="#buffer_static_method_buffer_allocunsafe_size"
        ><code>Buffer.allocUnsafe()</code></a
      >,
      <a href="#buffer_static_method_buffer_from_array"
        ><code>Buffer.from(array)</code></a
      >,
      <a href="#buffer_static_method_buffer_concat_list_totallength"
        ><code>Buffer.concat()</code></a
      >, and the deprecated <code>new Buffer(size)</code> constructor only when
      <code>size</code> is less than or equal to
      <code>Buffer.poolSize &gt;&gt; 1</code> (floor of
      <a href="#buffer_class_property_buffer_poolsize"
        ><code>Buffer.poolSize</code></a
      >
      divided by two).
    </p>
    <p>
      Use of this pre-allocated internal memory pool is a key difference between
      calling
      <code>Buffer.alloc(size, fill)</code>
      vs. <code>Buffer.allocUnsafe(size).fill(fill)</code>. Specifically,
      <code>Buffer.alloc(size, fill)</code> will <em>never</em> use the internal
      <code>Buffer</code> pool, while
      <code>Buffer.allocUnsafe(size).fill(fill)</code> <em>will</em> use the
      internal <code>Buffer</code> pool if <code>size</code> is less than or
      equal to half
      <a href="#buffer_class_property_buffer_poolsize"
        ><code>Buffer.poolSize</code></a
      >. The difference is subtle but can be important when an application
      requires the additional performance that
      <a href="#buffer_static_method_buffer_allocunsafe_size"
        ><code>Buffer.allocUnsafe()</code></a
      >
      provides.
    </p>
    <h3 id="static-method-buffer.allocunsafeslowsize">
      Static method: <code>Buffer.allocUnsafeSlow(size)</code>
    </h3>
    <!-- YAML
added: v5.12.0
changes:
  - version: v15.0.0
    pr-url: https://github.com/nodejs/node/pull/34682
    description: Throw ERR_INVALID_ARG_VALUE instead of ERR_INVALID_OPT_VALUE
                 for invalid input arguments.
-->
    <ul>
      <li>
        <code>size</code> {integer} The desired length of the new
        <code>Buffer</code>.
      </li>
    </ul>
    <p>
      Allocates a new <code>Buffer</code> of <code>size</code> bytes. If
      <code>size</code> is larger than
      <a href="#buffer_buffer_constants_max_length"
        ><code>buffer.constants.MAX_LENGTH</code></a
      >
      or smaller than 0,
      <a href="errors.md#ERR_INVALID_ARG_VALUE"
        ><code>ERR_INVALID_ARG_VALUE</code></a
      >
      is thrown. A zero-length <code>Buffer</code> is created if
      <code>size</code> is 0.
    </p>
    <p>
      The underlying memory for <code>Buffer</code> instances created in this
      way is <em>not initialized</em>. The contents of the newly created
      <code>Buffer</code> are unknown and <em>may contain sensitive data</em>.
      Use
      <a href="#buffer_buf_fill_value_offset_end_encoding"
        ><code>buf.fill(0)</code></a
      >
      to initialize such <code>Buffer</code> instances with zeroes.
    </p>
    <p>
      When using
      <a href="#buffer_static_method_buffer_allocunsafe_size"
        ><code>Buffer.allocUnsafe()</code></a
      >
      to allocate new <code>Buffer</code> instances, allocations under 4 KB are
      sliced from a single pre-allocated <code>Buffer</code>. This allows
      applications to avoid the garbage collection overhead of creating many
      individually allocated <code>Buffer</code> instances. This approach
      improves both performance and memory usage by eliminating the need to
      track and clean up as many individual <code>ArrayBuffer</code> objects.
    </p>
    <p>
      However, in the case where a developer may need to retain a small chunk of
      memory from a pool for an indeterminate amount of time, it may be
      appropriate to create an un-pooled <code>Buffer</code> instance using
      <code>Buffer.allocUnsafeSlow()</code> and then copying out the relevant
      bits.
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

// Need to keep around a few small chunks of memory.
const store = [];

socket.on(&#39;readable&#39;, () =&gt; {
  let data;
  while (null !== (data = readable.read())) {
    // Allocate for retained data.
    const sb = Buffer.allocUnsafeSlow(10);

    // Copy the data into the new allocation.
    data.copy(sb, 0, 0, 10);

    store.push(sb);
  }
});</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

// Need to keep around a few small chunks of memory.
const store = [];

socket.on(&#39;readable&#39;, () =&gt; {
  let data;
  while (null !== (data = readable.read())) {
    // Allocate for retained data.
    const sb = Buffer.allocUnsafeSlow(10);

    // Copy the data into the new allocation.
    data.copy(sb, 0, 0, 10);

    store.push(sb);
  }
});</code></pre>
    <p>
      A <code>TypeError</code> will be thrown if <code>size</code> is not a
      number.
    </p>
    <h3 id="static-method-buffer.bytelengthstring-encoding">
      Static method: <code>Buffer.byteLength(string[, encoding])</code>
    </h3>
    <!-- YAML
added: v0.1.90
changes:
  - version: v7.0.0
    pr-url: https://github.com/nodejs/node/pull/8946
    description: Passing invalid input will now throw an error.
  - version: v5.10.0
    pr-url: https://github.com/nodejs/node/pull/5255
    description: The `string` parameter can now be any `TypedArray`, `DataView`
                 or `ArrayBuffer`.
-->
    <ul>
      <li>
        <code>string</code>
        {string|Buffer|TypedArray|DataView|ArrayBuffer|SharedArrayBuffer} A
        value to calculate the length of.
      </li>
      <li>
        <code>encoding</code> {string} If <code>string</code> is a string, this
        is its encoding. <strong>Default:</strong> <code>'utf8'</code>.
      </li>
      <li>
        Returns: {integer} The number of bytes contained within
        <code>string</code>.
      </li>
    </ul>
    <p>
      Returns the byte length of a string when encoded using
      <code>encoding</code>. This is not the same as
      <a
        href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/length"
        ><code>String.prototype.length</code></a
      >, which does not account for the encoding that is used to convert the
      string into bytes.
    </p>
    <p>
      For <code>'base64'</code>, <code>'base64url'</code>, and
      <code>'hex'</code>, this function assumes valid input. For strings that
      contain non-base64/hex-encoded data (e.g. whitespace), the return value
      might be greater than the length of a <code>Buffer</code> created from the
      string.
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

const str = &#39;\u00bd + \u00bc = \u00be&#39;;

console.log(`${str}: ${str.length} characters, ` +
            `${Buffer.byteLength(str, &#39;utf8&#39;)} bytes`);
// Prints: ½ + ¼ = ¾: 9 characters, 12 bytes</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

const str = &#39;\u00bd + \u00bc = \u00be&#39;;

console.log(`${str}: ${str.length} characters, ` +
            `${Buffer.byteLength(str, &#39;utf8&#39;)} bytes`);
// Prints: ½ + ¼ = ¾: 9 characters, 12 bytes</code></pre>
    <p>
      When <code>string</code> is a <code>Buffer</code>/<a
        href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView"
        ><code>DataView</code></a
      >/<a
        href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray"
        ><code>TypedArray</code></a
      >/<a
        href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer"
        ><code>ArrayBuffer</code></a
      >/
      <a
        href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer"
        ><code>SharedArrayBuffer</code></a
      >, the byte length as reported by <code>.byteLength</code> is returned.
    </p>
    <h3 id="static-method-buffer.comparebuf1-buf2">
      Static method: <code>Buffer.compare(buf1, buf2)</code>
    </h3>
    <!-- YAML
added: v0.11.13
changes:
  - version: v8.0.0
    pr-url: https://github.com/nodejs/node/pull/10236
    description: The arguments can now be `Uint8Array`s.
-->
    <ul>
      <li><code>buf1</code> {Buffer|Uint8Array}</li>
      <li><code>buf2</code> {Buffer|Uint8Array}</li>
      <li>
        Returns: {integer} Either <code>-1</code>, <code>0</code>, or
        <code>1</code>, depending on the result of the comparison. See
        <a
          href="#buffer_buf_compare_target_targetstart_targetend_sourcestart_sourceend"
          ><code>buf.compare()</code></a
        >
        for details.
      </li>
    </ul>
    <p>
      Compares <code>buf1</code> to <code>buf2</code>, typically for the purpose
      of sorting arrays of <code>Buffer</code> instances. This is equivalent to
      calling
      <a
        href="#buffer_buf_compare_target_targetstart_targetend_sourcestart_sourceend"
        ><code>buf1.compare(buf2)</code></a
      >.
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

const buf1 = Buffer.from(&#39;1234&#39;);
const buf2 = Buffer.from(&#39;0123&#39;);
const arr = [buf1, buf2];

console.log(arr.sort(Buffer.compare));
// Prints: [ &lt;Buffer 30 31 32 33&gt;, &lt;Buffer 31 32 33 34&gt; ]
// (This result is equal to: [buf2, buf1].)</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

const buf1 = Buffer.from(&#39;1234&#39;);
const buf2 = Buffer.from(&#39;0123&#39;);
const arr = [buf1, buf2];

console.log(arr.sort(Buffer.compare));
// Prints: [ &lt;Buffer 30 31 32 33&gt;, &lt;Buffer 31 32 33 34&gt; ]
// (This result is equal to: [buf2, buf1].)</code></pre>
    <h3 id="static-method-buffer.concatlist-totallength">
      Static method: <code>Buffer.concat(list[, totalLength])</code>
    </h3>
    <!-- YAML
added: v0.7.11
changes:
  - version: v8.0.0
    pr-url: https://github.com/nodejs/node/pull/10236
    description: The elements of `list` can now be `Uint8Array`s.
-->
    <ul>
      <li>
        <code>list</code> {Buffer[] | Uint8Array[]} List of
        <code>Buffer</code> or
        <a
          href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array"
          ><code>Uint8Array</code></a
        >
        instances to concatenate.
      </li>
      <li>
        <code>totalLength</code> {integer} Total length of the
        <code>Buffer</code> instances in <code>list</code> when concatenated.
      </li>
      <li>Returns: {Buffer}</li>
    </ul>
    <p>
      Returns a new <code>Buffer</code> which is the result of concatenating all
      the <code>Buffer</code> instances in the <code>list</code> together.
    </p>
    <p>
      If the list has no items, or if the <code>totalLength</code> is 0, then a
      new zero-length <code>Buffer</code> is returned.
    </p>
    <p>
      If <code>totalLength</code> is not provided, it is calculated from the
      <code>Buffer</code> instances in <code>list</code> by adding their
      lengths.
    </p>
    <p>
      If <code>totalLength</code> is provided, it is coerced to an unsigned
      integer. If the combined length of the <code>Buffer</code>s in
      <code>list</code> exceeds <code>totalLength</code>, the result is
      truncated to <code>totalLength</code>.
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

// Create a single `Buffer` from a list of three `Buffer` instances.

const buf1 = Buffer.alloc(10);
const buf2 = Buffer.alloc(14);
const buf3 = Buffer.alloc(18);
const totalLength = buf1.length + buf2.length + buf3.length;

console.log(totalLength);
// Prints: 42

const bufA = Buffer.concat([buf1, buf2, buf3], totalLength);

console.log(bufA);
// Prints: &lt;Buffer 00 00 00 00 ...&gt;
console.log(bufA.length);
// Prints: 42</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

// Create a single `Buffer` from a list of three `Buffer` instances.

const buf1 = Buffer.alloc(10);
const buf2 = Buffer.alloc(14);
const buf3 = Buffer.alloc(18);
const totalLength = buf1.length + buf2.length + buf3.length;

console.log(totalLength);
// Prints: 42

const bufA = Buffer.concat([buf1, buf2, buf3], totalLength);

console.log(bufA);
// Prints: &lt;Buffer 00 00 00 00 ...&gt;
console.log(bufA.length);
// Prints: 42</code></pre>
    <p>
      <code>Buffer.concat()</code> may also use the internal
      <code>Buffer</code> pool like
      <a href="#buffer_static_method_buffer_allocunsafe_size"
        ><code>Buffer.allocUnsafe()</code></a
      >
      does.
    </p>
    <h3 id="static-method-buffer.fromarray">
      Static method: <code>Buffer.from(array)</code>
    </h3>
    <!-- YAML
added: v5.10.0
-->
    <ul>
      <li><code>array</code> {integer[]}</li>
    </ul>
    <p>
      Allocates a new <code>Buffer</code> using an <code>array</code> of bytes
      in the range <code>0</code> – <code>255</code>. Array entries outside that
      range will be truncated to fit into it.
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

// Creates a new Buffer containing the UTF-8 bytes of the string &#39;buffer&#39;.
const buf = Buffer.from([0x62, 0x75, 0x66, 0x66, 0x65, 0x72]);</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

// Creates a new Buffer containing the UTF-8 bytes of the string &#39;buffer&#39;.
const buf = Buffer.from([0x62, 0x75, 0x66, 0x66, 0x65, 0x72]);</code></pre>
    <p>
      A <code>TypeError</code> will be thrown if <code>array</code> is not an
      <code>Array</code> or another type appropriate for
      <code>Buffer.from()</code> variants.
    </p>
    <p>
      <code>Buffer.from(array)</code> and
      <a href="#buffer_static_method_buffer_from_string_encoding"
        ><code>Buffer.from(string)</code></a
      >
      may also use the internal <code>Buffer</code> pool like
      <a href="#buffer_static_method_buffer_allocunsafe_size"
        ><code>Buffer.allocUnsafe()</code></a
      >
      does.
    </p>
    <h3 id="static-method-buffer.fromarraybuffer-byteoffset-length">
      Static method:
      <code>Buffer.from(arrayBuffer[, byteOffset[, length]])</code>
    </h3>
    <!-- YAML
added: v5.10.0
-->
    <ul>
      <li>
        <code>arrayBuffer</code> {ArrayBuffer|SharedArrayBuffer} An
        <a
          href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer"
          ><code>ArrayBuffer</code></a
        >,
        <a
          href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer"
          ><code>SharedArrayBuffer</code></a
        >, for example the <code>.buffer</code> property of a
        <a
          href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray"
          ><code>TypedArray</code></a
        >.
      </li>
      <li>
        <code>byteOffset</code> {integer} Index of first byte to expose.
        <strong>Default:</strong> <code>0</code>.
      </li>
      <li>
        <code>length</code> {integer} Number of bytes to expose.
        <strong>Default:</strong>
        <code>arrayBuffer.byteLength - byteOffset</code>.
      </li>
    </ul>
    <p>
      This creates a view of the
      <a
        href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer"
        ><code>ArrayBuffer</code></a
      >
      without copying the underlying memory. For example, when passed a
      reference to the <code>.buffer</code> property of a
      <a
        href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray"
        ><code>TypedArray</code></a
      >
      instance, the newly created <code>Buffer</code> will share the same
      allocated memory as the
      <a
        href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray"
        ><code>TypedArray</code></a
      >’s underlying <code>ArrayBuffer</code>.
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

const arr = new Uint16Array(2);

arr[0] = 5000;
arr[1] = 4000;

// Shares memory with `arr`.
const buf = Buffer.from(arr.buffer);

console.log(buf);
// Prints: &lt;Buffer 88 13 a0 0f&gt;

// Changing the original Uint16Array changes the Buffer also.
arr[1] = 6000;

console.log(buf);
// Prints: &lt;Buffer 88 13 70 17&gt;</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

const arr = new Uint16Array(2);

arr[0] = 5000;
arr[1] = 4000;

// Shares memory with `arr`.
const buf = Buffer.from(arr.buffer);

console.log(buf);
// Prints: &lt;Buffer 88 13 a0 0f&gt;

// Changing the original Uint16Array changes the Buffer also.
arr[1] = 6000;

console.log(buf);
// Prints: &lt;Buffer 88 13 70 17&gt;</code></pre>
    <p>
      The optional <code>byteOffset</code> and <code>length</code> arguments
      specify a memory range within the <code>arrayBuffer</code> that will be
      shared by the <code>Buffer</code>.
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

const ab = new ArrayBuffer(10);
const buf = Buffer.from(ab, 0, 2);

console.log(buf.length);
// Prints: 2</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

const ab = new ArrayBuffer(10);
const buf = Buffer.from(ab, 0, 2);

console.log(buf.length);
// Prints: 2</code></pre>
    <p>
      A <code>TypeError</code> will be thrown if <code>arrayBuffer</code> is not
      an
      <a
        href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer"
        ><code>ArrayBuffer</code></a
      >
      or a
      <a
        href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer"
        ><code>SharedArrayBuffer</code></a
      >
      or another type appropriate for <code>Buffer.from()</code> variants.
    </p>
    <p>
      It is important to remember that a backing <code>ArrayBuffer</code> can
      cover a range of memory that extends beyond the bounds of a
      <code>TypedArray</code> view. A new <code>Buffer</code> created using the
      <code>buffer</code> property of a <code>TypedArray</code> may extend
      beyond the range of the <code>TypedArray</code>:
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

const arrA = Uint8Array.from([0x63, 0x64, 0x65, 0x66]); // 4 elements
const arrB = new Uint8Array(arrA.buffer, 1, 2); // 2 elements
console.log(arrA.buffer === arrB.buffer); // true

const buf = Buffer.from(arrB.buffer);
console.log(buf);
// Prints: &lt;Buffer 63 64 65 66&gt;</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

const arrA = Uint8Array.from([0x63, 0x64, 0x65, 0x66]); // 4 elements
const arrB = new Uint8Array(arrA.buffer, 1, 2); // 2 elements
console.log(arrA.buffer === arrB.buffer); // true

const buf = Buffer.from(arrB.buffer);
console.log(buf);
// Prints: &lt;Buffer 63 64 65 66&gt;</code></pre>
    <h3 id="static-method-buffer.frombuffer">
      Static method: <code>Buffer.from(buffer)</code>
    </h3>
    <!-- YAML
added: v5.10.0
-->
    <ul>
      <li>
        <code>buffer</code> {Buffer|Uint8Array} An existing
        <code>Buffer</code> or
        <a
          href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array"
          ><code>Uint8Array</code></a
        >
        from which to copy data.
      </li>
    </ul>
    <p>
      Copies the passed <code>buffer</code> data onto a new
      <code>Buffer</code> instance.
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

const buf1 = Buffer.from(&#39;buffer&#39;);
const buf2 = Buffer.from(buf1);

buf1[0] = 0x61;

console.log(buf1.toString());
// Prints: auffer
console.log(buf2.toString());
// Prints: buffer</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

const buf1 = Buffer.from(&#39;buffer&#39;);
const buf2 = Buffer.from(buf1);

buf1[0] = 0x61;

console.log(buf1.toString());
// Prints: auffer
console.log(buf2.toString());
// Prints: buffer</code></pre>
    <p>
      A <code>TypeError</code> will be thrown if <code>buffer</code> is not a
      <code>Buffer</code> or another type appropriate for
      <code>Buffer.from()</code> variants.
    </p>
    <h3 id="static-method-buffer.fromobject-offsetorencoding-length">
      Static method:
      <code>Buffer.from(object[, offsetOrEncoding[, length]])</code>
    </h3>
    <!-- YAML
added: v8.2.0
-->
    <ul>
      <li>
        <code>object</code> {Object} An object supporting
        <code>Symbol.toPrimitive</code> or <code>valueOf()</code>.
      </li>
      <li>
        <code>offsetOrEncoding</code> {integer|string} A byte-offset or
        encoding.
      </li>
      <li><code>length</code> {integer} A length.</li>
    </ul>
    <p>
      For objects whose <code>valueOf()</code> function returns a value not
      strictly equal to <code>object</code>, returns
      <code>Buffer.from(object.valueOf(), offsetOrEncoding, length)</code>.
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

const buf = Buffer.from(new String(&#39;this is a test&#39;));
// Prints: &lt;Buffer 74 68 69 73 20 69 73 20 61 20 74 65 73 74&gt;</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

const buf = Buffer.from(new String(&#39;this is a test&#39;));
// Prints: &lt;Buffer 74 68 69 73 20 69 73 20 61 20 74 65 73 74&gt;</code></pre>
    <p>
      For objects that support <code>Symbol.toPrimitive</code>, returns
      <code
        >Buffer.from(object[Symbol.toPrimitive]('string'),
        offsetOrEncoding)</code
      >.
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

class Foo {
  [Symbol.toPrimitive]() {
    return &#39;this is a test&#39;;
  }
}

const buf = Buffer.from(new Foo(), &#39;utf8&#39;);
// Prints: &lt;Buffer 74 68 69 73 20 69 73 20 61 20 74 65 73 74&gt;</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

class Foo {
  [Symbol.toPrimitive]() {
    return &#39;this is a test&#39;;
  }
}

const buf = Buffer.from(new Foo(), &#39;utf8&#39;);
// Prints: &lt;Buffer 74 68 69 73 20 69 73 20 61 20 74 65 73 74&gt;</code></pre>
    <p>
      A <code>TypeError</code> will be thrown if <code>object</code> does not
      have the mentioned methods or is not of another type appropriate for
      <code>Buffer.from()</code> variants.
    </p>
    <h3 id="static-method-buffer.fromstring-encoding">
      Static method: <code>Buffer.from(string[, encoding])</code>
    </h3>
    <!-- YAML
added: v5.10.0
-->
    <ul>
      <li><code>string</code> {string} A string to encode.</li>
      <li>
        <code>encoding</code> {string} The encoding of <code>string</code>.
        <strong>Default:</strong> <code>'utf8'</code>.
      </li>
    </ul>
    <p>
      Creates a new <code>Buffer</code> containing <code>string</code>. The
      <code>encoding</code> parameter identifies the character encoding to be
      used when converting <code>string</code> into bytes.
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

const buf1 = Buffer.from(&#39;this is a tést&#39;);
const buf2 = Buffer.from(&#39;7468697320697320612074c3a97374&#39;, &#39;hex&#39;);

console.log(buf1.toString());
// Prints: this is a tést
console.log(buf2.toString());
// Prints: this is a tést
console.log(buf1.toString(&#39;latin1&#39;));
// Prints: this is a tÃ©st</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

const buf1 = Buffer.from(&#39;this is a tést&#39;);
const buf2 = Buffer.from(&#39;7468697320697320612074c3a97374&#39;, &#39;hex&#39;);

console.log(buf1.toString());
// Prints: this is a tést
console.log(buf2.toString());
// Prints: this is a tést
console.log(buf1.toString(&#39;latin1&#39;));
// Prints: this is a tÃ©st</code></pre>
    <p>
      A <code>TypeError</code> will be thrown if <code>string</code> is not a
      string or another type appropriate for
      <code>Buffer.from()</code> variants.
    </p>
    <h3 id="static-method-buffer.isbufferobj">
      Static method: <code>Buffer.isBuffer(obj)</code>
    </h3>
    <!-- YAML
added: v0.1.101
-->
    <ul>
      <li><code>obj</code> {Object}</li>
      <li>Returns: {boolean}</li>
    </ul>
    <p>
      Returns <code>true</code> if <code>obj</code> is a <code>Buffer</code>,
      <code>false</code> otherwise.
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

Buffer.isBuffer(Buffer.alloc(10)); // true
Buffer.isBuffer(Buffer.from(&#39;foo&#39;)); // true
Buffer.isBuffer(&#39;a string&#39;); // false
Buffer.isBuffer([]); // false
Buffer.isBuffer(new Uint8Array(1024)); // false</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

Buffer.isBuffer(Buffer.alloc(10)); // true
Buffer.isBuffer(Buffer.from(&#39;foo&#39;)); // true
Buffer.isBuffer(&#39;a string&#39;); // false
Buffer.isBuffer([]); // false
Buffer.isBuffer(new Uint8Array(1024)); // false</code></pre>
    <h3 id="static-method-buffer.isencodingencoding">
      Static method: <code>Buffer.isEncoding(encoding)</code>
    </h3>
    <!-- YAML
added: v0.9.1
-->
    <ul>
      <li>
        <code>encoding</code> {string} A character encoding name to check.
      </li>
      <li>Returns: {boolean}</li>
    </ul>
    <p>
      Returns <code>true</code> if <code>encoding</code> is the name of a
      supported character encoding, or <code>false</code> otherwise.
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

console.log(Buffer.isEncoding(&#39;utf8&#39;));
// Prints: true

console.log(Buffer.isEncoding(&#39;hex&#39;));
// Prints: true

console.log(Buffer.isEncoding(&#39;utf/8&#39;));
// Prints: false

console.log(Buffer.isEncoding(&#39;&#39;));
// Prints: false</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

console.log(Buffer.isEncoding(&#39;utf8&#39;));
// Prints: true

console.log(Buffer.isEncoding(&#39;hex&#39;));
// Prints: true

console.log(Buffer.isEncoding(&#39;utf/8&#39;));
// Prints: false

console.log(Buffer.isEncoding(&#39;&#39;));
// Prints: false</code></pre>
    <h3 id="class-property-buffer.poolsize">
      Class property: <code>Buffer.poolSize</code>
    </h3>
    <!-- YAML
added: v0.11.3
-->
    <ul>
      <li>{integer} <strong>Default:</strong> <code>8192</code></li>
    </ul>
    <p>
      This is the size (in bytes) of pre-allocated internal
      <code>Buffer</code> instances used for pooling. This value may be
      modified.
    </p>
    <h3 id="bufindex"><code>buf[index]</code></h3>
    <ul>
      <li><code>index</code> {integer}</li>
    </ul>
    <p>
      The index operator <code>[index]</code> can be used to get and set the
      octet at position <code>index</code> in <code>buf</code>. The values refer
      to individual bytes, so the legal value range is between
      <code>0x00</code> and <code>0xFF</code> (hex) or <code>0</code> and
      <code>255</code> (decimal).
    </p>
    <p>
      This operator is inherited from <code>Uint8Array</code>, so its behavior
      on out-of-bounds access is the same as <code>Uint8Array</code>. In other
      words, <code>buf[index]</code> returns <code>undefined</code> when
      <code>index</code> is negative or greater or equal to
      <code>buf.length</code>, and <code>buf[index] = value</code> does not
      modify the buffer if <code>index</code> is negative or
      <code>&gt;= buf.length</code>.
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

// Copy an ASCII string into a `Buffer` one byte at a time.
// (This only works for ASCII-only strings. In general, one should use
// `Buffer.from()` to perform this conversion.)

const str = &#39;Node.js&#39;;
const buf = Buffer.allocUnsafe(str.length);

for (let i = 0; i &lt; str.length; i++) {
  buf[i] = str.charCodeAt(i);
}

console.log(buf.toString(&#39;utf8&#39;));
// Prints: Node.js</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

// Copy an ASCII string into a `Buffer` one byte at a time.
// (This only works for ASCII-only strings. In general, one should use
// `Buffer.from()` to perform this conversion.)

const str = &#39;Node.js&#39;;
const buf = Buffer.allocUnsafe(str.length);

for (let i = 0; i &lt; str.length; i++) {
  buf[i] = str.charCodeAt(i);
}

console.log(buf.toString(&#39;utf8&#39;));
// Prints: Node.js</code></pre>
    <h3 id="buf.buffer"><code>buf.buffer</code></h3>
    <ul>
      <li>
        {ArrayBuffer} The underlying <code>ArrayBuffer</code> object based on
        which this <code>Buffer</code> object is created.
      </li>
    </ul>
    <p>
      This <code>ArrayBuffer</code> is not guaranteed to correspond exactly to
      the original <code>Buffer</code>. See the notes on
      <code>buf.byteOffset</code> for details.
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

const arrayBuffer = new ArrayBuffer(16);
const buffer = Buffer.from(arrayBuffer);

console.log(buffer.buffer === arrayBuffer);
// Prints: true</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

const arrayBuffer = new ArrayBuffer(16);
const buffer = Buffer.from(arrayBuffer);

console.log(buffer.buffer === arrayBuffer);
// Prints: true</code></pre>
    <h3 id="buf.byteoffset"><code>buf.byteOffset</code></h3>
    <ul>
      <li>
        {integer} The <code>byteOffset</code> of the <code>Buffer</code>s
        underlying <code>ArrayBuffer</code> object.
      </li>
    </ul>
    <p>
      When setting <code>byteOffset</code> in
      <code>Buffer.from(ArrayBuffer, byteOffset, length)</code>, or sometimes
      when allocating a <code>Buffer</code> smaller than
      <code>Buffer.poolSize</code>, the buffer does not start from a zero offset
      on the underlying <code>ArrayBuffer</code>.
    </p>
    <p>
      This can cause problems when accessing the underlying
      <code>ArrayBuffer</code> directly using <code>buf.buffer</code>, as other
      parts of the <code>ArrayBuffer</code> may be unrelated to the
      <code>Buffer</code> object itself.
    </p>
    <p>
      A common issue when creating a <code>TypedArray</code> object that shares
      its memory with a <code>Buffer</code> is that in this case one needs to
      specify the <code>byteOffset</code> correctly:
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

// Create a buffer smaller than `Buffer.poolSize`.
const nodeBuffer = new Buffer.from([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);

// When casting the Node.js Buffer to an Int8Array, use the byteOffset
// to refer only to the part of `nodeBuffer.buffer` that contains the memory
// for `nodeBuffer`.
new Int8Array(nodeBuffer.buffer, nodeBuffer.byteOffset, nodeBuffer.length);</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

// Create a buffer smaller than `Buffer.poolSize`.
const nodeBuffer = new Buffer.from([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);

// When casting the Node.js Buffer to an Int8Array, use the byteOffset
// to refer only to the part of `nodeBuffer.buffer` that contains the memory
// for `nodeBuffer`.
new Int8Array(nodeBuffer.buffer, nodeBuffer.byteOffset, nodeBuffer.length);</code></pre>
    <h3 id="buf.comparetarget-targetstart-targetend-sourcestart-sourceend">
      <code
        >buf.compare(target[, targetStart[, targetEnd[, sourceStart[,
        sourceEnd]]]])</code
      >
    </h3>
    <!-- YAML
added: v0.11.13
changes:
  - version: v8.0.0
    pr-url: https://github.com/nodejs/node/pull/10236
    description: The `target` parameter can now be a `Uint8Array`.
  - version: v5.11.0
    pr-url: https://github.com/nodejs/node/pull/5880
    description: Additional parameters for specifying offsets are supported now.
-->
    <ul>
      <li>
        <code>target</code> {Buffer|Uint8Array} A <code>Buffer</code> or
        <a
          href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array"
          ><code>Uint8Array</code></a
        >
        with which to compare <code>buf</code>.
      </li>
      <li>
        <code>targetStart</code> {integer} The offset within
        <code>target</code> at which to begin comparison.
        <strong>Default:</strong> <code>0</code>.
      </li>
      <li>
        <code>targetEnd</code> {integer} The offset within
        <code>target</code> at which to end comparison (not inclusive).
        <strong>Default:</strong> <code>target.length</code>.
      </li>
      <li>
        <code>sourceStart</code> {integer} The offset within <code>buf</code> at
        which to begin comparison. <strong>Default:</strong> <code>0</code>.
      </li>
      <li>
        <code>sourceEnd</code> {integer} The offset within <code>buf</code> at
        which to end comparison (not inclusive). <strong>Default:</strong>
        <a href="#buffer_buf_length"><code>buf.length</code></a
        >.
      </li>
      <li>Returns: {integer}</li>
    </ul>
    <p>
      Compares <code>buf</code> with <code>target</code> and returns a number
      indicating whether <code>buf</code> comes before, after, or is the same as
      <code>target</code> in sort order. Comparison is based on the actual
      sequence of bytes in each <code>Buffer</code>.
    </p>
    <ul>
      <li>
        <code>0</code> is returned if <code>target</code> is the same as
        <code>buf</code>
      </li>
      <li>
        <code>1</code> is returned if <code>target</code> should come
        <em>before</em> <code>buf</code> when sorted.
      </li>
      <li>
        <code>-1</code> is returned if <code>target</code> should come
        <em>after</em> <code>buf</code> when sorted.
      </li>
    </ul>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

const buf1 = Buffer.from(&#39;ABC&#39;);
const buf2 = Buffer.from(&#39;BCD&#39;);
const buf3 = Buffer.from(&#39;ABCD&#39;);

console.log(buf1.compare(buf1));
// Prints: 0
console.log(buf1.compare(buf2));
// Prints: -1
console.log(buf1.compare(buf3));
// Prints: -1
console.log(buf2.compare(buf1));
// Prints: 1
console.log(buf2.compare(buf3));
// Prints: 1
console.log([buf1, buf2, buf3].sort(Buffer.compare));
// Prints: [ &lt;Buffer 41 42 43&gt;, &lt;Buffer 41 42 43 44&gt;, &lt;Buffer 42 43 44&gt; ]
// (This result is equal to: [buf1, buf3, buf2].)</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

const buf1 = Buffer.from(&#39;ABC&#39;);
const buf2 = Buffer.from(&#39;BCD&#39;);
const buf3 = Buffer.from(&#39;ABCD&#39;);

console.log(buf1.compare(buf1));
// Prints: 0
console.log(buf1.compare(buf2));
// Prints: -1
console.log(buf1.compare(buf3));
// Prints: -1
console.log(buf2.compare(buf1));
// Prints: 1
console.log(buf2.compare(buf3));
// Prints: 1
console.log([buf1, buf2, buf3].sort(Buffer.compare));
// Prints: [ &lt;Buffer 41 42 43&gt;, &lt;Buffer 41 42 43 44&gt;, &lt;Buffer 42 43 44&gt; ]
// (This result is equal to: [buf1, buf3, buf2].)</code></pre>
    <p>
      The optional <code>targetStart</code>, <code>targetEnd</code>,
      <code>sourceStart</code>, and <code>sourceEnd</code> arguments can be used
      to limit the comparison to specific ranges within <code>target</code> and
      <code>buf</code> respectively.
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

const buf1 = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8, 9]);
const buf2 = Buffer.from([5, 6, 7, 8, 9, 1, 2, 3, 4]);

console.log(buf1.compare(buf2, 5, 9, 0, 4));
// Prints: 0
console.log(buf1.compare(buf2, 0, 6, 4));
// Prints: -1
console.log(buf1.compare(buf2, 5, 6, 5));
// Prints: 1</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

const buf1 = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8, 9]);
const buf2 = Buffer.from([5, 6, 7, 8, 9, 1, 2, 3, 4]);

console.log(buf1.compare(buf2, 5, 9, 0, 4));
// Prints: 0
console.log(buf1.compare(buf2, 0, 6, 4));
// Prints: -1
console.log(buf1.compare(buf2, 5, 6, 5));
// Prints: 1</code></pre>
    <p>
      <a href="errors.md#ERR_OUT_OF_RANGE"><code>ERR_OUT_OF_RANGE</code></a> is
      thrown if <code>targetStart &lt; 0</code>,
      <code>sourceStart &lt; 0</code>,
      <code>targetEnd &gt; target.byteLength</code>, or
      <code>sourceEnd &gt; source.byteLength</code>.
    </p>
    <h3 id="buf.copytarget-targetstart-sourcestart-sourceend">
      <code>buf.copy(target[, targetStart[, sourceStart[, sourceEnd]]])</code>
    </h3>
    <!-- YAML
added: v0.1.90
-->
    <ul>
      <li>
        <code>target</code> {Buffer|Uint8Array} A <code>Buffer</code> or
        <a
          href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array"
          ><code>Uint8Array</code></a
        >
        to copy into.
      </li>
      <li>
        <code>targetStart</code> {integer} The offset within
        <code>target</code> at which to begin writing.
        <strong>Default:</strong> <code>0</code>.
      </li>
      <li>
        <code>sourceStart</code> {integer} The offset within
        <code>buf</code> from which to begin copying. <strong>Default:</strong>
        <code>0</code>.
      </li>
      <li>
        <code>sourceEnd</code> {integer} The offset within <code>buf</code> at
        which to stop copying (not inclusive). <strong>Default:</strong>
        <a href="#buffer_buf_length"><code>buf.length</code></a
        >.
      </li>
      <li>Returns: {integer} The number of bytes copied.</li>
    </ul>
    <p>
      Copies data from a region of <code>buf</code> to a region in
      <code>target</code>, even if the <code>target</code> memory region
      overlaps with <code>buf</code>.
    </p>
    <p>
      <a
        href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set"
        ><code>TypedArray.prototype.set()</code></a
      >
      performs the same operation, and is available for all TypedArrays,
      including Node.js <code>Buffer</code>s, although it takes different
      function arguments.
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

// Create two `Buffer` instances.
const buf1 = Buffer.allocUnsafe(26);
const buf2 = Buffer.allocUnsafe(26).fill(&#39;!&#39;);

for (let i = 0; i &lt; 26; i++) {
  // 97 is the decimal ASCII value for &#39;a&#39;.
  buf1[i] = i + 97;
}

// Copy `buf1` bytes 16 through 19 into `buf2` starting at byte 8 of `buf2`.
buf1.copy(buf2, 8, 16, 20);
// This is equivalent to:
// buf2.set(buf1.subarray(16, 20), 8);

console.log(buf2.toString(&#39;ascii&#39;, 0, 25));
// Prints: !!!!!!!!qrst!!!!!!!!!!!!!</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

// Create two `Buffer` instances.
const buf1 = Buffer.allocUnsafe(26);
const buf2 = Buffer.allocUnsafe(26).fill(&#39;!&#39;);

for (let i = 0; i &lt; 26; i++) {
  // 97 is the decimal ASCII value for &#39;a&#39;.
  buf1[i] = i + 97;
}

// Copy `buf1` bytes 16 through 19 into `buf2` starting at byte 8 of `buf2`.
buf1.copy(buf2, 8, 16, 20);
// This is equivalent to:
// buf2.set(buf1.subarray(16, 20), 8);

console.log(buf2.toString(&#39;ascii&#39;, 0, 25));
// Prints: !!!!!!!!qrst!!!!!!!!!!!!!</code></pre>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

// Create a `Buffer` and copy data from one region to an overlapping region
// within the same `Buffer`.

const buf = Buffer.allocUnsafe(26);

for (let i = 0; i &lt; 26; i++) {
  // 97 is the decimal ASCII value for &#39;a&#39;.
  buf[i] = i + 97;
}

buf.copy(buf, 0, 4, 10);

console.log(buf.toString());
// Prints: efghijghijklmnopqrstuvwxyz</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

// Create a `Buffer` and copy data from one region to an overlapping region
// within the same `Buffer`.

const buf = Buffer.allocUnsafe(26);

for (let i = 0; i &lt; 26; i++) {
  // 97 is the decimal ASCII value for &#39;a&#39;.
  buf[i] = i + 97;
}

buf.copy(buf, 0, 4, 10);

console.log(buf.toString());
// Prints: efghijghijklmnopqrstuvwxyz</code></pre>
    <h3 id="buf.entries"><code>buf.entries()</code></h3>
    <!-- YAML
added: v1.1.0
-->
    <ul>
      <li>Returns: {Iterator}</li>
    </ul>
    <p>
      Creates and returns an
      <a
        href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols"
        >iterator</a
      >
      of <code>[index, byte]</code> pairs from the contents of <code>buf</code>.
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

// Log the entire contents of a `Buffer`.

const buf = Buffer.from(&#39;buffer&#39;);

for (const pair of buf.entries()) {
  console.log(pair);
}
// Prints:
//   [0, 98]
//   [1, 117]
//   [2, 102]
//   [3, 102]
//   [4, 101]
//   [5, 114]</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

// Log the entire contents of a `Buffer`.

const buf = Buffer.from(&#39;buffer&#39;);

for (const pair of buf.entries()) {
  console.log(pair);
}
// Prints:
//   [0, 98]
//   [1, 117]
//   [2, 102]
//   [3, 102]
//   [4, 101]
//   [5, 114]</code></pre>
    <h3 id="buf.equalsotherbuffer"><code>buf.equals(otherBuffer)</code></h3>
    <!-- YAML
added: v0.11.13
changes:
  - version: v8.0.0
    pr-url: https://github.com/nodejs/node/pull/10236
    description: The arguments can now be `Uint8Array`s.
-->
    <ul>
      <li>
        <code>otherBuffer</code> {Buffer|Uint8Array} A <code>Buffer</code> or
        <a
          href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array"
          ><code>Uint8Array</code></a
        >
        with which to compare <code>buf</code>.
      </li>
      <li>Returns: {boolean}</li>
    </ul>
    <p>
      Returns <code>true</code> if both <code>buf</code> and
      <code>otherBuffer</code> have exactly the same bytes,
      <code>false</code> otherwise. Equivalent to
      <a
        href="#buffer_buf_compare_target_targetstart_targetend_sourcestart_sourceend"
        ><code>buf.compare(otherBuffer) === 0</code></a
      >.
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

const buf1 = Buffer.from(&#39;ABC&#39;);
const buf2 = Buffer.from(&#39;414243&#39;, &#39;hex&#39;);
const buf3 = Buffer.from(&#39;ABCD&#39;);

console.log(buf1.equals(buf2));
// Prints: true
console.log(buf1.equals(buf3));
// Prints: false</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

const buf1 = Buffer.from(&#39;ABC&#39;);
const buf2 = Buffer.from(&#39;414243&#39;, &#39;hex&#39;);
const buf3 = Buffer.from(&#39;ABCD&#39;);

console.log(buf1.equals(buf2));
// Prints: true
console.log(buf1.equals(buf3));
// Prints: false</code></pre>
    <h3 id="buf.fillvalue-offset-end-encoding">
      <code>buf.fill(value[, offset[, end]][, encoding])</code>
    </h3>
    <!-- YAML
added: v0.5.0
changes:
  - version: v11.0.0
    pr-url: https://github.com/nodejs/node/pull/22969
    description: Throws `ERR_OUT_OF_RANGE` instead of `ERR_INDEX_OUT_OF_RANGE`.
  - version: v10.0.0
    pr-url: https://github.com/nodejs/node/pull/18790
    description: Negative `end` values throw an `ERR_INDEX_OUT_OF_RANGE` error.
  - version: v10.0.0
    pr-url: https://github.com/nodejs/node/pull/18129
    description: Attempting to fill a non-zero length buffer with a zero length
                 buffer triggers a thrown exception.
  - version: v10.0.0
    pr-url: https://github.com/nodejs/node/pull/17427
    description: Specifying an invalid string for `value` triggers a thrown
                 exception.
  - version: v5.7.0
    pr-url: https://github.com/nodejs/node/pull/4935
    description: The `encoding` parameter is supported now.
-->
    <ul>
      <li>
        <code>value</code> {string|Buffer|Uint8Array|integer} The value with
        which to fill <code>buf</code>.
      </li>
      <li>
        <code>offset</code> {integer} Number of bytes to skip before starting to
        fill <code>buf</code>. <strong>Default:</strong> <code>0</code>.
      </li>
      <li>
        <code>end</code> {integer} Where to stop filling <code>buf</code> (not
        inclusive). <strong>Default:</strong>
        <a href="#buffer_buf_length"><code>buf.length</code></a
        >.
      </li>
      <li>
        <code>encoding</code> {string} The encoding for <code>value</code> if
        <code>value</code> is a string. <strong>Default:</strong>
        <code>'utf8'</code>.
      </li>
      <li>Returns: {Buffer} A reference to <code>buf</code>.</li>
    </ul>
    <p>
      Fills <code>buf</code> with the specified <code>value</code>. If the
      <code>offset</code> and <code>end</code> are not given, the entire
      <code>buf</code> will be filled:
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

// Fill a `Buffer` with the ASCII character &#39;h&#39;.

const b = Buffer.allocUnsafe(50).fill(&#39;h&#39;);

console.log(b.toString());
// Prints: hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

// Fill a `Buffer` with the ASCII character &#39;h&#39;.

const b = Buffer.allocUnsafe(50).fill(&#39;h&#39;);

console.log(b.toString());
// Prints: hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh</code></pre>
    <p>
      <code>value</code> is coerced to a <code>uint32</code> value if it is not
      a string, <code>Buffer</code>, or integer. If the resulting integer is
      greater than <code>255</code> (decimal), <code>buf</code> will be filled
      with <code>value &amp; 255</code>.
    </p>
    <p>
      If the final write of a <code>fill()</code> operation falls on a
      multi-byte character, then only the bytes of that character that fit into
      <code>buf</code> are written:
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

// Fill a `Buffer` with character that takes up two bytes in UTF-8.

console.log(Buffer.allocUnsafe(5).fill(&#39;\u0222&#39;));
// Prints: &lt;Buffer c8 a2 c8 a2 c8&gt;</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

// Fill a `Buffer` with character that takes up two bytes in UTF-8.

console.log(Buffer.allocUnsafe(5).fill(&#39;\u0222&#39;));
// Prints: &lt;Buffer c8 a2 c8 a2 c8&gt;</code></pre>
    <p>
      If <code>value</code> contains invalid characters, it is truncated; if no
      valid fill data remains, an exception is thrown:
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

const buf = Buffer.allocUnsafe(5);

console.log(buf.fill(&#39;a&#39;));
// Prints: &lt;Buffer 61 61 61 61 61&gt;
console.log(buf.fill(&#39;aazz&#39;, &#39;hex&#39;));
// Prints: &lt;Buffer aa aa aa aa aa&gt;
console.log(buf.fill(&#39;zz&#39;, &#39;hex&#39;));
// Throws an exception.</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

const buf = Buffer.allocUnsafe(5);

console.log(buf.fill(&#39;a&#39;));
// Prints: &lt;Buffer 61 61 61 61 61&gt;
console.log(buf.fill(&#39;aazz&#39;, &#39;hex&#39;));
// Prints: &lt;Buffer aa aa aa aa aa&gt;
console.log(buf.fill(&#39;zz&#39;, &#39;hex&#39;));
// Throws an exception.</code></pre>
    <h3 id="buf.includesvalue-byteoffset-encoding">
      <code>buf.includes(value[, byteOffset][, encoding])</code>
    </h3>
    <!-- YAML
added: v5.3.0
-->
    <ul>
      <li>
        <code>value</code> {string|Buffer|Uint8Array|integer} What to search
        for.
      </li>
      <li>
        <code>byteOffset</code> {integer} Where to begin searching in
        <code>buf</code>. If negative, then offset is calculated from the end of
        <code>buf</code>. <strong>Default:</strong> <code>0</code>.
      </li>
      <li>
        <code>encoding</code> {string} If <code>value</code> is a string, this
        is its encoding. <strong>Default:</strong> <code>'utf8'</code>.
      </li>
      <li>
        Returns: {boolean} <code>true</code> if <code>value</code> was found in
        <code>buf</code>, <code>false</code> otherwise.
      </li>
    </ul>
    <p>
      Equivalent to
      <a href="#buffer_buf_indexof_value_byteoffset_encoding"
        ><code>buf.indexOf() !== -1</code></a
      >.
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

const buf = Buffer.from(&#39;this is a buffer&#39;);

console.log(buf.includes(&#39;this&#39;));
// Prints: true
console.log(buf.includes(&#39;is&#39;));
// Prints: true
console.log(buf.includes(Buffer.from(&#39;a buffer&#39;)));
// Prints: true
console.log(buf.includes(97));
// Prints: true (97 is the decimal ASCII value for &#39;a&#39;)
console.log(buf.includes(Buffer.from(&#39;a buffer example&#39;)));
// Prints: false
console.log(buf.includes(Buffer.from(&#39;a buffer example&#39;).slice(0, 8)));
// Prints: true
console.log(buf.includes(&#39;this&#39;, 4));
// Prints: false</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

const buf = Buffer.from(&#39;this is a buffer&#39;);

console.log(buf.includes(&#39;this&#39;));
// Prints: true
console.log(buf.includes(&#39;is&#39;));
// Prints: true
console.log(buf.includes(Buffer.from(&#39;a buffer&#39;)));
// Prints: true
console.log(buf.includes(97));
// Prints: true (97 is the decimal ASCII value for &#39;a&#39;)
console.log(buf.includes(Buffer.from(&#39;a buffer example&#39;)));
// Prints: false
console.log(buf.includes(Buffer.from(&#39;a buffer example&#39;).slice(0, 8)));
// Prints: true
console.log(buf.includes(&#39;this&#39;, 4));
// Prints: false</code></pre>
    <h3 id="buf.indexofvalue-byteoffset-encoding">
      <code>buf.indexOf(value[, byteOffset][, encoding])</code>
    </h3>
    <!-- YAML
added: v1.5.0
changes:
  - version: v8.0.0
    pr-url: https://github.com/nodejs/node/pull/10236
    description: The `value` can now be a `Uint8Array`.
  - version:
    - v5.7.0
    - v4.4.0
    pr-url: https://github.com/nodejs/node/pull/4803
    description: When `encoding` is being passed, the `byteOffset` parameter
                 is no longer required.
-->
    <ul>
      <li>
        <code>value</code> {string|Buffer|Uint8Array|integer} What to search
        for.
      </li>
      <li>
        <code>byteOffset</code> {integer} Where to begin searching in
        <code>buf</code>. If negative, then offset is calculated from the end of
        <code>buf</code>. <strong>Default:</strong> <code>0</code>.
      </li>
      <li>
        <code>encoding</code> {string} If <code>value</code> is a string, this
        is the encoding used to determine the binary representation of the
        string that will be searched for in <code>buf</code>.
        <strong>Default:</strong> <code>'utf8'</code>.
      </li>
      <li>
        Returns: {integer} The index of the first occurrence of
        <code>value</code> in <code>buf</code>, or <code>-1</code> if
        <code>buf</code> does not contain <code>value</code>.
      </li>
    </ul>
    <p>If <code>value</code> is:</p>
    <ul>
      <li>
        a string, <code>value</code> is interpreted according to the character
        encoding in <code>encoding</code>.
      </li>
      <li>
        a <code>Buffer</code> or
        <a
          href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array"
          ><code>Uint8Array</code></a
        >, <code>value</code> will be used in its entirety. To compare a partial
        <code>Buffer</code>, use
        <a href="#buffer_buf_slice_start_end"><code>buf.slice()</code></a
        >.
      </li>
      <li>
        a number, <code>value</code> will be interpreted as an unsigned 8-bit
        integer value between <code>0</code> and <code>255</code>.
      </li>
    </ul>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

const buf = Buffer.from(&#39;this is a buffer&#39;);

console.log(buf.indexOf(&#39;this&#39;));
// Prints: 0
console.log(buf.indexOf(&#39;is&#39;));
// Prints: 2
console.log(buf.indexOf(Buffer.from(&#39;a buffer&#39;)));
// Prints: 8
console.log(buf.indexOf(97));
// Prints: 8 (97 is the decimal ASCII value for &#39;a&#39;)
console.log(buf.indexOf(Buffer.from(&#39;a buffer example&#39;)));
// Prints: -1
console.log(buf.indexOf(Buffer.from(&#39;a buffer example&#39;).slice(0, 8)));
// Prints: 8

const utf16Buffer = Buffer.from(&#39;\u039a\u0391\u03a3\u03a3\u0395&#39;, &#39;utf16le&#39;);

console.log(utf16Buffer.indexOf(&#39;\u03a3&#39;, 0, &#39;utf16le&#39;));
// Prints: 4
console.log(utf16Buffer.indexOf(&#39;\u03a3&#39;, -4, &#39;utf16le&#39;));
// Prints: 6</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

const buf = Buffer.from(&#39;this is a buffer&#39;);

console.log(buf.indexOf(&#39;this&#39;));
// Prints: 0
console.log(buf.indexOf(&#39;is&#39;));
// Prints: 2
console.log(buf.indexOf(Buffer.from(&#39;a buffer&#39;)));
// Prints: 8
console.log(buf.indexOf(97));
// Prints: 8 (97 is the decimal ASCII value for &#39;a&#39;)
console.log(buf.indexOf(Buffer.from(&#39;a buffer example&#39;)));
// Prints: -1
console.log(buf.indexOf(Buffer.from(&#39;a buffer example&#39;).slice(0, 8)));
// Prints: 8

const utf16Buffer = Buffer.from(&#39;\u039a\u0391\u03a3\u03a3\u0395&#39;, &#39;utf16le&#39;);

console.log(utf16Buffer.indexOf(&#39;\u03a3&#39;, 0, &#39;utf16le&#39;));
// Prints: 4
console.log(utf16Buffer.indexOf(&#39;\u03a3&#39;, -4, &#39;utf16le&#39;));
// Prints: 6</code></pre>
    <p>
      If <code>value</code> is not a string, number, or <code>Buffer</code>,
      this method will throw a <code>TypeError</code>. If <code>value</code> is
      a number, it will be coerced to a valid byte value, an integer between 0
      and 255.
    </p>
    <p>
      If <code>byteOffset</code> is not a number, it will be coerced to a
      number. If the result of coercion is <code>NaN</code> or <code>0</code>,
      then the entire buffer will be searched. This behavior matches
      <a
        href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/indexOf"
        ><code>String.prototype.indexOf()</code></a
      >.
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

const b = Buffer.from(&#39;abcdef&#39;);

// Passing a value that&#39;s a number, but not a valid byte.
// Prints: 2, equivalent to searching for 99 or &#39;c&#39;.
console.log(b.indexOf(99.9));
console.log(b.indexOf(256 + 99));

// Passing a byteOffset that coerces to NaN or 0.
// Prints: 1, searching the whole buffer.
console.log(b.indexOf(&#39;b&#39;, undefined));
console.log(b.indexOf(&#39;b&#39;, {}));
console.log(b.indexOf(&#39;b&#39;, null));
console.log(b.indexOf(&#39;b&#39;, []));</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

const b = Buffer.from(&#39;abcdef&#39;);

// Passing a value that&#39;s a number, but not a valid byte.
// Prints: 2, equivalent to searching for 99 or &#39;c&#39;.
console.log(b.indexOf(99.9));
console.log(b.indexOf(256 + 99));

// Passing a byteOffset that coerces to NaN or 0.
// Prints: 1, searching the whole buffer.
console.log(b.indexOf(&#39;b&#39;, undefined));
console.log(b.indexOf(&#39;b&#39;, {}));
console.log(b.indexOf(&#39;b&#39;, null));
console.log(b.indexOf(&#39;b&#39;, []));</code></pre>
    <p>
      If <code>value</code> is an empty string or empty <code>Buffer</code> and
      <code>byteOffset</code> is less than <code>buf.length</code>,
      <code>byteOffset</code> will be returned. If <code>value</code> is empty
      and <code>byteOffset</code> is at least <code>buf.length</code>,
      <code>buf.length</code> will be returned.
    </p>
    <h3 id="buf.keys"><code>buf.keys()</code></h3>
    <!-- YAML
added: v1.1.0
-->
    <ul>
      <li>Returns: {Iterator}</li>
    </ul>
    <p>
      Creates and returns an
      <a
        href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols"
        >iterator</a
      >
      of <code>buf</code> keys (indices).
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

const buf = Buffer.from(&#39;buffer&#39;);

for (const key of buf.keys()) {
  console.log(key);
}
// Prints:
//   0
//   1
//   2
//   3
//   4
//   5</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

const buf = Buffer.from(&#39;buffer&#39;);

for (const key of buf.keys()) {
  console.log(key);
}
// Prints:
//   0
//   1
//   2
//   3
//   4
//   5</code></pre>
    <h3 id="buf.lastindexofvalue-byteoffset-encoding">
      <code>buf.lastIndexOf(value[, byteOffset][, encoding])</code>
    </h3>
    <!-- YAML
added: v6.0.0
changes:
  - version: v8.0.0
    pr-url: https://github.com/nodejs/node/pull/10236
    description: The `value` can now be a `Uint8Array`.
-->
    <ul>
      <li>
        <code>value</code> {string|Buffer|Uint8Array|integer} What to search
        for.
      </li>
      <li>
        <code>byteOffset</code> {integer} Where to begin searching in
        <code>buf</code>. If negative, then offset is calculated from the end of
        <code>buf</code>. <strong>Default:</strong> <code>buf.length - 1</code>.
      </li>
      <li>
        <code>encoding</code> {string} If <code>value</code> is a string, this
        is the encoding used to determine the binary representation of the
        string that will be searched for in <code>buf</code>.
        <strong>Default:</strong> <code>'utf8'</code>.
      </li>
      <li>
        Returns: {integer} The index of the last occurrence of
        <code>value</code> in <code>buf</code>, or <code>-1</code> if
        <code>buf</code> does not contain <code>value</code>.
      </li>
    </ul>
    <p>
      Identical to
      <a href="#buffer_buf_indexof_value_byteoffset_encoding"
        ><code>buf.indexOf()</code></a
      >, except the last occurrence of <code>value</code> is found rather than
      the first occurrence.
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

const buf = Buffer.from(&#39;this buffer is a buffer&#39;);

console.log(buf.lastIndexOf(&#39;this&#39;));
// Prints: 0
console.log(buf.lastIndexOf(&#39;buffer&#39;));
// Prints: 17
console.log(buf.lastIndexOf(Buffer.from(&#39;buffer&#39;)));
// Prints: 17
console.log(buf.lastIndexOf(97));
// Prints: 15 (97 is the decimal ASCII value for &#39;a&#39;)
console.log(buf.lastIndexOf(Buffer.from(&#39;yolo&#39;)));
// Prints: -1
console.log(buf.lastIndexOf(&#39;buffer&#39;, 5));
// Prints: 5
console.log(buf.lastIndexOf(&#39;buffer&#39;, 4));
// Prints: -1

const utf16Buffer = Buffer.from(&#39;\u039a\u0391\u03a3\u03a3\u0395&#39;, &#39;utf16le&#39;);

console.log(utf16Buffer.lastIndexOf(&#39;\u03a3&#39;, undefined, &#39;utf16le&#39;));
// Prints: 6
console.log(utf16Buffer.lastIndexOf(&#39;\u03a3&#39;, -5, &#39;utf16le&#39;));
// Prints: 4</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

const buf = Buffer.from(&#39;this buffer is a buffer&#39;);

console.log(buf.lastIndexOf(&#39;this&#39;));
// Prints: 0
console.log(buf.lastIndexOf(&#39;buffer&#39;));
// Prints: 17
console.log(buf.lastIndexOf(Buffer.from(&#39;buffer&#39;)));
// Prints: 17
console.log(buf.lastIndexOf(97));
// Prints: 15 (97 is the decimal ASCII value for &#39;a&#39;)
console.log(buf.lastIndexOf(Buffer.from(&#39;yolo&#39;)));
// Prints: -1
console.log(buf.lastIndexOf(&#39;buffer&#39;, 5));
// Prints: 5
console.log(buf.lastIndexOf(&#39;buffer&#39;, 4));
// Prints: -1

const utf16Buffer = Buffer.from(&#39;\u039a\u0391\u03a3\u03a3\u0395&#39;, &#39;utf16le&#39;);

console.log(utf16Buffer.lastIndexOf(&#39;\u03a3&#39;, undefined, &#39;utf16le&#39;));
// Prints: 6
console.log(utf16Buffer.lastIndexOf(&#39;\u03a3&#39;, -5, &#39;utf16le&#39;));
// Prints: 4</code></pre>
    <p>
      If <code>value</code> is not a string, number, or <code>Buffer</code>,
      this method will throw a <code>TypeError</code>. If <code>value</code> is
      a number, it will be coerced to a valid byte value, an integer between 0
      and 255.
    </p>
    <p>
      If <code>byteOffset</code> is not a number, it will be coerced to a
      number. Any arguments that coerce to <code>NaN</code>, like
      <code>{}</code> or <code>undefined</code>, will search the whole buffer.
      This behavior matches
      <a
        href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/lastIndexOf"
        ><code>String.prototype.lastIndexOf()</code></a
      >.
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

const b = Buffer.from(&#39;abcdef&#39;);

// Passing a value that&#39;s a number, but not a valid byte.
// Prints: 2, equivalent to searching for 99 or &#39;c&#39;.
console.log(b.lastIndexOf(99.9));
console.log(b.lastIndexOf(256 + 99));

// Passing a byteOffset that coerces to NaN.
// Prints: 1, searching the whole buffer.
console.log(b.lastIndexOf(&#39;b&#39;, undefined));
console.log(b.lastIndexOf(&#39;b&#39;, {}));

// Passing a byteOffset that coerces to 0.
// Prints: -1, equivalent to passing 0.
console.log(b.lastIndexOf(&#39;b&#39;, null));
console.log(b.lastIndexOf(&#39;b&#39;, []));</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

const b = Buffer.from(&#39;abcdef&#39;);

// Passing a value that&#39;s a number, but not a valid byte.
// Prints: 2, equivalent to searching for 99 or &#39;c&#39;.
console.log(b.lastIndexOf(99.9));
console.log(b.lastIndexOf(256 + 99));

// Passing a byteOffset that coerces to NaN.
// Prints: 1, searching the whole buffer.
console.log(b.lastIndexOf(&#39;b&#39;, undefined));
console.log(b.lastIndexOf(&#39;b&#39;, {}));

// Passing a byteOffset that coerces to 0.
// Prints: -1, equivalent to passing 0.
console.log(b.lastIndexOf(&#39;b&#39;, null));
console.log(b.lastIndexOf(&#39;b&#39;, []));</code></pre>
    <p>
      If <code>value</code> is an empty string or empty <code>Buffer</code>,
      <code>byteOffset</code> will be returned.
    </p>
    <h3 id="buf.length"><code>buf.length</code></h3>
    <!-- YAML
added: v0.1.90
-->
    <ul>
      <li>{integer}</li>
    </ul>
    <p>Returns the number of bytes in <code>buf</code>.</p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

// Create a `Buffer` and write a shorter string to it using UTF-8.

const buf = Buffer.alloc(1234);

console.log(buf.length);
// Prints: 1234

buf.write(&#39;some string&#39;, 0, &#39;utf8&#39;);

console.log(buf.length);
// Prints: 1234</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

// Create a `Buffer` and write a shorter string to it using UTF-8.

const buf = Buffer.alloc(1234);

console.log(buf.length);
// Prints: 1234

buf.write(&#39;some string&#39;, 0, &#39;utf8&#39;);

console.log(buf.length);
// Prints: 1234</code></pre>
    <h3 id="buf.parent"><code>buf.parent</code></h3>
    <!-- YAML
deprecated: v8.0.0
-->
    <blockquote>
      <p>
        Stability: 0 - Deprecated: Use
        <a href="#buffer_buf_buffer"><code>buf.buffer</code></a> instead.
      </p>
    </blockquote>
    <p>
      The <code>buf.parent</code> property is a deprecated alias for
      <code>buf.buffer</code>.
    </p>
    <h3 id="buf.readbigint64beoffset">
      <code>buf.readBigInt64BE([offset])</code>
    </h3>
    <!-- YAML
added:
 - v12.0.0
 - v10.20.0
-->
    <ul>
      <li>
        <code>offset</code> {integer} Number of bytes to skip before starting to
        read. Must satisfy: <code>0 &lt;= offset &lt;= buf.length - 8</code>.
        <strong>Default:</strong> <code>0</code>.
      </li>
      <li>Returns: {bigint}</li>
    </ul>
    <p>
      Reads a signed, big-endian 64-bit integer from <code>buf</code> at the
      specified <code>offset</code>.
    </p>
    <p>
      Integers read from a <code>Buffer</code> are interpreted as two’s
      complement signed values.
    </p>
    <h3 id="buf.readbigint64leoffset">
      <code>buf.readBigInt64LE([offset])</code>
    </h3>
    <!-- YAML
added:
 - v12.0.0
 - v10.20.0
-->
    <ul>
      <li>
        <code>offset</code> {integer} Number of bytes to skip before starting to
        read. Must satisfy: <code>0 &lt;= offset &lt;= buf.length - 8</code>.
        <strong>Default:</strong> <code>0</code>.
      </li>
      <li>Returns: {bigint}</li>
    </ul>
    <p>
      Reads a signed, little-endian 64-bit integer from <code>buf</code> at the
      specified <code>offset</code>.
    </p>
    <p>
      Integers read from a <code>Buffer</code> are interpreted as two’s
      complement signed values.
    </p>
    <h3 id="buf.readbiguint64beoffset">
      <code>buf.readBigUInt64BE([offset])</code>
    </h3>
    <!-- YAML
added:
 - v12.0.0
 - v10.20.0
changes:
  - version:
    - v14.10.0
    - v12.19.0
    pr-url: https://github.com/nodejs/node/pull/34960
    description: This function is also available as `buf.readBigUint64BE()`.
-->
    <ul>
      <li>
        <code>offset</code> {integer} Number of bytes to skip before starting to
        read. Must satisfy: <code>0 &lt;= offset &lt;= buf.length - 8</code>.
        <strong>Default:</strong> <code>0</code>.
      </li>
      <li>Returns: {bigint}</li>
    </ul>
    <p>
      Reads an unsigned, big-endian 64-bit integer from <code>buf</code> at the
      specified <code>offset</code>.
    </p>
    <p>
      This function is also available under the
      <code>readBigUint64BE</code> alias.
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

const buf = Buffer.from([0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff]);

console.log(buf.readBigUInt64BE(0));
// Prints: 4294967295n</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

const buf = Buffer.from([0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff]);

console.log(buf.readBigUInt64BE(0));
// Prints: 4294967295n</code></pre>
    <h3 id="buf.readbiguint64leoffset">
      <code>buf.readBigUInt64LE([offset])</code>
    </h3>
    <!-- YAML
added:
 - v12.0.0
 - v10.20.0
changes:
  - version:
    - v14.10.0
    - v12.19.0
    pr-url: https://github.com/nodejs/node/pull/34960
    description: This function is also available as `buf.readBigUint64LE()`.
-->
    <ul>
      <li>
        <code>offset</code> {integer} Number of bytes to skip before starting to
        read. Must satisfy: <code>0 &lt;= offset &lt;= buf.length - 8</code>.
        <strong>Default:</strong> <code>0</code>.
      </li>
      <li>Returns: {bigint}</li>
    </ul>
    <p>
      Reads an unsigned, little-endian 64-bit integer from <code>buf</code> at
      the specified <code>offset</code>.
    </p>
    <p>
      This function is also available under the
      <code>readBigUint64LE</code> alias.
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

const buf = Buffer.from([0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff]);

console.log(buf.readBigUInt64LE(0));
// Prints: 18446744069414584320n</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

const buf = Buffer.from([0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff]);

console.log(buf.readBigUInt64LE(0));
// Prints: 18446744069414584320n</code></pre>
    <h3 id="buf.readdoublebeoffset"><code>buf.readDoubleBE([offset])</code></h3>
    <!-- YAML
added: v0.11.15
changes:
  - version: v10.0.0
    pr-url: https://github.com/nodejs/node/pull/18395
    description: Removed `noAssert` and no implicit coercion of the offset
                 to `uint32` anymore.
-->
    <ul>
      <li>
        <code>offset</code> {integer} Number of bytes to skip before starting to
        read. Must satisfy <code>0 &lt;= offset &lt;= buf.length - 8</code>.
        <strong>Default:</strong> <code>0</code>.
      </li>
      <li>Returns: {number}</li>
    </ul>
    <p>
      Reads a 64-bit, big-endian double from <code>buf</code> at the specified
      <code>offset</code>.
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

const buf = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8]);

console.log(buf.readDoubleBE(0));
// Prints: 8.20788039913184e-304</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

const buf = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8]);

console.log(buf.readDoubleBE(0));
// Prints: 8.20788039913184e-304</code></pre>
    <h3 id="buf.readdoubleleoffset"><code>buf.readDoubleLE([offset])</code></h3>
    <!-- YAML
added: v0.11.15
changes:
  - version: v10.0.0
    pr-url: https://github.com/nodejs/node/pull/18395
    description: Removed `noAssert` and no implicit coercion of the offset
                 to `uint32` anymore.
-->
    <ul>
      <li>
        <code>offset</code> {integer} Number of bytes to skip before starting to
        read. Must satisfy <code>0 &lt;= offset &lt;= buf.length - 8</code>.
        <strong>Default:</strong> <code>0</code>.
      </li>
      <li>Returns: {number}</li>
    </ul>
    <p>
      Reads a 64-bit, little-endian double from <code>buf</code> at the
      specified <code>offset</code>.
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

const buf = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8]);

console.log(buf.readDoubleLE(0));
// Prints: 5.447603722011605e-270
console.log(buf.readDoubleLE(1));
// Throws ERR_OUT_OF_RANGE.</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

const buf = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8]);

console.log(buf.readDoubleLE(0));
// Prints: 5.447603722011605e-270
console.log(buf.readDoubleLE(1));
// Throws ERR_OUT_OF_RANGE.</code></pre>
    <h3 id="buf.readfloatbeoffset"><code>buf.readFloatBE([offset])</code></h3>
    <!-- YAML
added: v0.11.15
changes:
  - version: v10.0.0
    pr-url: https://github.com/nodejs/node/pull/18395
    description: Removed `noAssert` and no implicit coercion of the offset
                 to `uint32` anymore.
-->
    <ul>
      <li>
        <code>offset</code> {integer} Number of bytes to skip before starting to
        read. Must satisfy <code>0 &lt;= offset &lt;= buf.length - 4</code>.
        <strong>Default:</strong> <code>0</code>.
      </li>
      <li>Returns: {number}</li>
    </ul>
    <p>
      Reads a 32-bit, big-endian float from <code>buf</code> at the specified
      <code>offset</code>.
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

const buf = Buffer.from([1, 2, 3, 4]);

console.log(buf.readFloatBE(0));
// Prints: 2.387939260590663e-38</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

const buf = Buffer.from([1, 2, 3, 4]);

console.log(buf.readFloatBE(0));
// Prints: 2.387939260590663e-38</code></pre>
    <h3 id="buf.readfloatleoffset"><code>buf.readFloatLE([offset])</code></h3>
    <!-- YAML
added: v0.11.15
changes:
  - version: v10.0.0
    pr-url: https://github.com/nodejs/node/pull/18395
    description: Removed `noAssert` and no implicit coercion of the offset
                 to `uint32` anymore.
-->
    <ul>
      <li>
        <code>offset</code> {integer} Number of bytes to skip before starting to
        read. Must satisfy <code>0 &lt;= offset &lt;= buf.length - 4</code>.
        <strong>Default:</strong> <code>0</code>.
      </li>
      <li>Returns: {number}</li>
    </ul>
    <p>
      Reads a 32-bit, little-endian float from <code>buf</code> at the specified
      <code>offset</code>.
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

const buf = Buffer.from([1, 2, 3, 4]);

console.log(buf.readFloatLE(0));
// Prints: 1.539989614439558e-36
console.log(buf.readFloatLE(1));
// Throws ERR_OUT_OF_RANGE.</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

const buf = Buffer.from([1, 2, 3, 4]);

console.log(buf.readFloatLE(0));
// Prints: 1.539989614439558e-36
console.log(buf.readFloatLE(1));
// Throws ERR_OUT_OF_RANGE.</code></pre>
    <h3 id="buf.readint8offset"><code>buf.readInt8([offset])</code></h3>
    <!-- YAML
added: v0.5.0
changes:
  - version: v10.0.0
    pr-url: https://github.com/nodejs/node/pull/18395
    description: Removed `noAssert` and no implicit coercion of the offset
                 to `uint32` anymore.
-->
    <ul>
      <li>
        <code>offset</code> {integer} Number of bytes to skip before starting to
        read. Must satisfy <code>0 &lt;= offset &lt;= buf.length - 1</code>.
        <strong>Default:</strong> <code>0</code>.
      </li>
      <li>Returns: {integer}</li>
    </ul>
    <p>
      Reads a signed 8-bit integer from <code>buf</code> at the specified
      <code>offset</code>.
    </p>
    <p>
      Integers read from a <code>Buffer</code> are interpreted as two’s
      complement signed values.
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

const buf = Buffer.from([-1, 5]);

console.log(buf.readInt8(0));
// Prints: -1
console.log(buf.readInt8(1));
// Prints: 5
console.log(buf.readInt8(2));
// Throws ERR_OUT_OF_RANGE.</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

const buf = Buffer.from([-1, 5]);

console.log(buf.readInt8(0));
// Prints: -1
console.log(buf.readInt8(1));
// Prints: 5
console.log(buf.readInt8(2));
// Throws ERR_OUT_OF_RANGE.</code></pre>
    <h3 id="buf.readint16beoffset"><code>buf.readInt16BE([offset])</code></h3>
    <!-- YAML
added: v0.5.5
changes:
  - version: v10.0.0
    pr-url: https://github.com/nodejs/node/pull/18395
    description: Removed `noAssert` and no implicit coercion of the offset
                 to `uint32` anymore.
-->
    <ul>
      <li>
        <code>offset</code> {integer} Number of bytes to skip before starting to
        read. Must satisfy <code>0 &lt;= offset &lt;= buf.length - 2</code>.
        <strong>Default:</strong> <code>0</code>.
      </li>
      <li>Returns: {integer}</li>
    </ul>
    <p>
      Reads a signed, big-endian 16-bit integer from <code>buf</code> at the
      specified <code>offset</code>.
    </p>
    <p>
      Integers read from a <code>Buffer</code> are interpreted as two’s
      complement signed values.
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

const buf = Buffer.from([0, 5]);

console.log(buf.readInt16BE(0));
// Prints: 5</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

const buf = Buffer.from([0, 5]);

console.log(buf.readInt16BE(0));
// Prints: 5</code></pre>
    <h3 id="buf.readint16leoffset"><code>buf.readInt16LE([offset])</code></h3>
    <!-- YAML
added: v0.5.5
changes:
  - version: v10.0.0
    pr-url: https://github.com/nodejs/node/pull/18395
    description: Removed `noAssert` and no implicit coercion of the offset
                 to `uint32` anymore.
-->
    <ul>
      <li>
        <code>offset</code> {integer} Number of bytes to skip before starting to
        read. Must satisfy <code>0 &lt;= offset &lt;= buf.length - 2</code>.
        <strong>Default:</strong> <code>0</code>.
      </li>
      <li>Returns: {integer}</li>
    </ul>
    <p>
      Reads a signed, little-endian 16-bit integer from <code>buf</code> at the
      specified <code>offset</code>.
    </p>
    <p>
      Integers read from a <code>Buffer</code> are interpreted as two’s
      complement signed values.
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

const buf = Buffer.from([0, 5]);

console.log(buf.readInt16LE(0));
// Prints: 1280
console.log(buf.readInt16LE(1));
// Throws ERR_OUT_OF_RANGE.</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

const buf = Buffer.from([0, 5]);

console.log(buf.readInt16LE(0));
// Prints: 1280
console.log(buf.readInt16LE(1));
// Throws ERR_OUT_OF_RANGE.</code></pre>
    <h3 id="buf.readint32beoffset"><code>buf.readInt32BE([offset])</code></h3>
    <!-- YAML
added: v0.5.5
changes:
  - version: v10.0.0
    pr-url: https://github.com/nodejs/node/pull/18395
    description: Removed `noAssert` and no implicit coercion of the offset
                 to `uint32` anymore.
-->
    <ul>
      <li>
        <code>offset</code> {integer} Number of bytes to skip before starting to
        read. Must satisfy <code>0 &lt;= offset &lt;= buf.length - 4</code>.
        <strong>Default:</strong> <code>0</code>.
      </li>
      <li>Returns: {integer}</li>
    </ul>
    <p>
      Reads a signed, big-endian 32-bit integer from <code>buf</code> at the
      specified <code>offset</code>.
    </p>
    <p>
      Integers read from a <code>Buffer</code> are interpreted as two’s
      complement signed values.
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

const buf = Buffer.from([0, 0, 0, 5]);

console.log(buf.readInt32BE(0));
// Prints: 5</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

const buf = Buffer.from([0, 0, 0, 5]);

console.log(buf.readInt32BE(0));
// Prints: 5</code></pre>
    <h3 id="buf.readint32leoffset"><code>buf.readInt32LE([offset])</code></h3>
    <!-- YAML
added: v0.5.5
changes:
  - version: v10.0.0
    pr-url: https://github.com/nodejs/node/pull/18395
    description: Removed `noAssert` and no implicit coercion of the offset
                 to `uint32` anymore.
-->
    <ul>
      <li>
        <code>offset</code> {integer} Number of bytes to skip before starting to
        read. Must satisfy <code>0 &lt;= offset &lt;= buf.length - 4</code>.
        <strong>Default:</strong> <code>0</code>.
      </li>
      <li>Returns: {integer}</li>
    </ul>
    <p>
      Reads a signed, little-endian 32-bit integer from <code>buf</code> at the
      specified <code>offset</code>.
    </p>
    <p>
      Integers read from a <code>Buffer</code> are interpreted as two’s
      complement signed values.
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

const buf = Buffer.from([0, 0, 0, 5]);

console.log(buf.readInt32LE(0));
// Prints: 83886080
console.log(buf.readInt32LE(1));
// Throws ERR_OUT_OF_RANGE.</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

const buf = Buffer.from([0, 0, 0, 5]);

console.log(buf.readInt32LE(0));
// Prints: 83886080
console.log(buf.readInt32LE(1));
// Throws ERR_OUT_OF_RANGE.</code></pre>
    <h3 id="buf.readintbeoffset-bytelength">
      <code>buf.readIntBE(offset, byteLength)</code>
    </h3>
    <!-- YAML
added: v0.11.15
changes:
  - version: v10.0.0
    pr-url: https://github.com/nodejs/node/pull/18395
    description: Removed `noAssert` and no implicit coercion of the offset
                 and `byteLength` to `uint32` anymore.
-->
    <ul>
      <li>
        <code>offset</code> {integer} Number of bytes to skip before starting to
        read. Must satisfy
        <code>0 &lt;= offset &lt;= buf.length - byteLength</code>.
      </li>
      <li>
        <code>byteLength</code> {integer} Number of bytes to read. Must satisfy
        <code>0 &lt; byteLength &lt;= 6</code>.
      </li>
      <li>Returns: {integer}</li>
    </ul>
    <p>
      Reads <code>byteLength</code> number of bytes from <code>buf</code> at the
      specified <code>offset</code> and interprets the result as a big-endian,
      two’s complement signed value supporting up to 48 bits of accuracy.
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

const buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);

console.log(buf.readIntBE(0, 6).toString(16));
// Prints: 1234567890ab
console.log(buf.readIntBE(1, 6).toString(16));
// Throws ERR_OUT_OF_RANGE.
console.log(buf.readIntBE(1, 0).toString(16));
// Throws ERR_OUT_OF_RANGE.</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

const buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);

console.log(buf.readIntBE(0, 6).toString(16));
// Prints: 1234567890ab
console.log(buf.readIntBE(1, 6).toString(16));
// Throws ERR_OUT_OF_RANGE.
console.log(buf.readIntBE(1, 0).toString(16));
// Throws ERR_OUT_OF_RANGE.</code></pre>
    <h3 id="buf.readintleoffset-bytelength">
      <code>buf.readIntLE(offset, byteLength)</code>
    </h3>
    <!-- YAML
added: v0.11.15
changes:
  - version: v10.0.0
    pr-url: https://github.com/nodejs/node/pull/18395
    description: Removed `noAssert` and no implicit coercion of the offset
                 and `byteLength` to `uint32` anymore.
-->
    <ul>
      <li>
        <code>offset</code> {integer} Number of bytes to skip before starting to
        read. Must satisfy
        <code>0 &lt;= offset &lt;= buf.length - byteLength</code>.
      </li>
      <li>
        <code>byteLength</code> {integer} Number of bytes to read. Must satisfy
        <code>0 &lt; byteLength &lt;= 6</code>.
      </li>
      <li>Returns: {integer}</li>
    </ul>
    <p>
      Reads <code>byteLength</code> number of bytes from <code>buf</code> at the
      specified <code>offset</code> and interprets the result as a
      little-endian, two’s complement signed value supporting up to 48 bits of
      accuracy.
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

const buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);

console.log(buf.readIntLE(0, 6).toString(16));
// Prints: -546f87a9cbee</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

const buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);

console.log(buf.readIntLE(0, 6).toString(16));
// Prints: -546f87a9cbee</code></pre>
    <h3 id="buf.readuint8offset"><code>buf.readUInt8([offset])</code></h3>
    <!-- YAML
added: v0.5.0
changes:
  - version:
    - v14.9.0
    - v12.19.0
    pr-url: https://github.com/nodejs/node/pull/34729
    description: This function is also available as `buf.readUint8()`.
  - version: v10.0.0
    pr-url: https://github.com/nodejs/node/pull/18395
    description: Removed `noAssert` and no implicit coercion of the offset
                 to `uint32` anymore.
-->
    <ul>
      <li>
        <code>offset</code> {integer} Number of bytes to skip before starting to
        read. Must satisfy <code>0 &lt;= offset &lt;= buf.length - 1</code>.
        <strong>Default:</strong> <code>0</code>.
      </li>
      <li>Returns: {integer}</li>
    </ul>
    <p>
      Reads an unsigned 8-bit integer from <code>buf</code> at the specified
      <code>offset</code>.
    </p>
    <p>
      This function is also available under the <code>readUint8</code> alias.
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

const buf = Buffer.from([1, -2]);

console.log(buf.readUInt8(0));
// Prints: 1
console.log(buf.readUInt8(1));
// Prints: 254
console.log(buf.readUInt8(2));
// Throws ERR_OUT_OF_RANGE.</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

const buf = Buffer.from([1, -2]);

console.log(buf.readUInt8(0));
// Prints: 1
console.log(buf.readUInt8(1));
// Prints: 254
console.log(buf.readUInt8(2));
// Throws ERR_OUT_OF_RANGE.</code></pre>
    <h3 id="buf.readuint16beoffset"><code>buf.readUInt16BE([offset])</code></h3>
    <!-- YAML
added: v0.5.5
changes:
  - version:
    - v14.9.0
    - v12.19.0
    pr-url: https://github.com/nodejs/node/pull/34729
    description: This function is also available as `buf.readUint16BE()`.
  - version: v10.0.0
    pr-url: https://github.com/nodejs/node/pull/18395
    description: Removed `noAssert` and no implicit coercion of the offset
                 to `uint32` anymore.
-->
    <ul>
      <li>
        <code>offset</code> {integer} Number of bytes to skip before starting to
        read. Must satisfy <code>0 &lt;= offset &lt;= buf.length - 2</code>.
        <strong>Default:</strong> <code>0</code>.
      </li>
      <li>Returns: {integer}</li>
    </ul>
    <p>
      Reads an unsigned, big-endian 16-bit integer from <code>buf</code> at the
      specified <code>offset</code>.
    </p>
    <p>
      This function is also available under the <code>readUint16BE</code> alias.
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

const buf = Buffer.from([0x12, 0x34, 0x56]);

console.log(buf.readUInt16BE(0).toString(16));
// Prints: 1234
console.log(buf.readUInt16BE(1).toString(16));
// Prints: 3456</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

const buf = Buffer.from([0x12, 0x34, 0x56]);

console.log(buf.readUInt16BE(0).toString(16));
// Prints: 1234
console.log(buf.readUInt16BE(1).toString(16));
// Prints: 3456</code></pre>
    <h3 id="buf.readuint16leoffset"><code>buf.readUInt16LE([offset])</code></h3>
    <!-- YAML
added: v0.5.5
changes:
  - version:
    - v14.9.0
    - v12.19.0
    pr-url: https://github.com/nodejs/node/pull/34729
    description: This function is also available as `buf.readUint16LE()`.
  - version: v10.0.0
    pr-url: https://github.com/nodejs/node/pull/18395
    description: Removed `noAssert` and no implicit coercion of the offset
                 to `uint32` anymore.
-->
    <ul>
      <li>
        <code>offset</code> {integer} Number of bytes to skip before starting to
        read. Must satisfy <code>0 &lt;= offset &lt;= buf.length - 2</code>.
        <strong>Default:</strong> <code>0</code>.
      </li>
      <li>Returns: {integer}</li>
    </ul>
    <p>
      Reads an unsigned, little-endian 16-bit integer from <code>buf</code> at
      the specified <code>offset</code>.
    </p>
    <p>
      This function is also available under the <code>readUint16LE</code> alias.
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

const buf = Buffer.from([0x12, 0x34, 0x56]);

console.log(buf.readUInt16LE(0).toString(16));
// Prints: 3412
console.log(buf.readUInt16LE(1).toString(16));
// Prints: 5634
console.log(buf.readUInt16LE(2).toString(16));
// Throws ERR_OUT_OF_RANGE.</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

const buf = Buffer.from([0x12, 0x34, 0x56]);

console.log(buf.readUInt16LE(0).toString(16));
// Prints: 3412
console.log(buf.readUInt16LE(1).toString(16));
// Prints: 5634
console.log(buf.readUInt16LE(2).toString(16));
// Throws ERR_OUT_OF_RANGE.</code></pre>
    <h3 id="buf.readuint32beoffset"><code>buf.readUInt32BE([offset])</code></h3>
    <!-- YAML
added: v0.5.5
changes:
  - version:
    - v14.9.0
    - v12.19.0
    pr-url: https://github.com/nodejs/node/pull/34729
    description: This function is also available as `buf.readUint32BE()`.
  - version: v10.0.0
    pr-url: https://github.com/nodejs/node/pull/18395
    description: Removed `noAssert` and no implicit coercion of the offset
                 to `uint32` anymore.
-->
    <ul>
      <li>
        <code>offset</code> {integer} Number of bytes to skip before starting to
        read. Must satisfy <code>0 &lt;= offset &lt;= buf.length - 4</code>.
        <strong>Default:</strong> <code>0</code>.
      </li>
      <li>Returns: {integer}</li>
    </ul>
    <p>
      Reads an unsigned, big-endian 32-bit integer from <code>buf</code> at the
      specified <code>offset</code>.
    </p>
    <p>
      This function is also available under the <code>readUint32BE</code> alias.
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

const buf = Buffer.from([0x12, 0x34, 0x56, 0x78]);

console.log(buf.readUInt32BE(0).toString(16));
// Prints: 12345678</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

const buf = Buffer.from([0x12, 0x34, 0x56, 0x78]);

console.log(buf.readUInt32BE(0).toString(16));
// Prints: 12345678</code></pre>
    <h3 id="buf.readuint32leoffset"><code>buf.readUInt32LE([offset])</code></h3>
    <!-- YAML
added: v0.5.5
changes:
  - version:
    - v14.9.0
    - v12.19.0
    pr-url: https://github.com/nodejs/node/pull/34729
    description: This function is also available as `buf.readUint32LE()`.
  - version: v10.0.0
    pr-url: https://github.com/nodejs/node/pull/18395
    description: Removed `noAssert` and no implicit coercion of the offset
                 to `uint32` anymore.
-->
    <ul>
      <li>
        <code>offset</code> {integer} Number of bytes to skip before starting to
        read. Must satisfy <code>0 &lt;= offset &lt;= buf.length - 4</code>.
        <strong>Default:</strong> <code>0</code>.
      </li>
      <li>Returns: {integer}</li>
    </ul>
    <p>
      Reads an unsigned, little-endian 32-bit integer from <code>buf</code> at
      the specified <code>offset</code>.
    </p>
    <p>
      This function is also available under the <code>readUint32LE</code> alias.
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

const buf = Buffer.from([0x12, 0x34, 0x56, 0x78]);

console.log(buf.readUInt32LE(0).toString(16));
// Prints: 78563412
console.log(buf.readUInt32LE(1).toString(16));
// Throws ERR_OUT_OF_RANGE.</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

const buf = Buffer.from([0x12, 0x34, 0x56, 0x78]);

console.log(buf.readUInt32LE(0).toString(16));
// Prints: 78563412
console.log(buf.readUInt32LE(1).toString(16));
// Throws ERR_OUT_OF_RANGE.</code></pre>
    <h3 id="buf.readuintbeoffset-bytelength">
      <code>buf.readUIntBE(offset, byteLength)</code>
    </h3>
    <!-- YAML
added: v0.11.15
changes:
  - version:
    - v14.9.0
    - v12.19.0
    pr-url: https://github.com/nodejs/node/pull/34729
    description: This function is also available as `buf.readUintBE()`.
  - version: v10.0.0
    pr-url: https://github.com/nodejs/node/pull/18395
    description: Removed `noAssert` and no implicit coercion of the offset
                 and `byteLength` to `uint32` anymore.
-->
    <ul>
      <li>
        <code>offset</code> {integer} Number of bytes to skip before starting to
        read. Must satisfy
        <code>0 &lt;= offset &lt;= buf.length - byteLength</code>.
      </li>
      <li>
        <code>byteLength</code> {integer} Number of bytes to read. Must satisfy
        <code>0 &lt; byteLength &lt;= 6</code>.
      </li>
      <li>Returns: {integer}</li>
    </ul>
    <p>
      Reads <code>byteLength</code> number of bytes from <code>buf</code> at the
      specified <code>offset</code> and interprets the result as an unsigned
      big-endian integer supporting up to 48 bits of accuracy.
    </p>
    <p>
      This function is also available under the <code>readUintBE</code> alias.
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

const buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);

console.log(buf.readUIntBE(0, 6).toString(16));
// Prints: 1234567890ab
console.log(buf.readUIntBE(1, 6).toString(16));
// Throws ERR_OUT_OF_RANGE.</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

const buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);

console.log(buf.readUIntBE(0, 6).toString(16));
// Prints: 1234567890ab
console.log(buf.readUIntBE(1, 6).toString(16));
// Throws ERR_OUT_OF_RANGE.</code></pre>
    <h3 id="buf.readuintleoffset-bytelength">
      <code>buf.readUIntLE(offset, byteLength)</code>
    </h3>
    <!-- YAML
added: v0.11.15
changes:
  - version:
    - v14.9.0
    - v12.19.0
    pr-url: https://github.com/nodejs/node/pull/34729
    description: This function is also available as `buf.readUintLE()`.
  - version: v10.0.0
    pr-url: https://github.com/nodejs/node/pull/18395
    description: Removed `noAssert` and no implicit coercion of the offset
                 and `byteLength` to `uint32` anymore.
-->
    <ul>
      <li>
        <code>offset</code> {integer} Number of bytes to skip before starting to
        read. Must satisfy
        <code>0 &lt;= offset &lt;= buf.length - byteLength</code>.
      </li>
      <li>
        <code>byteLength</code> {integer} Number of bytes to read. Must satisfy
        <code>0 &lt; byteLength &lt;= 6</code>.
      </li>
      <li>Returns: {integer}</li>
    </ul>
    <p>
      Reads <code>byteLength</code> number of bytes from <code>buf</code> at the
      specified <code>offset</code> and interprets the result as an unsigned,
      little-endian integer supporting up to 48 bits of accuracy.
    </p>
    <p>
      This function is also available under the <code>readUintLE</code> alias.
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

const buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);

console.log(buf.readUIntLE(0, 6).toString(16));
// Prints: ab9078563412</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

const buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);

console.log(buf.readUIntLE(0, 6).toString(16));
// Prints: ab9078563412</code></pre>
    <h3 id="buf.subarraystart-end">
      <code>buf.subarray([start[, end]])</code>
    </h3>
    <!-- YAML
added: v3.0.0
-->
    <ul>
      <li>
        <code>start</code> {integer} Where the new <code>Buffer</code> will
        start. <strong>Default:</strong> <code>0</code>.
      </li>
      <li>
        <code>end</code> {integer} Where the new <code>Buffer</code> will end
        (not inclusive). <strong>Default:</strong>
        <a href="#buffer_buf_length"><code>buf.length</code></a
        >.
      </li>
      <li>Returns: {Buffer}</li>
    </ul>
    <p>
      Returns a new <code>Buffer</code> that references the same memory as the
      original, but offset and cropped by the <code>start</code> and
      <code>end</code> indices.
    </p>
    <p>
      Specifying <code>end</code> greater than
      <a href="#buffer_buf_length"><code>buf.length</code></a> will return the
      same result as that of <code>end</code> equal to
      <a href="#buffer_buf_length"><code>buf.length</code></a
      >.
    </p>
    <p>
      This method is inherited from
      <a
        href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/subarray"
        ><code>TypedArray.prototype.subarray()</code></a
      >.
    </p>
    <p>
      Modifying the new <code>Buffer</code> slice will modify the memory in the
      original <code>Buffer</code> because the allocated memory of the two
      objects overlap.
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

// Create a `Buffer` with the ASCII alphabet, take a slice, and modify one byte
// from the original `Buffer`.

const buf1 = Buffer.allocUnsafe(26);

for (let i = 0; i &lt; 26; i++) {
  // 97 is the decimal ASCII value for &#39;a&#39;.
  buf1[i] = i + 97;
}

const buf2 = buf1.subarray(0, 3);

console.log(buf2.toString(&#39;ascii&#39;, 0, buf2.length));
// Prints: abc

buf1[0] = 33;

console.log(buf2.toString(&#39;ascii&#39;, 0, buf2.length));
// Prints: !bc</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

// Create a `Buffer` with the ASCII alphabet, take a slice, and modify one byte
// from the original `Buffer`.

const buf1 = Buffer.allocUnsafe(26);

for (let i = 0; i &lt; 26; i++) {
  // 97 is the decimal ASCII value for &#39;a&#39;.
  buf1[i] = i + 97;
}

const buf2 = buf1.subarray(0, 3);

console.log(buf2.toString(&#39;ascii&#39;, 0, buf2.length));
// Prints: abc

buf1[0] = 33;

console.log(buf2.toString(&#39;ascii&#39;, 0, buf2.length));
// Prints: !bc</code></pre>
    <p>
      Specifying negative indexes causes the slice to be generated relative to
      the end of <code>buf</code> rather than the beginning.
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

const buf = Buffer.from(&#39;buffer&#39;);

console.log(buf.subarray(-6, -1).toString());
// Prints: buffe
// (Equivalent to buf.subarray(0, 5).)

console.log(buf.subarray(-6, -2).toString());
// Prints: buff
// (Equivalent to buf.subarray(0, 4).)

console.log(buf.subarray(-5, -2).toString());
// Prints: uff
// (Equivalent to buf.subarray(1, 4).)</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

const buf = Buffer.from(&#39;buffer&#39;);

console.log(buf.subarray(-6, -1).toString());
// Prints: buffe
// (Equivalent to buf.subarray(0, 5).)

console.log(buf.subarray(-6, -2).toString());
// Prints: buff
// (Equivalent to buf.subarray(0, 4).)

console.log(buf.subarray(-5, -2).toString());
// Prints: uff
// (Equivalent to buf.subarray(1, 4).)</code></pre>
    <h3 id="buf.slicestart-end"><code>buf.slice([start[, end]])</code></h3>
    <!-- YAML
added: v0.3.0
changes:
  - version:
    - v7.1.0
    - v6.9.2
    pr-url: https://github.com/nodejs/node/pull/9341
    description: Coercing the offsets to integers now handles values outside
                 the 32-bit integer range properly.
  - version: v7.0.0
    pr-url: https://github.com/nodejs/node/pull/9101
    description: All offsets are now coerced to integers before doing any
                 calculations with them.
-->
    <ul>
      <li>
        <code>start</code> {integer} Where the new <code>Buffer</code> will
        start. <strong>Default:</strong> <code>0</code>.
      </li>
      <li>
        <code>end</code> {integer} Where the new <code>Buffer</code> will end
        (not inclusive). <strong>Default:</strong>
        <a href="#buffer_buf_length"><code>buf.length</code></a
        >.
      </li>
      <li>Returns: {Buffer}</li>
    </ul>
    <p>
      Returns a new <code>Buffer</code> that references the same memory as the
      original, but offset and cropped by the <code>start</code> and
      <code>end</code> indices.
    </p>
    <p>This is the same behavior as <code>buf.subarray()</code>.</p>
    <p>
      This method is not compatible with the
      <code>Uint8Array.prototype.slice()</code>, which is a superclass of
      <code>Buffer</code>. To copy the slice, use
      <code>Uint8Array.prototype.slice()</code>.
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

const buf = Buffer.from(&#39;buffer&#39;);

const copiedBuf = Uint8Array.prototype.slice.call(buf);
copiedBuf[0]++;
console.log(copiedBuf.toString());
// Prints: cuffer

console.log(buf.toString());
// Prints: buffer</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

const buf = Buffer.from(&#39;buffer&#39;);

const copiedBuf = Uint8Array.prototype.slice.call(buf);
copiedBuf[0]++;
console.log(copiedBuf.toString());
// Prints: cuffer

console.log(buf.toString());
// Prints: buffer</code></pre>
    <h3 id="buf.swap16"><code>buf.swap16()</code></h3>
    <!-- YAML
added: v5.10.0
-->
    <ul>
      <li>Returns: {Buffer} A reference to <code>buf</code>.</li>
    </ul>
    <p>
      Interprets <code>buf</code> as an array of unsigned 16-bit integers and
      swaps the byte order <em>in-place</em>. Throws
      <a href="errors.md#ERR_INVALID_BUFFER_SIZE"
        ><code>ERR_INVALID_BUFFER_SIZE</code></a
      >
      if <a href="#buffer_buf_length"><code>buf.length</code></a> is not a
      multiple of 2.
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

const buf1 = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]);

console.log(buf1);
// Prints: &lt;Buffer 01 02 03 04 05 06 07 08&gt;

buf1.swap16();

console.log(buf1);
// Prints: &lt;Buffer 02 01 04 03 06 05 08 07&gt;

const buf2 = Buffer.from([0x1, 0x2, 0x3]);

buf2.swap16();
// Throws ERR_INVALID_BUFFER_SIZE.</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

const buf1 = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]);

console.log(buf1);
// Prints: &lt;Buffer 01 02 03 04 05 06 07 08&gt;

buf1.swap16();

console.log(buf1);
// Prints: &lt;Buffer 02 01 04 03 06 05 08 07&gt;

const buf2 = Buffer.from([0x1, 0x2, 0x3]);

buf2.swap16();
// Throws ERR_INVALID_BUFFER_SIZE.</code></pre>
    <p>
      One convenient use of <code>buf.swap16()</code> is to perform a fast
      in-place conversion between UTF-16 little-endian and UTF-16 big-endian:
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

const buf = Buffer.from(&#39;This is little-endian UTF-16&#39;, &#39;utf16le&#39;);
buf.swap16(); // Convert to big-endian UTF-16 text.</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

const buf = Buffer.from(&#39;This is little-endian UTF-16&#39;, &#39;utf16le&#39;);
buf.swap16(); // Convert to big-endian UTF-16 text.</code></pre>
    <h3 id="buf.swap32"><code>buf.swap32()</code></h3>
    <!-- YAML
added: v5.10.0
-->
    <ul>
      <li>Returns: {Buffer} A reference to <code>buf</code>.</li>
    </ul>
    <p>
      Interprets <code>buf</code> as an array of unsigned 32-bit integers and
      swaps the byte order <em>in-place</em>. Throws
      <a href="errors.md#ERR_INVALID_BUFFER_SIZE"
        ><code>ERR_INVALID_BUFFER_SIZE</code></a
      >
      if <a href="#buffer_buf_length"><code>buf.length</code></a> is not a
      multiple of 4.
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

const buf1 = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]);

console.log(buf1);
// Prints: &lt;Buffer 01 02 03 04 05 06 07 08&gt;

buf1.swap32();

console.log(buf1);
// Prints: &lt;Buffer 04 03 02 01 08 07 06 05&gt;

const buf2 = Buffer.from([0x1, 0x2, 0x3]);

buf2.swap32();
// Throws ERR_INVALID_BUFFER_SIZE.</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

const buf1 = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]);

console.log(buf1);
// Prints: &lt;Buffer 01 02 03 04 05 06 07 08&gt;

buf1.swap32();

console.log(buf1);
// Prints: &lt;Buffer 04 03 02 01 08 07 06 05&gt;

const buf2 = Buffer.from([0x1, 0x2, 0x3]);

buf2.swap32();
// Throws ERR_INVALID_BUFFER_SIZE.</code></pre>
    <h3 id="buf.swap64"><code>buf.swap64()</code></h3>
    <!-- YAML
added: v6.3.0
-->
    <ul>
      <li>Returns: {Buffer} A reference to <code>buf</code>.</li>
    </ul>
    <p>
      Interprets <code>buf</code> as an array of 64-bit numbers and swaps byte
      order <em>in-place</em>. Throws
      <a href="errors.md#ERR_INVALID_BUFFER_SIZE"
        ><code>ERR_INVALID_BUFFER_SIZE</code></a
      >
      if <a href="#buffer_buf_length"><code>buf.length</code></a> is not a
      multiple of 8.
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

const buf1 = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]);

console.log(buf1);
// Prints: &lt;Buffer 01 02 03 04 05 06 07 08&gt;

buf1.swap64();

console.log(buf1);
// Prints: &lt;Buffer 08 07 06 05 04 03 02 01&gt;

const buf2 = Buffer.from([0x1, 0x2, 0x3]);

buf2.swap64();
// Throws ERR_INVALID_BUFFER_SIZE.</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

const buf1 = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]);

console.log(buf1);
// Prints: &lt;Buffer 01 02 03 04 05 06 07 08&gt;

buf1.swap64();

console.log(buf1);
// Prints: &lt;Buffer 08 07 06 05 04 03 02 01&gt;

const buf2 = Buffer.from([0x1, 0x2, 0x3]);

buf2.swap64();
// Throws ERR_INVALID_BUFFER_SIZE.</code></pre>
    <h3 id="buf.tojson"><code>buf.toJSON()</code></h3>
    <!-- YAML
added: v0.9.2
-->
    <ul>
      <li>Returns: {Object}</li>
    </ul>
    <p>
      Returns a JSON representation of <code>buf</code>.
      <a
        href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify"
        ><code>JSON.stringify()</code></a
      >
      implicitly calls this function when stringifying a
      <code>Buffer</code> instance.
    </p>
    <p>
      <code>Buffer.from()</code> accepts objects in the format returned from
      this method. In particular, <code>Buffer.from(buf.toJSON())</code> works
      like <code>Buffer.from(buf)</code>.
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

const buf = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5]);
const json = JSON.stringify(buf);

console.log(json);
// Prints: {&quot;type&quot;:&quot;Buffer&quot;,&quot;data&quot;:[1,2,3,4,5]}

const copy = JSON.parse(json, (key, value) =&gt; {
  return value &amp;&amp; value.type === &#39;Buffer&#39; ?
    Buffer.from(value) :
    value;
});

console.log(copy);
// Prints: &lt;Buffer 01 02 03 04 05&gt;</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

const buf = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5]);
const json = JSON.stringify(buf);

console.log(json);
// Prints: {&quot;type&quot;:&quot;Buffer&quot;,&quot;data&quot;:[1,2,3,4,5]}

const copy = JSON.parse(json, (key, value) =&gt; {
  return value &amp;&amp; value.type === &#39;Buffer&#39; ?
    Buffer.from(value) :
    value;
});

console.log(copy);
// Prints: &lt;Buffer 01 02 03 04 05&gt;</code></pre>
    <h3 id="buf.tostringencoding-start-end">
      <code>buf.toString([encoding[, start[, end]]])</code>
    </h3>
    <!-- YAML
added: v0.1.90
-->
    <ul>
      <li>
        <code>encoding</code> {string} The character encoding to use.
        <strong>Default:</strong> <code>'utf8'</code>.
      </li>
      <li>
        <code>start</code> {integer} The byte offset to start decoding at.
        <strong>Default:</strong> <code>0</code>.
      </li>
      <li>
        <code>end</code> {integer} The byte offset to stop decoding at (not
        inclusive). <strong>Default:</strong>
        <a href="#buffer_buf_length"><code>buf.length</code></a
        >.
      </li>
      <li>Returns: {string}</li>
    </ul>
    <p>
      Decodes <code>buf</code> to a string according to the specified character
      encoding in <code>encoding</code>. <code>start</code> and
      <code>end</code> may be passed to decode only a subset of
      <code>buf</code>.
    </p>
    <p>
      If <code>encoding</code> is <code>'utf8'</code> and a byte sequence in the
      input is not valid UTF-8, then each invalid byte is replaced with the
      replacement character <code>U+FFFD</code>.
    </p>
    <p>
      The maximum length of a string instance (in UTF-16 code units) is
      available as
      <a href="#buffer_buffer_constants_max_string_length"
        ><code>buffer.constants.MAX_STRING_LENGTH</code></a
      >.
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

const buf1 = Buffer.allocUnsafe(26);

for (let i = 0; i &lt; 26; i++) {
  // 97 is the decimal ASCII value for &#39;a&#39;.
  buf1[i] = i + 97;
}

console.log(buf1.toString(&#39;utf8&#39;));
// Prints: abcdefghijklmnopqrstuvwxyz
console.log(buf1.toString(&#39;utf8&#39;, 0, 5));
// Prints: abcde

const buf2 = Buffer.from(&#39;tést&#39;);

console.log(buf2.toString(&#39;hex&#39;));
// Prints: 74c3a97374
console.log(buf2.toString(&#39;utf8&#39;, 0, 3));
// Prints: té
console.log(buf2.toString(undefined, 0, 3));
// Prints: té</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

const buf1 = Buffer.allocUnsafe(26);

for (let i = 0; i &lt; 26; i++) {
  // 97 is the decimal ASCII value for &#39;a&#39;.
  buf1[i] = i + 97;
}

console.log(buf1.toString(&#39;utf8&#39;));
// Prints: abcdefghijklmnopqrstuvwxyz
console.log(buf1.toString(&#39;utf8&#39;, 0, 5));
// Prints: abcde

const buf2 = Buffer.from(&#39;tést&#39;);

console.log(buf2.toString(&#39;hex&#39;));
// Prints: 74c3a97374
console.log(buf2.toString(&#39;utf8&#39;, 0, 3));
// Prints: té
console.log(buf2.toString(undefined, 0, 3));
// Prints: té</code></pre>
    <h3 id="buf.values"><code>buf.values()</code></h3>
    <!-- YAML
added: v1.1.0
-->
    <ul>
      <li>Returns: {Iterator}</li>
    </ul>
    <p>
      Creates and returns an
      <a
        href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols"
        >iterator</a
      >
      for <code>buf</code> values (bytes). This function is called automatically
      when a <code>Buffer</code> is used in a <code>for..of</code> statement.
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

const buf = Buffer.from(&#39;buffer&#39;);

for (const value of buf.values()) {
  console.log(value);
}
// Prints:
//   98
//   117
//   102
//   102
//   101
//   114

for (const value of buf) {
  console.log(value);
}
// Prints:
//   98
//   117
//   102
//   102
//   101
//   114</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

const buf = Buffer.from(&#39;buffer&#39;);

for (const value of buf.values()) {
  console.log(value);
}
// Prints:
//   98
//   117
//   102
//   102
//   101
//   114

for (const value of buf) {
  console.log(value);
}
// Prints:
//   98
//   117
//   102
//   102
//   101
//   114</code></pre>
    <h3 id="buf.writestring-offset-length-encoding">
      <code>buf.write(string[, offset[, length]][, encoding])</code>
    </h3>
    <!-- YAML
added: v0.1.90
-->
    <ul>
      <li><code>string</code> {string} String to write to <code>buf</code>.</li>
      <li>
        <code>offset</code> {integer} Number of bytes to skip before starting to
        write <code>string</code>. <strong>Default:</strong> <code>0</code>.
      </li>
      <li>
        <code>length</code> {integer} Maximum number of bytes to write (written
        bytes will not exceed <code>buf.length - offset</code>).
        <strong>Default:</strong> <code>buf.length - offset</code>.
      </li>
      <li>
        <code>encoding</code> {string} The character encoding of
        <code>string</code>. <strong>Default:</strong> <code>'utf8'</code>.
      </li>
      <li>Returns: {integer} Number of bytes written.</li>
    </ul>
    <p>
      Writes <code>string</code> to <code>buf</code> at
      <code>offset</code> according to the character encoding in
      <code>encoding</code>. The <code>length</code> parameter is the number of
      bytes to write. If <code>buf</code> did not contain enough space to fit
      the entire string, only part of <code>string</code> will be written.
      However, partially encoded characters will not be written.
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

const buf = Buffer.alloc(256);

const len = buf.write(&#39;\u00bd + \u00bc = \u00be&#39;, 0);

console.log(`${len} bytes: ${buf.toString(&#39;utf8&#39;, 0, len)}`);
// Prints: 12 bytes: ½ + ¼ = ¾

const buffer = Buffer.alloc(10);

const length = buffer.write(&#39;abcd&#39;, 8);

console.log(`${length} bytes: ${buffer.toString(&#39;utf8&#39;, 8, 10)}`);
// Prints: 2 bytes : ab</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

const buf = Buffer.alloc(256);

const len = buf.write(&#39;\u00bd + \u00bc = \u00be&#39;, 0);

console.log(`${len} bytes: ${buf.toString(&#39;utf8&#39;, 0, len)}`);
// Prints: 12 bytes: ½ + ¼ = ¾

const buffer = Buffer.alloc(10);

const length = buffer.write(&#39;abcd&#39;, 8);

console.log(`${length} bytes: ${buffer.toString(&#39;utf8&#39;, 8, 10)}`);
// Prints: 2 bytes : ab</code></pre>
    <h3 id="buf.writebigint64bevalue-offset">
      <code>buf.writeBigInt64BE(value[, offset])</code>
    </h3>
    <!-- YAML
added:
 - v12.0.0
 - v10.20.0
-->
    <ul>
      <li>
        <code>value</code> {bigint} Number to be written to <code>buf</code>.
      </li>
      <li>
        <code>offset</code> {integer} Number of bytes to skip before starting to
        write. Must satisfy: <code>0 &lt;= offset &lt;= buf.length - 8</code>.
        <strong>Default:</strong> <code>0</code>.
      </li>
      <li>
        Returns: {integer} <code>offset</code> plus the number of bytes written.
      </li>
    </ul>
    <p>
      Writes <code>value</code> to <code>buf</code> at the specified
      <code>offset</code> as big-endian.
    </p>
    <p>
      <code>value</code> is interpreted and written as a two’s complement signed
      integer.
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

const buf = Buffer.allocUnsafe(8);

buf.writeBigInt64BE(0x0102030405060708n, 0);

console.log(buf);
// Prints: &lt;Buffer 01 02 03 04 05 06 07 08&gt;</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

const buf = Buffer.allocUnsafe(8);

buf.writeBigInt64BE(0x0102030405060708n, 0);

console.log(buf);
// Prints: &lt;Buffer 01 02 03 04 05 06 07 08&gt;</code></pre>
    <h3 id="buf.writebigint64levalue-offset">
      <code>buf.writeBigInt64LE(value[, offset])</code>
    </h3>
    <!-- YAML
added:
 - v12.0.0
 - v10.20.0
-->
    <ul>
      <li>
        <code>value</code> {bigint} Number to be written to <code>buf</code>.
      </li>
      <li>
        <code>offset</code> {integer} Number of bytes to skip before starting to
        write. Must satisfy: <code>0 &lt;= offset &lt;= buf.length - 8</code>.
        <strong>Default:</strong> <code>0</code>.
      </li>
      <li>
        Returns: {integer} <code>offset</code> plus the number of bytes written.
      </li>
    </ul>
    <p>
      Writes <code>value</code> to <code>buf</code> at the specified
      <code>offset</code> as little-endian.
    </p>
    <p>
      <code>value</code> is interpreted and written as a two’s complement signed
      integer.
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

const buf = Buffer.allocUnsafe(8);

buf.writeBigInt64LE(0x0102030405060708n, 0);

console.log(buf);
// Prints: &lt;Buffer 08 07 06 05 04 03 02 01&gt;</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

const buf = Buffer.allocUnsafe(8);

buf.writeBigInt64LE(0x0102030405060708n, 0);

console.log(buf);
// Prints: &lt;Buffer 08 07 06 05 04 03 02 01&gt;</code></pre>
    <h3 id="buf.writebiguint64bevalue-offset">
      <code>buf.writeBigUInt64BE(value[, offset])</code>
    </h3>
    <!-- YAML
added:
 - v12.0.0
 - v10.20.0
changes:
  - version:
    - v14.10.0
    - v12.19.0
    pr-url: https://github.com/nodejs/node/pull/34960
    description: This function is also available as `buf.writeBigUint64BE()`.
-->
    <ul>
      <li>
        <code>value</code> {bigint} Number to be written to <code>buf</code>.
      </li>
      <li>
        <code>offset</code> {integer} Number of bytes to skip before starting to
        write. Must satisfy: <code>0 &lt;= offset &lt;= buf.length - 8</code>.
        <strong>Default:</strong> <code>0</code>.
      </li>
      <li>
        Returns: {integer} <code>offset</code> plus the number of bytes written.
      </li>
    </ul>
    <p>
      Writes <code>value</code> to <code>buf</code> at the specified
      <code>offset</code> as big-endian.
    </p>
    <p>
      This function is also available under the
      <code>writeBigUint64BE</code> alias.
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

const buf = Buffer.allocUnsafe(8);

buf.writeBigUInt64BE(0xdecafafecacefaden, 0);

console.log(buf);
// Prints: &lt;Buffer de ca fa fe ca ce fa de&gt;</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

const buf = Buffer.allocUnsafe(8);

buf.writeBigUInt64BE(0xdecafafecacefaden, 0);

console.log(buf);
// Prints: &lt;Buffer de ca fa fe ca ce fa de&gt;</code></pre>
    <h3 id="buf.writebiguint64levalue-offset">
      <code>buf.writeBigUInt64LE(value[, offset])</code>
    </h3>
    <!-- YAML
added:
 - v12.0.0
 - v10.20.0
changes:
  - version:
    - v14.10.0
    - v12.19.0
    pr-url: https://github.com/nodejs/node/pull/34960
    description: This function is also available as `buf.writeBigUint64LE()`.
-->
    <ul>
      <li>
        <code>value</code> {bigint} Number to be written to <code>buf</code>.
      </li>
      <li>
        <code>offset</code> {integer} Number of bytes to skip before starting to
        write. Must satisfy: <code>0 &lt;= offset &lt;= buf.length - 8</code>.
        <strong>Default:</strong> <code>0</code>.
      </li>
      <li>
        Returns: {integer} <code>offset</code> plus the number of bytes written.
      </li>
    </ul>
    <p>
      Writes <code>value</code> to <code>buf</code> at the specified
      <code>offset</code> as little-endian
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

const buf = Buffer.allocUnsafe(8);

buf.writeBigUInt64LE(0xdecafafecacefaden, 0);

console.log(buf);
// Prints: &lt;Buffer de fa ce ca fe fa ca de&gt;</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

const buf = Buffer.allocUnsafe(8);

buf.writeBigUInt64LE(0xdecafafecacefaden, 0);

console.log(buf);
// Prints: &lt;Buffer de fa ce ca fe fa ca de&gt;</code></pre>
    <p>
      This function is also available under the
      <code>writeBigUint64LE</code> alias.
    </p>
    <h3 id="buf.writedoublebevalue-offset">
      <code>buf.writeDoubleBE(value[, offset])</code>
    </h3>
    <!-- YAML
added: v0.11.15
changes:
  - version: v10.0.0
    pr-url: https://github.com/nodejs/node/pull/18395
    description: Removed `noAssert` and no implicit coercion of the offset
                 to `uint32` anymore.
-->
    <ul>
      <li>
        <code>value</code> {number} Number to be written to <code>buf</code>.
      </li>
      <li>
        <code>offset</code> {integer} Number of bytes to skip before starting to
        write. Must satisfy <code>0 &lt;= offset &lt;= buf.length - 8</code>.
        <strong>Default:</strong> <code>0</code>.
      </li>
      <li>
        Returns: {integer} <code>offset</code> plus the number of bytes written.
      </li>
    </ul>
    <p>
      Writes <code>value</code> to <code>buf</code> at the specified
      <code>offset</code> as big-endian. The <code>value</code> must be a
      JavaScript number. Behavior is undefined when <code>value</code> is
      anything other than a JavaScript number.
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

const buf = Buffer.allocUnsafe(8);

buf.writeDoubleBE(123.456, 0);

console.log(buf);
// Prints: &lt;Buffer 40 5e dd 2f 1a 9f be 77&gt;</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

const buf = Buffer.allocUnsafe(8);

buf.writeDoubleBE(123.456, 0);

console.log(buf);
// Prints: &lt;Buffer 40 5e dd 2f 1a 9f be 77&gt;</code></pre>
    <h3 id="buf.writedoublelevalue-offset">
      <code>buf.writeDoubleLE(value[, offset])</code>
    </h3>
    <!-- YAML
added: v0.11.15
changes:
  - version: v10.0.0
    pr-url: https://github.com/nodejs/node/pull/18395
    description: Removed `noAssert` and no implicit coercion of the offset
                 to `uint32` anymore.
-->
    <ul>
      <li>
        <code>value</code> {number} Number to be written to <code>buf</code>.
      </li>
      <li>
        <code>offset</code> {integer} Number of bytes to skip before starting to
        write. Must satisfy <code>0 &lt;= offset &lt;= buf.length - 8</code>.
        <strong>Default:</strong> <code>0</code>.
      </li>
      <li>
        Returns: {integer} <code>offset</code> plus the number of bytes written.
      </li>
    </ul>
    <p>
      Writes <code>value</code> to <code>buf</code> at the specified
      <code>offset</code> as little-endian. The <code>value</code> must be a
      JavaScript number. Behavior is undefined when <code>value</code> is
      anything other than a JavaScript number.
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

const buf = Buffer.allocUnsafe(8);

buf.writeDoubleLE(123.456, 0);

console.log(buf);
// Prints: &lt;Buffer 77 be 9f 1a 2f dd 5e 40&gt;</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

const buf = Buffer.allocUnsafe(8);

buf.writeDoubleLE(123.456, 0);

console.log(buf);
// Prints: &lt;Buffer 77 be 9f 1a 2f dd 5e 40&gt;</code></pre>
    <h3 id="buf.writefloatbevalue-offset">
      <code>buf.writeFloatBE(value[, offset])</code>
    </h3>
    <!-- YAML
added: v0.11.15
changes:
  - version: v10.0.0
    pr-url: https://github.com/nodejs/node/pull/18395
    description: Removed `noAssert` and no implicit coercion of the offset
                 to `uint32` anymore.
-->
    <ul>
      <li>
        <code>value</code> {number} Number to be written to <code>buf</code>.
      </li>
      <li>
        <code>offset</code> {integer} Number of bytes to skip before starting to
        write. Must satisfy <code>0 &lt;= offset &lt;= buf.length - 4</code>.
        <strong>Default:</strong> <code>0</code>.
      </li>
      <li>
        Returns: {integer} <code>offset</code> plus the number of bytes written.
      </li>
    </ul>
    <p>
      Writes <code>value</code> to <code>buf</code> at the specified
      <code>offset</code> as big-endian. Behavior is undefined when
      <code>value</code> is anything other than a JavaScript number.
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

const buf = Buffer.allocUnsafe(4);

buf.writeFloatBE(0xcafebabe, 0);

console.log(buf);
// Prints: &lt;Buffer 4f 4a fe bb&gt;</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

const buf = Buffer.allocUnsafe(4);

buf.writeFloatBE(0xcafebabe, 0);

console.log(buf);
// Prints: &lt;Buffer 4f 4a fe bb&gt;</code></pre>
    <h3 id="buf.writefloatlevalue-offset">
      <code>buf.writeFloatLE(value[, offset])</code>
    </h3>
    <!-- YAML
added: v0.11.15
changes:
  - version: v10.0.0
    pr-url: https://github.com/nodejs/node/pull/18395
    description: Removed `noAssert` and no implicit coercion of the offset
                 to `uint32` anymore.
-->
    <ul>
      <li>
        <code>value</code> {number} Number to be written to <code>buf</code>.
      </li>
      <li>
        <code>offset</code> {integer} Number of bytes to skip before starting to
        write. Must satisfy <code>0 &lt;= offset &lt;= buf.length - 4</code>.
        <strong>Default:</strong> <code>0</code>.
      </li>
      <li>
        Returns: {integer} <code>offset</code> plus the number of bytes written.
      </li>
    </ul>
    <p>
      Writes <code>value</code> to <code>buf</code> at the specified
      <code>offset</code> as little-endian. Behavior is undefined when
      <code>value</code> is anything other than a JavaScript number.
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

const buf = Buffer.allocUnsafe(4);

buf.writeFloatLE(0xcafebabe, 0);

console.log(buf);
// Prints: &lt;Buffer bb fe 4a 4f&gt;</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

const buf = Buffer.allocUnsafe(4);

buf.writeFloatLE(0xcafebabe, 0);

console.log(buf);
// Prints: &lt;Buffer bb fe 4a 4f&gt;</code></pre>
    <h3 id="buf.writeint8value-offset">
      <code>buf.writeInt8(value[, offset])</code>
    </h3>
    <!-- YAML
added: v0.5.0
changes:
  - version: v10.0.0
    pr-url: https://github.com/nodejs/node/pull/18395
    description: Removed `noAssert` and no implicit coercion of the offset
                 to `uint32` anymore.
-->
    <ul>
      <li>
        <code>value</code> {integer} Number to be written to <code>buf</code>.
      </li>
      <li>
        <code>offset</code> {integer} Number of bytes to skip before starting to
        write. Must satisfy <code>0 &lt;= offset &lt;= buf.length - 1</code>.
        <strong>Default:</strong> <code>0</code>.
      </li>
      <li>
        Returns: {integer} <code>offset</code> plus the number of bytes written.
      </li>
    </ul>
    <p>
      Writes <code>value</code> to <code>buf</code> at the specified
      <code>offset</code>. <code>value</code> must be a valid signed 8-bit
      integer. Behavior is undefined when <code>value</code> is anything other
      than a signed 8-bit integer.
    </p>
    <p>
      <code>value</code> is interpreted and written as a two’s complement signed
      integer.
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

const buf = Buffer.allocUnsafe(2);

buf.writeInt8(2, 0);
buf.writeInt8(-2, 1);

console.log(buf);
// Prints: &lt;Buffer 02 fe&gt;</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

const buf = Buffer.allocUnsafe(2);

buf.writeInt8(2, 0);
buf.writeInt8(-2, 1);

console.log(buf);
// Prints: &lt;Buffer 02 fe&gt;</code></pre>
    <h3 id="buf.writeint16bevalue-offset">
      <code>buf.writeInt16BE(value[, offset])</code>
    </h3>
    <!-- YAML
added: v0.5.5
changes:
  - version: v10.0.0
    pr-url: https://github.com/nodejs/node/pull/18395
    description: Removed `noAssert` and no implicit coercion of the offset
                 to `uint32` anymore.
-->
    <ul>
      <li>
        <code>value</code> {integer} Number to be written to <code>buf</code>.
      </li>
      <li>
        <code>offset</code> {integer} Number of bytes to skip before starting to
        write. Must satisfy <code>0 &lt;= offset &lt;= buf.length - 2</code>.
        <strong>Default:</strong> <code>0</code>.
      </li>
      <li>
        Returns: {integer} <code>offset</code> plus the number of bytes written.
      </li>
    </ul>
    <p>
      Writes <code>value</code> to <code>buf</code> at the specified
      <code>offset</code> as big-endian. The <code>value</code> must be a valid
      signed 16-bit integer. Behavior is undefined when <code>value</code> is
      anything other than a signed 16-bit integer.
    </p>
    <p>
      The <code>value</code> is interpreted and written as a two’s complement
      signed integer.
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

const buf = Buffer.allocUnsafe(2);

buf.writeInt16BE(0x0102, 0);

console.log(buf);
// Prints: &lt;Buffer 01 02&gt;</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

const buf = Buffer.allocUnsafe(2);

buf.writeInt16BE(0x0102, 0);

console.log(buf);
// Prints: &lt;Buffer 01 02&gt;</code></pre>
    <h3 id="buf.writeint16levalue-offset">
      <code>buf.writeInt16LE(value[, offset])</code>
    </h3>
    <!-- YAML
added: v0.5.5
changes:
  - version: v10.0.0
    pr-url: https://github.com/nodejs/node/pull/18395
    description: Removed `noAssert` and no implicit coercion of the offset
                 to `uint32` anymore.
-->
    <ul>
      <li>
        <code>value</code> {integer} Number to be written to <code>buf</code>.
      </li>
      <li>
        <code>offset</code> {integer} Number of bytes to skip before starting to
        write. Must satisfy <code>0 &lt;= offset &lt;= buf.length - 2</code>.
        <strong>Default:</strong> <code>0</code>.
      </li>
      <li>
        Returns: {integer} <code>offset</code> plus the number of bytes written.
      </li>
    </ul>
    <p>
      Writes <code>value</code> to <code>buf</code> at the specified
      <code>offset</code> as little-endian. The <code>value</code> must be a
      valid signed 16-bit integer. Behavior is undefined when
      <code>value</code> is anything other than a signed 16-bit integer.
    </p>
    <p>
      The <code>value</code> is interpreted and written as a two’s complement
      signed integer.
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

const buf = Buffer.allocUnsafe(2);

buf.writeInt16LE(0x0304, 0);

console.log(buf);
// Prints: &lt;Buffer 04 03&gt;</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

const buf = Buffer.allocUnsafe(2);

buf.writeInt16LE(0x0304, 0);

console.log(buf);
// Prints: &lt;Buffer 04 03&gt;</code></pre>
    <h3 id="buf.writeint32bevalue-offset">
      <code>buf.writeInt32BE(value[, offset])</code>
    </h3>
    <!-- YAML
added: v0.5.5
changes:
  - version: v10.0.0
    pr-url: https://github.com/nodejs/node/pull/18395
    description: Removed `noAssert` and no implicit coercion of the offset
                 to `uint32` anymore.
-->
    <ul>
      <li>
        <code>value</code> {integer} Number to be written to <code>buf</code>.
      </li>
      <li>
        <code>offset</code> {integer} Number of bytes to skip before starting to
        write. Must satisfy <code>0 &lt;= offset &lt;= buf.length - 4</code>.
        <strong>Default:</strong> <code>0</code>.
      </li>
      <li>
        Returns: {integer} <code>offset</code> plus the number of bytes written.
      </li>
    </ul>
    <p>
      Writes <code>value</code> to <code>buf</code> at the specified
      <code>offset</code> as big-endian. The <code>value</code> must be a valid
      signed 32-bit integer. Behavior is undefined when <code>value</code> is
      anything other than a signed 32-bit integer.
    </p>
    <p>
      The <code>value</code> is interpreted and written as a two’s complement
      signed integer.
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

const buf = Buffer.allocUnsafe(4);

buf.writeInt32BE(0x01020304, 0);

console.log(buf);
// Prints: &lt;Buffer 01 02 03 04&gt;</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

const buf = Buffer.allocUnsafe(4);

buf.writeInt32BE(0x01020304, 0);

console.log(buf);
// Prints: &lt;Buffer 01 02 03 04&gt;</code></pre>
    <h3 id="buf.writeint32levalue-offset">
      <code>buf.writeInt32LE(value[, offset])</code>
    </h3>
    <!-- YAML
added: v0.5.5
changes:
  - version: v10.0.0
    pr-url: https://github.com/nodejs/node/pull/18395
    description: Removed `noAssert` and no implicit coercion of the offset
                 to `uint32` anymore.
-->
    <ul>
      <li>
        <code>value</code> {integer} Number to be written to <code>buf</code>.
      </li>
      <li>
        <code>offset</code> {integer} Number of bytes to skip before starting to
        write. Must satisfy <code>0 &lt;= offset &lt;= buf.length - 4</code>.
        <strong>Default:</strong> <code>0</code>.
      </li>
      <li>
        Returns: {integer} <code>offset</code> plus the number of bytes written.
      </li>
    </ul>
    <p>
      Writes <code>value</code> to <code>buf</code> at the specified
      <code>offset</code> as little-endian. The <code>value</code> must be a
      valid signed 32-bit integer. Behavior is undefined when
      <code>value</code> is anything other than a signed 32-bit integer.
    </p>
    <p>
      The <code>value</code> is interpreted and written as a two’s complement
      signed integer.
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

const buf = Buffer.allocUnsafe(4);

buf.writeInt32LE(0x05060708, 0);

console.log(buf);
// Prints: &lt;Buffer 08 07 06 05&gt;</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

const buf = Buffer.allocUnsafe(4);

buf.writeInt32LE(0x05060708, 0);

console.log(buf);
// Prints: &lt;Buffer 08 07 06 05&gt;</code></pre>
    <h3 id="buf.writeintbevalue-offset-bytelength">
      <code>buf.writeIntBE(value, offset, byteLength)</code>
    </h3>
    <!-- YAML
added: v0.11.15
changes:
  - version: v10.0.0
    pr-url: https://github.com/nodejs/node/pull/18395
    description: Removed `noAssert` and no implicit coercion of the offset
                 and `byteLength` to `uint32` anymore.
-->
    <ul>
      <li>
        <code>value</code> {integer} Number to be written to <code>buf</code>.
      </li>
      <li>
        <code>offset</code> {integer} Number of bytes to skip before starting to
        write. Must satisfy
        <code>0 &lt;= offset &lt;= buf.length - byteLength</code>.
      </li>
      <li>
        <code>byteLength</code> {integer} Number of bytes to write. Must satisfy
        <code>0 &lt; byteLength &lt;= 6</code>.
      </li>
      <li>
        Returns: {integer} <code>offset</code> plus the number of bytes written.
      </li>
    </ul>
    <p>
      Writes <code>byteLength</code> bytes of <code>value</code> to
      <code>buf</code> at the specified <code>offset</code> as big-endian.
      Supports up to 48 bits of accuracy. Behavior is undefined when
      <code>value</code> is anything other than a signed integer.
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

const buf = Buffer.allocUnsafe(6);

buf.writeIntBE(0x1234567890ab, 0, 6);

console.log(buf);
// Prints: &lt;Buffer 12 34 56 78 90 ab&gt;</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

const buf = Buffer.allocUnsafe(6);

buf.writeIntBE(0x1234567890ab, 0, 6);

console.log(buf);
// Prints: &lt;Buffer 12 34 56 78 90 ab&gt;</code></pre>
    <h3 id="buf.writeintlevalue-offset-bytelength">
      <code>buf.writeIntLE(value, offset, byteLength)</code>
    </h3>
    <!-- YAML
added: v0.11.15
changes:
  - version: v10.0.0
    pr-url: https://github.com/nodejs/node/pull/18395
    description: Removed `noAssert` and no implicit coercion of the offset
                 and `byteLength` to `uint32` anymore.
-->
    <ul>
      <li>
        <code>value</code> {integer} Number to be written to <code>buf</code>.
      </li>
      <li>
        <code>offset</code> {integer} Number of bytes to skip before starting to
        write. Must satisfy
        <code>0 &lt;= offset &lt;= buf.length - byteLength</code>.
      </li>
      <li>
        <code>byteLength</code> {integer} Number of bytes to write. Must satisfy
        <code>0 &lt; byteLength &lt;= 6</code>.
      </li>
      <li>
        Returns: {integer} <code>offset</code> plus the number of bytes written.
      </li>
    </ul>
    <p>
      Writes <code>byteLength</code> bytes of <code>value</code> to
      <code>buf</code> at the specified <code>offset</code> as little-endian.
      Supports up to 48 bits of accuracy. Behavior is undefined when
      <code>value</code> is anything other than a signed integer.
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

const buf = Buffer.allocUnsafe(6);

buf.writeIntLE(0x1234567890ab, 0, 6);

console.log(buf);
// Prints: &lt;Buffer ab 90 78 56 34 12&gt;</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

const buf = Buffer.allocUnsafe(6);

buf.writeIntLE(0x1234567890ab, 0, 6);

console.log(buf);
// Prints: &lt;Buffer ab 90 78 56 34 12&gt;</code></pre>
    <h3 id="buf.writeuint8value-offset">
      <code>buf.writeUInt8(value[, offset])</code>
    </h3>
    <!-- YAML
added: v0.5.0
changes:
  - version:
    - v14.9.0
    - v12.19.0
    pr-url: https://github.com/nodejs/node/pull/34729
    description: This function is also available as `buf.writeUint8()`.
  - version: v10.0.0
    pr-url: https://github.com/nodejs/node/pull/18395
    description: Removed `noAssert` and no implicit coercion of the offset
                 to `uint32` anymore.
-->
    <ul>
      <li>
        <code>value</code> {integer} Number to be written to <code>buf</code>.
      </li>
      <li>
        <code>offset</code> {integer} Number of bytes to skip before starting to
        write. Must satisfy <code>0 &lt;= offset &lt;= buf.length - 1</code>.
        <strong>Default:</strong> <code>0</code>.
      </li>
      <li>
        Returns: {integer} <code>offset</code> plus the number of bytes written.
      </li>
    </ul>
    <p>
      Writes <code>value</code> to <code>buf</code> at the specified
      <code>offset</code>. <code>value</code> must be a valid unsigned 8-bit
      integer. Behavior is undefined when <code>value</code> is anything other
      than an unsigned 8-bit integer.
    </p>
    <p>
      This function is also available under the <code>writeUint8</code> alias.
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

const buf = Buffer.allocUnsafe(4);

buf.writeUInt8(0x3, 0);
buf.writeUInt8(0x4, 1);
buf.writeUInt8(0x23, 2);
buf.writeUInt8(0x42, 3);

console.log(buf);
// Prints: &lt;Buffer 03 04 23 42&gt;</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

const buf = Buffer.allocUnsafe(4);

buf.writeUInt8(0x3, 0);
buf.writeUInt8(0x4, 1);
buf.writeUInt8(0x23, 2);
buf.writeUInt8(0x42, 3);

console.log(buf);
// Prints: &lt;Buffer 03 04 23 42&gt;</code></pre>
    <h3 id="buf.writeuint16bevalue-offset">
      <code>buf.writeUInt16BE(value[, offset])</code>
    </h3>
    <!-- YAML
added: v0.5.5
changes:
  - version:
    - v14.9.0
    - v12.19.0
    pr-url: https://github.com/nodejs/node/pull/34729
    description: This function is also available as `buf.writeUint16BE()`.
  - version: v10.0.0
    pr-url: https://github.com/nodejs/node/pull/18395
    description: Removed `noAssert` and no implicit coercion of the offset
                 to `uint32` anymore.
-->
    <ul>
      <li>
        <code>value</code> {integer} Number to be written to <code>buf</code>.
      </li>
      <li>
        <code>offset</code> {integer} Number of bytes to skip before starting to
        write. Must satisfy <code>0 &lt;= offset &lt;= buf.length - 2</code>.
        <strong>Default:</strong> <code>0</code>.
      </li>
      <li>
        Returns: {integer} <code>offset</code> plus the number of bytes written.
      </li>
    </ul>
    <p>
      Writes <code>value</code> to <code>buf</code> at the specified
      <code>offset</code> as big-endian. The <code>value</code> must be a valid
      unsigned 16-bit integer. Behavior is undefined when <code>value</code> is
      anything other than an unsigned 16-bit integer.
    </p>
    <p>
      This function is also available under the
      <code>writeUint16BE</code> alias.
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

const buf = Buffer.allocUnsafe(4);

buf.writeUInt16BE(0xdead, 0);
buf.writeUInt16BE(0xbeef, 2);

console.log(buf);
// Prints: &lt;Buffer de ad be ef&gt;</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

const buf = Buffer.allocUnsafe(4);

buf.writeUInt16BE(0xdead, 0);
buf.writeUInt16BE(0xbeef, 2);

console.log(buf);
// Prints: &lt;Buffer de ad be ef&gt;</code></pre>
    <h3 id="buf.writeuint16levalue-offset">
      <code>buf.writeUInt16LE(value[, offset])</code>
    </h3>
    <!-- YAML
added: v0.5.5
changes:
  - version:
    - v14.9.0
    - v12.19.0
    pr-url: https://github.com/nodejs/node/pull/34729
    description: This function is also available as `buf.writeUint16LE()`.
  - version: v10.0.0
    pr-url: https://github.com/nodejs/node/pull/18395
    description: Removed `noAssert` and no implicit coercion of the offset
                 to `uint32` anymore.
-->
    <ul>
      <li>
        <code>value</code> {integer} Number to be written to <code>buf</code>.
      </li>
      <li>
        <code>offset</code> {integer} Number of bytes to skip before starting to
        write. Must satisfy <code>0 &lt;= offset &lt;= buf.length - 2</code>.
        <strong>Default:</strong> <code>0</code>.
      </li>
      <li>
        Returns: {integer} <code>offset</code> plus the number of bytes written.
      </li>
    </ul>
    <p>
      Writes <code>value</code> to <code>buf</code> at the specified
      <code>offset</code> as little-endian. The <code>value</code> must be a
      valid unsigned 16-bit integer. Behavior is undefined when
      <code>value</code> is anything other than an unsigned 16-bit integer.
    </p>
    <p>
      This function is also available under the
      <code>writeUint16LE</code> alias.
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

const buf = Buffer.allocUnsafe(4);

buf.writeUInt16LE(0xdead, 0);
buf.writeUInt16LE(0xbeef, 2);

console.log(buf);
// Prints: &lt;Buffer ad de ef be&gt;</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

const buf = Buffer.allocUnsafe(4);

buf.writeUInt16LE(0xdead, 0);
buf.writeUInt16LE(0xbeef, 2);

console.log(buf);
// Prints: &lt;Buffer ad de ef be&gt;</code></pre>
    <h3 id="buf.writeuint32bevalue-offset">
      <code>buf.writeUInt32BE(value[, offset])</code>
    </h3>
    <!-- YAML
added: v0.5.5
changes:
  - version:
    - v14.9.0
    - v12.19.0
    pr-url: https://github.com/nodejs/node/pull/34729
    description: This function is also available as `buf.writeUint32BE()`.
  - version: v10.0.0
    pr-url: https://github.com/nodejs/node/pull/18395
    description: Removed `noAssert` and no implicit coercion of the offset
                 to `uint32` anymore.
-->
    <ul>
      <li>
        <code>value</code> {integer} Number to be written to <code>buf</code>.
      </li>
      <li>
        <code>offset</code> {integer} Number of bytes to skip before starting to
        write. Must satisfy <code>0 &lt;= offset &lt;= buf.length - 4</code>.
        <strong>Default:</strong> <code>0</code>.
      </li>
      <li>
        Returns: {integer} <code>offset</code> plus the number of bytes written.
      </li>
    </ul>
    <p>
      Writes <code>value</code> to <code>buf</code> at the specified
      <code>offset</code> as big-endian. The <code>value</code> must be a valid
      unsigned 32-bit integer. Behavior is undefined when <code>value</code> is
      anything other than an unsigned 32-bit integer.
    </p>
    <p>
      This function is also available under the
      <code>writeUint32BE</code> alias.
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

const buf = Buffer.allocUnsafe(4);

buf.writeUInt32BE(0xfeedface, 0);

console.log(buf);
// Prints: &lt;Buffer fe ed fa ce&gt;</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

const buf = Buffer.allocUnsafe(4);

buf.writeUInt32BE(0xfeedface, 0);

console.log(buf);
// Prints: &lt;Buffer fe ed fa ce&gt;</code></pre>
    <h3 id="buf.writeuint32levalue-offset">
      <code>buf.writeUInt32LE(value[, offset])</code>
    </h3>
    <!-- YAML
added: v0.5.5
changes:
  - version:
    - v14.9.0
    - v12.19.0
    pr-url: https://github.com/nodejs/node/pull/34729
    description: This function is also available as `buf.writeUint32LE()`.
  - version: v10.0.0
    pr-url: https://github.com/nodejs/node/pull/18395
    description: Removed `noAssert` and no implicit coercion of the offset
                 to `uint32` anymore.
-->
    <ul>
      <li>
        <code>value</code> {integer} Number to be written to <code>buf</code>.
      </li>
      <li>
        <code>offset</code> {integer} Number of bytes to skip before starting to
        write. Must satisfy <code>0 &lt;= offset &lt;= buf.length - 4</code>.
        <strong>Default:</strong> <code>0</code>.
      </li>
      <li>
        Returns: {integer} <code>offset</code> plus the number of bytes written.
      </li>
    </ul>
    <p>
      Writes <code>value</code> to <code>buf</code> at the specified
      <code>offset</code> as little-endian. The <code>value</code> must be a
      valid unsigned 32-bit integer. Behavior is undefined when
      <code>value</code> is anything other than an unsigned 32-bit integer.
    </p>
    <p>
      This function is also available under the
      <code>writeUint32LE</code> alias.
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

const buf = Buffer.allocUnsafe(4);

buf.writeUInt32LE(0xfeedface, 0);

console.log(buf);
// Prints: &lt;Buffer ce fa ed fe&gt;</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

const buf = Buffer.allocUnsafe(4);

buf.writeUInt32LE(0xfeedface, 0);

console.log(buf);
// Prints: &lt;Buffer ce fa ed fe&gt;</code></pre>
    <h3 id="buf.writeuintbevalue-offset-bytelength">
      <code>buf.writeUIntBE(value, offset, byteLength)</code>
    </h3>
    <!-- YAML
added: v0.5.5
changes:
  - version:
    - v14.9.0
    - v12.19.0
    pr-url: https://github.com/nodejs/node/pull/34729
    description: This function is also available as `buf.writeUintBE()`.
  - version: v10.0.0
    pr-url: https://github.com/nodejs/node/pull/18395
    description: Removed `noAssert` and no implicit coercion of the offset
                 and `byteLength` to `uint32` anymore.
-->
    <ul>
      <li>
        <code>value</code> {integer} Number to be written to <code>buf</code>.
      </li>
      <li>
        <code>offset</code> {integer} Number of bytes to skip before starting to
        write. Must satisfy
        <code>0 &lt;= offset &lt;= buf.length - byteLength</code>.
      </li>
      <li>
        <code>byteLength</code> {integer} Number of bytes to write. Must satisfy
        <code>0 &lt; byteLength &lt;= 6</code>.
      </li>
      <li>
        Returns: {integer} <code>offset</code> plus the number of bytes written.
      </li>
    </ul>
    <p>
      Writes <code>byteLength</code> bytes of <code>value</code> to
      <code>buf</code> at the specified <code>offset</code> as big-endian.
      Supports up to 48 bits of accuracy. Behavior is undefined when
      <code>value</code> is anything other than an unsigned integer.
    </p>
    <p>
      This function is also available under the <code>writeUintBE</code> alias.
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

const buf = Buffer.allocUnsafe(6);

buf.writeUIntBE(0x1234567890ab, 0, 6);

console.log(buf);
// Prints: &lt;Buffer 12 34 56 78 90 ab&gt;</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

const buf = Buffer.allocUnsafe(6);

buf.writeUIntBE(0x1234567890ab, 0, 6);

console.log(buf);
// Prints: &lt;Buffer 12 34 56 78 90 ab&gt;</code></pre>
    <h3 id="buf.writeuintlevalue-offset-bytelength">
      <code>buf.writeUIntLE(value, offset, byteLength)</code>
    </h3>
    <!-- YAML
added: v0.5.5
changes:
  - version:
    - v14.9.0
    - v12.19.0
    pr-url: https://github.com/nodejs/node/pull/34729
    description: This function is also available as `buf.writeUintLE()`.
  - version: v10.0.0
    pr-url: https://github.com/nodejs/node/pull/18395
    description: Removed `noAssert` and no implicit coercion of the offset
                 and `byteLength` to `uint32` anymore.
-->
    <ul>
      <li>
        <code>value</code> {integer} Number to be written to <code>buf</code>.
      </li>
      <li>
        <code>offset</code> {integer} Number of bytes to skip before starting to
        write. Must satisfy
        <code>0 &lt;= offset &lt;= buf.length - byteLength</code>.
      </li>
      <li>
        <code>byteLength</code> {integer} Number of bytes to write. Must satisfy
        <code>0 &lt; byteLength &lt;= 6</code>.
      </li>
      <li>
        Returns: {integer} <code>offset</code> plus the number of bytes written.
      </li>
    </ul>
    <p>
      Writes <code>byteLength</code> bytes of <code>value</code> to
      <code>buf</code> at the specified <code>offset</code> as little-endian.
      Supports up to 48 bits of accuracy. Behavior is undefined when
      <code>value</code> is anything other than an unsigned integer.
    </p>
    <p>
      This function is also available under the <code>writeUintLE</code> alias.
    </p>
    <pre class="mjs"><code>import { Buffer } from &#39;buffer&#39;;

const buf = Buffer.allocUnsafe(6);

buf.writeUIntLE(0x1234567890ab, 0, 6);

console.log(buf);
// Prints: &lt;Buffer ab 90 78 56 34 12&gt;</code></pre>
    <pre class="cjs"><code>const { Buffer } = require(&#39;buffer&#39;);

const buf = Buffer.allocUnsafe(6);

buf.writeUIntLE(0x1234567890ab, 0, 6);

console.log(buf);
// Prints: &lt;Buffer ab 90 78 56 34 12&gt;</code></pre>
    <h3 id="new-bufferarray"><code>new Buffer(array)</code></h3>
    <!-- YAML
deprecated: v6.0.0
changes:
  - version: v10.0.0
    pr-url: https://github.com/nodejs/node/pull/19524
    description: Calling this constructor emits a deprecation warning when
                 run from code outside the `node_modules` directory.
  - version: v7.2.1
    pr-url: https://github.com/nodejs/node/pull/9529
    description: Calling this constructor no longer emits a deprecation warning.
  - version: v7.0.0
    pr-url: https://github.com/nodejs/node/pull/8169
    description: Calling this constructor emits a deprecation warning now.
-->
    <blockquote>
      <p>
        Stability: 0 - Deprecated: Use
        <a href="#buffer_static_method_buffer_from_array"
          ><code>Buffer.from(array)</code></a
        >
        instead.
      </p>
    </blockquote>
    <ul>
      <li><code>array</code> {integer[]} An array of bytes to copy from.</li>
    </ul>
    <p>
      See
      <a href="#buffer_static_method_buffer_from_array"
        ><code>Buffer.from(array)</code></a
      >.
    </p>
    <h3 id="new-bufferarraybuffer-byteoffset-length">
      <code>new Buffer(arrayBuffer[, byteOffset[, length]])</code>
    </h3>
    <!-- YAML
added: v3.0.0
deprecated: v6.0.0
changes:
  - version: v10.0.0
    pr-url: https://github.com/nodejs/node/pull/19524
    description: Calling this constructor emits a deprecation warning when
                 run from code outside the `node_modules` directory.
  - version: v7.2.1
    pr-url: https://github.com/nodejs/node/pull/9529
    description: Calling this constructor no longer emits a deprecation warning.
  - version: v7.0.0
    pr-url: https://github.com/nodejs/node/pull/8169
    description: Calling this constructor emits a deprecation warning now.
  - version: v6.0.0
    pr-url: https://github.com/nodejs/node/pull/4682
    description: The `byteOffset` and `length` parameters are supported now.
-->
    <blockquote>
      <p>
        Stability: 0 - Deprecated: Use
        <a
          href="#buffer_static_method_buffer_from_arraybuffer_byteoffset_length"
          ><code>Buffer.from(arrayBuffer[, byteOffset[, length]])</code></a
        >
        instead.
      </p>
    </blockquote>
    <ul>
      <li>
        <code>arrayBuffer</code> {ArrayBuffer|SharedArrayBuffer} An
        <a
          href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer"
          ><code>ArrayBuffer</code></a
        >,
        <a
          href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer"
          ><code>SharedArrayBuffer</code></a
        >
        or the <code>.buffer</code> property of a
        <a
          href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray"
          ><code>TypedArray</code></a
        >.
      </li>
      <li>
        <code>byteOffset</code> {integer} Index of first byte to expose.
        <strong>Default:</strong> <code>0</code>.
      </li>
      <li>
        <code>length</code> {integer} Number of bytes to expose.
        <strong>Default:</strong>
        <code>arrayBuffer.byteLength - byteOffset</code>.
      </li>
    </ul>
    <p>
      See
      <a href="#buffer_static_method_buffer_from_arraybuffer_byteoffset_length"
        ><code>Buffer.from(arrayBuffer[, byteOffset[, length]])</code></a
      >.
    </p>
    <h3 id="new-bufferbuffer"><code>new Buffer(buffer)</code></h3>
    <!-- YAML
deprecated: v6.0.0
changes:
  - version: v10.0.0
    pr-url: https://github.com/nodejs/node/pull/19524
    description: Calling this constructor emits a deprecation warning when
                 run from code outside the `node_modules` directory.
  - version: v7.2.1
    pr-url: https://github.com/nodejs/node/pull/9529
    description: Calling this constructor no longer emits a deprecation warning.
  - version: v7.0.0
    pr-url: https://github.com/nodejs/node/pull/8169
    description: Calling this constructor emits a deprecation warning now.
-->
    <blockquote>
      <p>
        Stability: 0 - Deprecated: Use
        <a href="#buffer_static_method_buffer_from_buffer"
          ><code>Buffer.from(buffer)</code></a
        >
        instead.
      </p>
    </blockquote>
    <ul>
      <li>
        <code>buffer</code> {Buffer|Uint8Array} An existing
        <code>Buffer</code> or
        <a
          href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array"
          ><code>Uint8Array</code></a
        >
        from which to copy data.
      </li>
    </ul>
    <p>
      See
      <a href="#buffer_static_method_buffer_from_buffer"
        ><code>Buffer.from(buffer)</code></a
      >.
    </p>
    <h3 id="new-buffersize"><code>new Buffer(size)</code></h3>
    <!-- YAML
deprecated: v6.0.0
changes:
  - version: v10.0.0
    pr-url: https://github.com/nodejs/node/pull/19524
    description: Calling this constructor emits a deprecation warning when
                 run from code outside the `node_modules` directory.
  - version: v8.0.0
    pr-url: https://github.com/nodejs/node/pull/12141
    description: The `new Buffer(size)` will return zero-filled memory by
                 default.
  - version: v7.2.1
    pr-url: https://github.com/nodejs/node/pull/9529
    description: Calling this constructor no longer emits a deprecation warning.
  - version: v7.0.0
    pr-url: https://github.com/nodejs/node/pull/8169
    description: Calling this constructor emits a deprecation warning now.
-->
    <blockquote>
      <p>
        Stability: 0 - Deprecated: Use
        <a href="#buffer_static_method_buffer_alloc_size_fill_encoding"
          ><code>Buffer.alloc()</code></a
        >
        instead (also see
        <a href="#buffer_static_method_buffer_allocunsafe_size"
          ><code>Buffer.allocUnsafe()</code></a
        >).
      </p>
    </blockquote>
    <ul>
      <li>
        <code>size</code> {integer} The desired length of the new
        <code>Buffer</code>.
      </li>
    </ul>
    <p>
      See
      <a href="#buffer_static_method_buffer_alloc_size_fill_encoding"
        ><code>Buffer.alloc()</code></a
      >
      and
      <a href="#buffer_static_method_buffer_allocunsafe_size"
        ><code>Buffer.allocUnsafe()</code></a
      >. This variant of the constructor is equivalent to
      <a href="#buffer_static_method_buffer_alloc_size_fill_encoding"
        ><code>Buffer.alloc()</code></a
      >.
    </p>
    <h3 id="new-bufferstring-encoding">
      <code>new Buffer(string[, encoding])</code>
    </h3>
    <!-- YAML
deprecated: v6.0.0
changes:
  - version: v10.0.0
    pr-url: https://github.com/nodejs/node/pull/19524
    description: Calling this constructor emits a deprecation warning when
                 run from code outside the `node_modules` directory.
  - version: v7.2.1
    pr-url: https://github.com/nodejs/node/pull/9529
    description: Calling this constructor no longer emits a deprecation warning.
  - version: v7.0.0
    pr-url: https://github.com/nodejs/node/pull/8169
    description: Calling this constructor emits a deprecation warning now.
-->
    <blockquote>
      <p>
        Stability: 0 - Deprecated: Use
        <a href="#buffer_static_method_buffer_from_string_encoding"
          ><code>Buffer.from(string[, encoding])</code></a
        >
        instead.
      </p>
    </blockquote>
    <ul>
      <li><code>string</code> {string} String to encode.</li>
      <li>
        <code>encoding</code> {string} The encoding of <code>string</code>.
        <strong>Default:</strong> <code>'utf8'</code>.
      </li>
    </ul>
    <p>
      See
      <a href="#buffer_static_method_buffer_from_string_encoding"
        ><code>Buffer.from(string[, encoding])</code></a
      >.
    </p>
    <h2 id="buffer-module-apis"><code>buffer</code> module APIs</h2>
    <p>
      While, the <code>Buffer</code> object is available as a global, there are
      additional <code>Buffer</code>-related APIs that are available only via
      the <code>buffer</code> module accessed using
      <code>require('buffer')</code>.
    </p>
    <h3 id="buffer.atobdata"><code>buffer.atob(data)</code></h3>
    <!-- YAML
added:
  - v15.13.0
  - v14.17.0
-->
    <blockquote>
      <p>
        Stability: 3 - Legacy. Use
        <code>Buffer.from(data, 'base64')</code> instead.
      </p>
    </blockquote>
    <ul>
      <li><code>data</code> {any} The Base64-encoded input string.</li>
    </ul>
    <p>
      Decodes a string of Base64-encoded data into bytes, and encodes those
      bytes into a string using Latin-1 (ISO-8859-1).
    </p>
    <p>
      The <code>data</code> may be any JavaScript-value that can be coerced into
      a string.
    </p>
    <p>
      <strong
        >This function is only provided for compatibility with legacy web
        platform APIs and should never be used in new code, because they use
        strings to represent binary data and predate the introduction of typed
        arrays in JavaScript. For code running using Node.js APIs, converting
        between base64-encoded strings and binary data should be performed using
        <code>Buffer.from(str, 'base64')</code> and
        <code>buf.toString('base64')</code>.</strong
      >
    </p>
    <h3 id="buffer.btoadata"><code>buffer.btoa(data)</code></h3>
    <!-- YAML
added:
  - v15.13.0
  - v14.17.0
-->
    <blockquote>
      <p>
        Stability: 3 - Legacy. Use <code>buf.toString('base64')</code> instead.
      </p>
    </blockquote>
    <ul>
      <li><code>data</code> {any} An ASCII (Latin1) string.</li>
    </ul>
    <p>
      Decodes a string into bytes using Latin-1 (ISO-8859), and encodes those
      bytes into a string using Base64.
    </p>
    <p>
      The <code>data</code> may be any JavaScript-value that can be coerced into
      a string.
    </p>
    <p>
      <strong
        >This function is only provided for compatibility with legacy web
        platform APIs and should never be used in new code, because they use
        strings to represent binary data and predate the introduction of typed
        arrays in JavaScript. For code running using Node.js APIs, converting
        between base64-encoded strings and binary data should be performed using
        <code>Buffer.from(str, 'base64')</code> and
        <code>buf.toString('base64')</code>.</strong
      >
    </p>
    <h3 id="buffer.inspect_max_bytes"><code>buffer.INSPECT_MAX_BYTES</code></h3>
    <!-- YAML
added: v0.5.4
-->
    <ul>
      <li>{integer} <strong>Default:</strong> <code>50</code></li>
    </ul>
    <p>
      Returns the maximum number of bytes that will be returned when
      <code>buf.inspect()</code> is called. This can be overridden by user
      modules. See
      <a href="util.md#util_util_inspect_object_options"
        ><code>util.inspect()</code></a
      >
      for more details on <code>buf.inspect()</code> behavior.
    </p>
    <h3 id="buffer.kmaxlength"><code>buffer.kMaxLength</code></h3>
    <!-- YAML
added: v3.0.0
-->
    <ul>
      <li>
        {integer} The largest size allowed for a single
        <code>Buffer</code> instance.
      </li>
    </ul>
    <p>
      An alias for
      <a href="#buffer_buffer_constants_max_length"
        ><code>buffer.constants.MAX_LENGTH</code></a
      >.
    </p>
    <h3 id="buffer.kstringmaxlength"><code>buffer.kStringMaxLength</code></h3>
    <!-- YAML
added: v3.0.0
-->
    <ul>
      <li>
        {integer} The largest length allowed for a single
        <code>string</code> instance.
      </li>
    </ul>
    <p>
      An alias for
      <a href="#buffer_buffer_constants_max_string_length"
        ><code>buffer.constants.MAX_STRING_LENGTH</code></a
      >.
    </p>
    <h3 id="buffer.transcodesource-fromenc-toenc">
      <code>buffer.transcode(source, fromEnc, toEnc)</code>
    </h3>
    <!-- YAML
added: v7.1.0
changes:
  - version: v8.0.0
    pr-url: https://github.com/nodejs/node/pull/10236
    description: The `source` parameter can now be a `Uint8Array`.
-->
    <ul>
      <li>
        <code>source</code> {Buffer|Uint8Array} A <code>Buffer</code> or
        <code>Uint8Array</code> instance.
      </li>
      <li><code>fromEnc</code> {string} The current encoding.</li>
      <li><code>toEnc</code> {string} To target encoding.</li>
      <li>Returns: {Buffer}</li>
    </ul>
    <p>
      Re-encodes the given <code>Buffer</code> or
      <code>Uint8Array</code> instance from one character encoding to another.
      Returns a new <code>Buffer</code> instance.
    </p>
    <p>
      Throws if the <code>fromEnc</code> or <code>toEnc</code> specify invalid
      character encodings or if conversion from <code>fromEnc</code> to
      <code>toEnc</code> is not permitted.
    </p>
    <p>
      Encodings supported by <code>buffer.transcode()</code> are:
      <code>'ascii'</code>, <code>'utf8'</code>, <code>'utf16le'</code>,
      <code>'ucs2'</code>, <code>'latin1'</code>, and <code>'binary'</code>.
    </p>
    <p>
      The transcoding process will use substitution characters if a given byte
      sequence cannot be adequately represented in the target encoding. For
      instance:
    </p>
    <pre class="mjs"><code>import { Buffer, transcode } from &#39;buffer&#39;;

const newBuf = transcode(Buffer.from(&#39;€&#39;), &#39;utf8&#39;, &#39;ascii&#39;);
console.log(newBuf.toString(&#39;ascii&#39;));
// Prints: &#39;?&#39;</code></pre>
    <pre
      class="cjs"
    ><code>const { Buffer, transcode } = require(&#39;buffer&#39;);

const newBuf = transcode(Buffer.from(&#39;€&#39;), &#39;utf8&#39;, &#39;ascii&#39;);
console.log(newBuf.toString(&#39;ascii&#39;));
// Prints: &#39;?&#39;</code></pre>
    <p>
      Because the Euro (<code>€</code>) sign is not representable in US-ASCII,
      it is replaced with <code>?</code> in the transcoded <code>Buffer</code>.
    </p>
    <h3 id="class-slowbuffer">Class: <code>SlowBuffer</code></h3>
    <!-- YAML
deprecated: v6.0.0
-->
    <blockquote>
      <p>
        Stability: 0 - Deprecated: Use
        <a href="#buffer_static_method_buffer_allocunsafeslow_size"
          ><code>Buffer.allocUnsafeSlow()</code></a
        >
        instead.
      </p>
    </blockquote>
    <p>
      See
      <a href="#buffer_static_method_buffer_allocunsafeslow_size"
        ><code>Buffer.allocUnsafeSlow()</code></a
      >. This was never a class in the sense that the constructor always
      returned a <code>Buffer</code> instance, rather than a
      <code>SlowBuffer</code> instance.
    </p>
    <h4 id="new-slowbuffersize"><code>new SlowBuffer(size)</code></h4>
    <!-- YAML
deprecated: v6.0.0
-->
    <blockquote>
      <p>
        Stability: 0 - Deprecated: Use
        <a href="#buffer_static_method_buffer_allocunsafeslow_size"
          ><code>Buffer.allocUnsafeSlow()</code></a
        >
        instead.
      </p>
    </blockquote>
    <ul>
      <li>
        <code>size</code> {integer} The desired length of the new
        <code>SlowBuffer</code>.
      </li>
    </ul>
    <p>
      See
      <a href="#buffer_static_method_buffer_allocunsafeslow_size"
        ><code>Buffer.allocUnsafeSlow()</code></a
      >.
    </p>
    <h3 id="buffer-constants">Buffer constants</h3>
    <!-- YAML
added: v8.2.0
-->
    <h4 id="buffer.constants.max_length">
      <code>buffer.constants.MAX_LENGTH</code>
    </h4>
    <!-- YAML
added: v8.2.0
changes:
  - version: v15.0.0
    pr-url: https://github.com/nodejs/node/pull/35415
    description: Value is changed to 2<sup>32</sup> on 64-bit
      architectures.
  - version: v14.0.0
    pr-url: https://github.com/nodejs/node/pull/32116
    description: Value is changed from 2<sup>31</sup> - 1 to
      2<sup>32</sup> - 1 on 64-bit architectures.
-->
    <ul>
      <li>
        {integer} The largest size allowed for a single
        <code>Buffer</code> instance.
      </li>
    </ul>
    <p>
      On 32-bit architectures, this value currently is 2<sup>30</sup> - 1 (about
      1 GB).
    </p>
    <p>
      On 64-bit architectures, this value currently is 2<sup>32</sup> (about 4
      GB).
    </p>
    <p>
      It reflects
      <a
        href="https://v8.github.io/api/head/classv8_1_1TypedArray.html#a54a48f4373da0850663c4393d843b9b0"
        ><code>v8::TypedArray::kMaxLength</code></a
      >
      under the hood.
    </p>
    <p>
      This value is also available as
      <a href="#buffer_buffer_kmaxlength"><code>buffer.kMaxLength</code></a
      >.
    </p>
    <h4 id="buffer.constants.max_string_length">
      <code>buffer.constants.MAX_STRING_LENGTH</code>
    </h4>
    <!-- YAML
added: v8.2.0
-->
    <ul>
      <li>
        {integer} The largest length allowed for a single
        <code>string</code> instance.
      </li>
    </ul>
    <p>
      Represents the largest <code>length</code> that a
      <code>string</code> primitive can have, counted in UTF-16 code units.
    </p>
    <p>This value may depend on the JS engine that is being used.</p>
    <h2 id="buffer.from-buffer.alloc-and-buffer.allocunsafe">
      <code>Buffer.from()</code>, <code>Buffer.alloc()</code>, and
      <code>Buffer.allocUnsafe()</code>
    </h2>
    <p>
      In versions of Node.js prior to 6.0.0, <code>Buffer</code> instances were
      created using the <code>Buffer</code> constructor function, which
      allocates the returned <code>Buffer</code> differently based on what
      arguments are provided:
    </p>
    <ul>
      <li>
        Passing a number as the first argument to
        <code>Buffer()</code> (e.g. <code>new Buffer(10)</code>) allocates a new
        <code>Buffer</code> object of the specified size. Prior to Node.js
        8.0.0, the memory allocated for such <code>Buffer</code> instances is
        <em>not</em> initialized and <em>can contain sensitive data</em>. Such
        <code>Buffer</code> instances <em>must</em> be subsequently initialized
        by using either
        <a href="#buffer_buf_fill_value_offset_end_encoding"
          ><code>buf.fill(0)</code></a
        >
        or by writing to the entire <code>Buffer</code> before reading data from
        the <code>Buffer</code>. While this behavior is <em>intentional</em> to
        improve performance, development experience has demonstrated that a more
        explicit distinction is required between creating a
        fast-but-uninitialized <code>Buffer</code> versus creating a
        slower-but-safer <code>Buffer</code>. Since Node.js 8.0.0,
        <code>Buffer(num)</code> and <code>new Buffer(num)</code> return a
        <code>Buffer</code> with initialized memory.
      </li>
      <li>
        Passing a string, array, or <code>Buffer</code> as the first argument
        copies the passed object’s data into the <code>Buffer</code>.
      </li>
      <li>
        Passing an
        <a
          href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer"
          ><code>ArrayBuffer</code></a
        >
        or a
        <a
          href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer"
          ><code>SharedArrayBuffer</code></a
        >
        returns a <code>Buffer</code> that shares allocated memory with the
        given array buffer.
      </li>
    </ul>
    <p>
      Because the behavior of <code>new Buffer()</code> is different depending
      on the type of the first argument, security and reliability issues can be
      inadvertently introduced into applications when argument validation or
      <code>Buffer</code> initialization is not performed.
    </p>
    <p>
      For example, if an attacker can cause an application to receive a number
      where a string is expected, the application may call
      <code>new Buffer(100)</code> instead of <code>new Buffer("100")</code>,
      leading it to allocate a 100 byte buffer instead of allocating a 3 byte
      buffer with content <code>"100"</code>. This is commonly possible using
      JSON API calls. Since JSON distinguishes between numeric and string types,
      it allows injection of numbers where a naively written application that
      does not validate its input sufficiently might expect to always receive a
      string. Before Node.js 8.0.0, the 100 byte buffer might contain arbitrary
      pre-existing in-memory data, so may be used to expose in-memory secrets to
      a remote attacker. Since Node.js 8.0.0, exposure of memory cannot occur
      because the data is zero-filled. However, other attacks are still
      possible, such as causing very large buffers to be allocated by the
      server, leading to performance degradation or crashing on memory
      exhaustion.
    </p>
    <p>
      To make the creation of <code>Buffer</code> instances more reliable and
      less error-prone, the various forms of the
      <code>new Buffer()</code> constructor have been
      <strong>deprecated</strong> and replaced by separate
      <code>Buffer.from()</code>,
      <a href="#buffer_static_method_buffer_alloc_size_fill_encoding"
        ><code>Buffer.alloc()</code></a
      >, and
      <a href="#buffer_static_method_buffer_allocunsafe_size"
        ><code>Buffer.allocUnsafe()</code></a
      >
      methods.
    </p>
    <p>
      <em
        >Developers should migrate all existing uses of the
        <code>new Buffer()</code> constructors to one of these new APIs.</em
      >
    </p>
    <ul>
      <li>
        <a href="#buffer_static_method_buffer_from_array"
          ><code>Buffer.from(array)</code></a
        >
        returns a new <code>Buffer</code> that <em>contains a copy</em> of the
        provided octets.
      </li>
      <li>
        <a
          href="#buffer_static_method_buffer_from_arraybuffer_byteoffset_length"
          ><code>Buffer.from(arrayBuffer[, byteOffset[, length]])</code></a
        >
        returns a new <code>Buffer</code> that
        <em>shares the same allocated memory</em> as the given
        <a
          href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer"
          ><code>ArrayBuffer</code></a
        >.
      </li>
      <li>
        <a href="#buffer_static_method_buffer_from_buffer"
          ><code>Buffer.from(buffer)</code></a
        >
        returns a new <code>Buffer</code> that <em>contains a copy</em> of the
        contents of the given <code>Buffer</code>.
      </li>
      <li>
        <a href="#buffer_static_method_buffer_from_string_encoding"
          ><code>Buffer.from(string[, encoding])</code></a
        >
        returns a new <code>Buffer</code> that <em>contains a copy</em> of the
        provided string.
      </li>
      <li>
        <a href="#buffer_static_method_buffer_alloc_size_fill_encoding"
          ><code>Buffer.alloc(size[, fill[, encoding]])</code></a
        >
        returns a new initialized <code>Buffer</code> of the specified size.
        This method is slower than
        <a href="#buffer_static_method_buffer_allocunsafe_size"
          ><code>Buffer.allocUnsafe(size)</code></a
        >
        but guarantees that newly created <code>Buffer</code> instances never
        contain old data that is potentially sensitive. A
        <code>TypeError</code> will be thrown if <code>size</code> is not a
        number.
      </li>
      <li>
        <a href="#buffer_static_method_buffer_allocunsafe_size"
          ><code>Buffer.allocUnsafe(size)</code></a
        >
        and
        <a href="#buffer_static_method_buffer_allocunsafeslow_size"
          ><code>Buffer.allocUnsafeSlow(size)</code></a
        >
        each return a new uninitialized <code>Buffer</code> of the specified
        <code>size</code>. Because the <code>Buffer</code> is uninitialized, the
        allocated segment of memory might contain old data that is potentially
        sensitive.
      </li>
    </ul>
    <p>
      <code>Buffer</code> instances returned by
      <a href="#buffer_static_method_buffer_allocunsafe_size"
        ><code>Buffer.allocUnsafe()</code></a
      >
      and
      <a href="#buffer_static_method_buffer_from_array"
        ><code>Buffer.from(array)</code></a
      >
      <em>may</em> be allocated off a shared internal memory pool if
      <code>size</code> is less than or equal to half
      <a href="#buffer_class_property_buffer_poolsize"
        ><code>Buffer.poolSize</code></a
      >. Instances returned by
      <a href="#buffer_static_method_buffer_allocunsafeslow_size"
        ><code>Buffer.allocUnsafeSlow()</code></a
      >
      <em>never</em> use the shared internal memory pool.
    </p>
    <h3 id="the---zero-fill-buffers-command-line-option">
      The <code>--zero-fill-buffers</code> command-line option
    </h3>
    <!-- YAML
added: v5.10.0
-->
    <p>
      Node.js can be started using the
      <code>--zero-fill-buffers</code> command-line option to cause all
      newly-allocated <code>Buffer</code> instances to be zero-filled upon
      creation by default. Without the option, buffers created with
      <a href="#buffer_static_method_buffer_allocunsafe_size"
        ><code>Buffer.allocUnsafe()</code></a
      >,
      <a href="#buffer_static_method_buffer_allocunsafeslow_size"
        ><code>Buffer.allocUnsafeSlow()</code></a
      >, and <code>new SlowBuffer(size)</code> are not zero-filled. Use of this
      flag can have a measurable negative impact on performance. Use the
      <code>--zero-fill-buffers</code> option only when necessary to enforce
      that newly allocated <code>Buffer</code> instances cannot contain old data
      that is potentially sensitive.
    </p>
    <pre class="console"><code>$ node --zero-fill-buffers
&gt; Buffer.allocUnsafe(5);
&lt;Buffer 00 00 00 00 00&gt;</code></pre>
    <h3 id="what-makes-buffer.allocunsafe-and-buffer.allocunsafeslow-unsafe">
      What makes <code>Buffer.allocUnsafe()</code> and
      <code>Buffer.allocUnsafeSlow()</code> “unsafe”?
    </h3>
    <p>
      When calling
      <a href="#buffer_static_method_buffer_allocunsafe_size"
        ><code>Buffer.allocUnsafe()</code></a
      >
      and
      <a href="#buffer_static_method_buffer_allocunsafeslow_size"
        ><code>Buffer.allocUnsafeSlow()</code></a
      >, the segment of allocated memory is <em>uninitialized</em> (it is not
      zeroed-out). While this design makes the allocation of memory quite fast,
      the allocated segment of memory might contain old data that is potentially
      sensitive. Using a <code>Buffer</code> created by
      <a href="#buffer_static_method_buffer_allocunsafe_size"
        ><code>Buffer.allocUnsafe()</code></a
      >
      without <em>completely</em> overwriting the memory can allow this old data
      to be leaked when the <code>Buffer</code> memory is read.
    </p>
    <p>
      While there are clear performance advantages to using
      <a href="#buffer_static_method_buffer_allocunsafe_size"
        ><code>Buffer.allocUnsafe()</code></a
      >, extra care <em>must</em> be taken in order to avoid introducing
      security vulnerabilities into an application.
    </p>
  </body>
</html>
