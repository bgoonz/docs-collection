<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <meta charset="utf-8" />
    <meta name="generator" content="pandoc" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=yes"
    />
    <title>addons</title>
    <style type="text/css">
      code {
        white-space: pre-wrap;
      }
      span.smallcaps {
        font-variant: small-caps;
      }
      span.underline {
        text-decoration: underline;
      }
      div.column {
        display: inline-block;
        vertical-align: top;
        width: 50%;
      }
    </style>
    <style type="text/css">
      a.sourceLine {
        display: inline-block;
        line-height: 1.25;
      }
      a.sourceLine {
        pointer-events: none;
        color: inherit;
        text-decoration: inherit;
      }
      a.sourceLine:empty {
        height: 1.2em;
      }
      .sourceCode {
        overflow: visible;
      }
      code.sourceCode {
        white-space: pre;
        position: relative;
      }
      div.sourceCode {
        margin: 1em 0;
      }
      pre.sourceCode {
        margin: 0;
      }
      @media screen {
        div.sourceCode {
          overflow: auto;
        }
      }
      @media print {
        code.sourceCode {
          white-space: pre-wrap;
        }
        a.sourceLine {
          text-indent: -1em;
          padding-left: 1em;
        }
      }
      pre.numberSource a.sourceLine {
        position: relative;
        left: -4em;
      }
      pre.numberSource a.sourceLine::before {
        content: attr(title);
        position: relative;
        left: -1em;
        text-align: right;
        vertical-align: baseline;
        border: none;
        pointer-events: all;
        display: inline-block;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        -khtml-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        padding: 0 4px;
        width: 4em;
        color: #aaaaaa;
      }
      pre.numberSource {
        margin-left: 3em;
        border-left: 1px solid #aaaaaa;
        padding-left: 4px;
      }
      div.sourceCode {
      }
      @media screen {
        a.sourceLine::before {
          text-decoration: underline;
        }
      }
      code span.al {
        color: #ff0000;
        font-weight: bold;
      } /* Alert */
      code span.an {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* Annotation */
      code span.at {
        color: #7d9029;
      } /* Attribute */
      code span.bn {
        color: #40a070;
      } /* BaseN */
      code span.bu {
      } /* BuiltIn */
      code span.cf {
        color: #007020;
        font-weight: bold;
      } /* ControlFlow */
      code span.ch {
        color: #4070a0;
      } /* Char */
      code span.cn {
        color: #880000;
      } /* Constant */
      code span.co {
        color: #60a0b0;
        font-style: italic;
      } /* Comment */
      code span.cv {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* CommentVar */
      code span.do {
        color: #ba2121;
        font-style: italic;
      } /* Documentation */
      code span.dt {
        color: #902000;
      } /* DataType */
      code span.dv {
        color: #40a070;
      } /* DecVal */
      code span.er {
        color: #ff0000;
        font-weight: bold;
      } /* Error */
      code span.ex {
      } /* Extension */
      code span.fl {
        color: #40a070;
      } /* Float */
      code span.fu {
        color: #06287e;
      } /* Function */
      code span.im {
      } /* Import */
      code span.in {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* Information */
      code span.kw {
        color: #007020;
        font-weight: bold;
      } /* Keyword */
      code span.op {
        color: #666666;
      } /* Operator */
      code span.ot {
        color: #007020;
      } /* Other */
      code span.pp {
        color: #bc7a00;
      } /* Preprocessor */
      code span.sc {
        color: #4070a0;
      } /* SpecialChar */
      code span.ss {
        color: #bb6688;
      } /* SpecialString */
      code span.st {
        color: #4070a0;
      } /* String */
      code span.va {
        color: #19177c;
      } /* Variable */
      code span.vs {
        color: #4070a0;
      } /* VerbatimString */
      code span.wa {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* Warning */
    </style>
  </head>
  <body>
    <h1 id="c-addons">C++ addons</h1>
    <!--introduced_in=v0.10.0-->
    <!-- type=misc -->
    <p>
      <em>Addons</em> are dynamically-linked shared objects written in C++. The
      <a href="modules.md#modules_require_id"><code>require()</code></a>
      function can load addons as ordinary Node.js modules. Addons provide an
      interface between JavaScript and C/C++ libraries.
    </p>
    <p>
      There are three options for implementing addons: Node-API, nan, or direct
      use of internal V8, libuv and Node.js libraries. Unless there is a need
      for direct access to functionality which is not exposed by Node-API, use
      Node-API. Refer to <a href="n-api.md">C/C++ addons with Node-API</a> for
      more information on Node-API.
    </p>
    <p>
      When not using Node-API, implementing addons is complicated, involving
      knowledge of several components and APIs:
    </p>
    <ul>
      <li>
        <p>
          <a href="https://v8.dev/">V8</a>: the C++ library Node.js uses to
          provide the JavaScript implementation. V8 provides the mechanisms for
          creating objects, calling functions, etc. V8’s API is documented
          mostly in the <code>v8.h</code> header file (<code
            >deps/v8/include/v8.h</code
          >
          in the Node.js source tree), which is also available
          <a href="https://v8docs.nodesource.com/">online</a>.
        </p>
      </li>
      <li>
        <p>
          <a href="https://github.com/libuv/libuv">libuv</a>: The C library that
          implements the Node.js event loop, its worker threads and all of the
          asynchronous behaviors of the platform. It also serves as a
          cross-platform abstraction library, giving easy, POSIX-like access
          across all major operating systems to many common system tasks, such
          as interacting with the filesystem, sockets, timers, and system
          events. libuv also provides a threading abstraction similar to POSIX
          threads for more sophisticated asynchronous addons that need to move
          beyond the standard event loop. Addon authors should avoid blocking
          the event loop with I/O or other time-intensive tasks by offloading
          work via libuv to non-blocking system operations, worker threads, or a
          custom use of libuv threads.
        </p>
      </li>
      <li>
        <p>
          Internal Node.js libraries. Node.js itself exports C++ APIs that
          addons can use, the most important of which is the
          <code>node::ObjectWrap</code> class.
        </p>
      </li>
      <li>
        <p>
          Node.js includes other statically linked libraries including OpenSSL.
          These other libraries are located in the <code>deps/</code> directory
          in the Node.js source tree. Only the libuv, OpenSSL, V8 and zlib
          symbols are purposefully re-exported by Node.js and may be used to
          various extents by addons. See
          <a href="#addons_linking_to_libraries_included_with_node_js"
            >Linking to libraries included with Node.js</a
          >
          for additional information.
        </p>
      </li>
    </ul>
    <p>
      All of the following examples are available for
      <a href="https://github.com/nodejs/node-addon-examples">download</a> and
      may be used as the starting-point for an addon.
    </p>
    <h2 id="hello-world">Hello world</h2>
    <p>
      This “Hello world” example is a simple addon, written in C++, that is the
      equivalent of the following JavaScript code:
    </p>
    <div class="sourceCode" id="cb1">
      <pre
        class="sourceCode js"
      ><code class="sourceCode javascript"><a class="sourceLine" id="cb1-1" title="1"><span class="va">module</span>.<span class="va">exports</span>.<span class="at">hello</span> <span class="op">=</span> () <span class="kw">=&gt;</span> <span class="st">&#39;world&#39;</span><span class="op">;</span></a></code></pre>
    </div>
    <p>First, create the file <code>hello.cc</code>:</p>
    <div class="sourceCode" id="cb2">
      <pre
        class="sourceCode cpp"
      ><code class="sourceCode cpp"><a class="sourceLine" id="cb2-1" title="1"><span class="co">// hello.cc</span></a>
<a class="sourceLine" id="cb2-2" title="2"><span class="pp">#include </span><span class="im">&lt;node.h&gt;</span></a>
<a class="sourceLine" id="cb2-3" title="3"></a>
<a class="sourceLine" id="cb2-4" title="4"><span class="kw">namespace</span> demo {</a>
<a class="sourceLine" id="cb2-5" title="5"></a>
<a class="sourceLine" id="cb2-6" title="6"><span class="kw">using</span> v8::FunctionCallbackInfo;</a>
<a class="sourceLine" id="cb2-7" title="7"><span class="kw">using</span> v8::Isolate;</a>
<a class="sourceLine" id="cb2-8" title="8"><span class="kw">using</span> v8::Local;</a>
<a class="sourceLine" id="cb2-9" title="9"><span class="kw">using</span> v8::Object;</a>
<a class="sourceLine" id="cb2-10" title="10"><span class="kw">using</span> v8::String;</a>
<a class="sourceLine" id="cb2-11" title="11"><span class="kw">using</span> v8::Value;</a>
<a class="sourceLine" id="cb2-12" title="12"></a>
<a class="sourceLine" id="cb2-13" title="13"><span class="dt">void</span> Method(<span class="at">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args) {</a>
<a class="sourceLine" id="cb2-14" title="14">  Isolate* isolate = args.GetIsolate();</a>
<a class="sourceLine" id="cb2-15" title="15">  args.GetReturnValue().Set(String::NewFromUtf8(</a>
<a class="sourceLine" id="cb2-16" title="16">      isolate, <span class="st">&quot;world&quot;</span>).ToLocalChecked());</a>
<a class="sourceLine" id="cb2-17" title="17">}</a>
<a class="sourceLine" id="cb2-18" title="18"></a>
<a class="sourceLine" id="cb2-19" title="19"><span class="dt">void</span> Initialize(Local&lt;Object&gt; exports) {</a>
<a class="sourceLine" id="cb2-20" title="20">  NODE_SET_METHOD(exports, <span class="st">&quot;hello&quot;</span>, Method);</a>
<a class="sourceLine" id="cb2-21" title="21">}</a>
<a class="sourceLine" id="cb2-22" title="22"></a>
<a class="sourceLine" id="cb2-23" title="23">NODE_MODULE(NODE_GYP_MODULE_NAME, Initialize)</a>
<a class="sourceLine" id="cb2-24" title="24"></a>
<a class="sourceLine" id="cb2-25" title="25">}  <span class="co">// namespace demo</span></a></code></pre>
    </div>
    <p>
      All Node.js addons must export an initialization function following the
      pattern:
    </p>
    <div class="sourceCode" id="cb3">
      <pre
        class="sourceCode cpp"
      ><code class="sourceCode cpp"><a class="sourceLine" id="cb3-1" title="1"><span class="dt">void</span> Initialize(Local&lt;Object&gt; exports);</a>
<a class="sourceLine" id="cb3-2" title="2">NODE_MODULE(NODE_GYP_MODULE_NAME, Initialize)</a></code></pre>
    </div>
    <p>
      There is no semi-colon after <code>NODE_MODULE</code> as it’s not a
      function (see <code>node.h</code>).
    </p>
    <p>
      The <code>module_name</code> must match the filename of the final binary
      (excluding the <code>.node</code> suffix).
    </p>
    <p>
      In the <code>hello.cc</code> example, then, the initialization function is
      <code>Initialize</code> and the addon module name is <code>addon</code>.
    </p>
    <p>
      When building addons with <code>node-gyp</code>, using the macro
      <code>NODE_GYP_MODULE_NAME</code> as the first parameter of
      <code>NODE_MODULE()</code> will ensure that the name of the final binary
      will be passed to <code>NODE_MODULE()</code>.
    </p>
    <h3 id="context-aware-addons">Context-aware addons</h3>
    <p>
      There are environments in which Node.js addons may need to be loaded
      multiple times in multiple contexts. For example, the
      <a href="https://electronjs.org/">Electron</a> runtime runs multiple
      instances of Node.js in a single process. Each instance will have its own
      <code>require()</code> cache, and thus each instance will need a native
      addon to behave correctly when loaded via <code>require()</code>. This
      means that the addon must support multiple initializations.
    </p>
    <p>
      A context-aware addon can be constructed by using the macro
      <code>NODE_MODULE_INITIALIZER</code>, which expands to the name of a
      function which Node.js will expect to find when it loads an addon. An
      addon can thus be initialized as in the following example:
    </p>
    <div class="sourceCode" id="cb4">
      <pre
        class="sourceCode cpp"
      ><code class="sourceCode cpp"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">using</span> <span class="kw">namespace</span> v8;</a>
<a class="sourceLine" id="cb4-2" title="2"></a>
<a class="sourceLine" id="cb4-3" title="3"><span class="at">extern</span> <span class="st">&quot;C&quot;</span> NODE_MODULE_EXPORT <span class="dt">void</span></a>
<a class="sourceLine" id="cb4-4" title="4">NODE_MODULE_INITIALIZER(Local&lt;Object&gt; exports,</a>
<a class="sourceLine" id="cb4-5" title="5">                        Local&lt;Value&gt; module,</a>
<a class="sourceLine" id="cb4-6" title="6">                        Local&lt;Context&gt; context) {</a>
<a class="sourceLine" id="cb4-7" title="7">  <span class="co">/* Perform addon initialization steps here. */</span></a>
<a class="sourceLine" id="cb4-8" title="8">}</a></code></pre>
    </div>
    <p>
      Another option is to use the macro <code>NODE_MODULE_INIT()</code>, which
      will also construct a context-aware addon. Unlike
      <code>NODE_MODULE()</code>, which is used to construct an addon around a
      given addon initializer function, <code>NODE_MODULE_INIT()</code> serves
      as the declaration of such an initializer to be followed by a function
      body.
    </p>
    <p>
      The following three variables may be used inside the function body
      following an invocation of <code>NODE_MODULE_INIT()</code>:
    </p>
    <ul>
      <li><code>Local&lt;Object&gt; exports</code>,</li>
      <li><code>Local&lt;Value&gt; module</code>, and</li>
      <li><code>Local&lt;Context&gt; context</code></li>
    </ul>
    <p>
      The choice to build a context-aware addon carries with it the
      responsibility of carefully managing global static data. Since the addon
      may be loaded multiple times, potentially even from different threads, any
      global static data stored in the addon must be properly protected, and
      must not contain any persistent references to JavaScript objects. The
      reason for this is that JavaScript objects are only valid in one context,
      and will likely cause a crash when accessed from the wrong context or from
      a different thread than the one on which they were created.
    </p>
    <p>
      The context-aware addon can be structured to avoid global static data by
      performing the following steps:
    </p>
    <ul>
      <li>
        <p>
          Define a class which will hold per-addon-instance data and which has a
          static member of the form
        </p>
        <div class="sourceCode" id="cb5">
          <pre
            class="sourceCode cpp"
          ><code class="sourceCode cpp"><a class="sourceLine" id="cb5-1" title="1"><span class="at">static</span> <span class="dt">void</span> DeleteInstance(<span class="dt">void</span>* data) {</a>
<a class="sourceLine" id="cb5-2" title="2">  <span class="co">// Cast `data` to an instance of the class and delete it.</span></a>
<a class="sourceLine" id="cb5-3" title="3">}</a></code></pre>
        </div>
      </li>
      <li>
        Heap-allocate an instance of this class in the addon initializer. This
        can be accomplished using the <code>new</code> keyword.
      </li>
      <li>
        Call <code>node::AddEnvironmentCleanupHook()</code>, passing it the
        above-created instance and a pointer to <code>DeleteInstance()</code>.
        This will ensure the instance is deleted when the environment is torn
        down.
      </li>
      <li>
        Store the instance of the class in a <code>v8::External</code>, and
      </li>
      <li>
        <p>
          Pass the <code>v8::External</code> to all methods exposed to
          JavaScript by passing it to
          <code>v8::FunctionTemplate::New()</code> or
          <code>v8::Function::New()</code> which creates the native-backed
          JavaScript functions. The third parameter of
          <code>v8::FunctionTemplate::New()</code> or
          <code>v8::Function::New()</code> accepts the
          <code>v8::External</code> and makes it available in the native
          callback using the
          <code>v8::FunctionCallbackInfo::Data()</code> method.
        </p>
      </li>
    </ul>
    <p>
      This will ensure that the per-addon-instance data reaches each binding
      that can be called from JavaScript. The per-addon-instance data must also
      be passed into any asynchronous callbacks the addon may create.
    </p>
    <p>
      The following example illustrates the implementation of a context-aware
      addon:
    </p>
    <div class="sourceCode" id="cb6">
      <pre
        class="sourceCode cpp"
      ><code class="sourceCode cpp"><a class="sourceLine" id="cb6-1" title="1"><span class="pp">#include </span><span class="im">&lt;node.h&gt;</span></a>
<a class="sourceLine" id="cb6-2" title="2"></a>
<a class="sourceLine" id="cb6-3" title="3"><span class="kw">using</span> <span class="kw">namespace</span> v8;</a>
<a class="sourceLine" id="cb6-4" title="4"></a>
<a class="sourceLine" id="cb6-5" title="5"><span class="kw">class</span> AddonData {</a>
<a class="sourceLine" id="cb6-6" title="6"> <span class="kw">public</span>:</a>
<a class="sourceLine" id="cb6-7" title="7">  <span class="kw">explicit</span> AddonData(Isolate* isolate):</a>
<a class="sourceLine" id="cb6-8" title="8">      call_count(<span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb6-9" title="9">    <span class="co">// Ensure this per-addon-instance data is deleted at environment cleanup.</span></a>
<a class="sourceLine" id="cb6-10" title="10">    node::AddEnvironmentCleanupHook(isolate, DeleteInstance, <span class="kw">this</span>);</a>
<a class="sourceLine" id="cb6-11" title="11">  }</a>
<a class="sourceLine" id="cb6-12" title="12"></a>
<a class="sourceLine" id="cb6-13" title="13">  <span class="co">// Per-addon data.</span></a>
<a class="sourceLine" id="cb6-14" title="14">  <span class="dt">int</span> call_count;</a>
<a class="sourceLine" id="cb6-15" title="15"></a>
<a class="sourceLine" id="cb6-16" title="16">  <span class="at">static</span> <span class="dt">void</span> DeleteInstance(<span class="dt">void</span>* data) {</a>
<a class="sourceLine" id="cb6-17" title="17">    <span class="kw">delete</span> <span class="kw">static_cast</span>&lt;AddonData*&gt;(data);</a>
<a class="sourceLine" id="cb6-18" title="18">  }</a>
<a class="sourceLine" id="cb6-19" title="19">};</a>
<a class="sourceLine" id="cb6-20" title="20"></a>
<a class="sourceLine" id="cb6-21" title="21"><span class="at">static</span> <span class="dt">void</span> Method(<span class="at">const</span> v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; info) {</a>
<a class="sourceLine" id="cb6-22" title="22">  <span class="co">// Retrieve the per-addon-instance data.</span></a>
<a class="sourceLine" id="cb6-23" title="23">  AddonData* data =</a>
<a class="sourceLine" id="cb6-24" title="24">      <span class="kw">reinterpret_cast</span>&lt;AddonData*&gt;(info.Data().As&lt;External&gt;()-&gt;Value());</a>
<a class="sourceLine" id="cb6-25" title="25">  data-&gt;call_count++;</a>
<a class="sourceLine" id="cb6-26" title="26">  info.GetReturnValue().Set((<span class="dt">double</span>)data-&gt;call_count);</a>
<a class="sourceLine" id="cb6-27" title="27">}</a>
<a class="sourceLine" id="cb6-28" title="28"></a>
<a class="sourceLine" id="cb6-29" title="29"><span class="co">// Initialize this addon to be context-aware.</span></a>
<a class="sourceLine" id="cb6-30" title="30">NODE_MODULE_INIT(<span class="co">/* exports, module, context */</span>) {</a>
<a class="sourceLine" id="cb6-31" title="31">  Isolate* isolate = context-&gt;GetIsolate();</a>
<a class="sourceLine" id="cb6-32" title="32"></a>
<a class="sourceLine" id="cb6-33" title="33">  <span class="co">// Create a new instance of `AddonData` for this instance of the addon and</span></a>
<a class="sourceLine" id="cb6-34" title="34">  <span class="co">// tie its life cycle to that of the Node.js environment.</span></a>
<a class="sourceLine" id="cb6-35" title="35">  AddonData* data = <span class="kw">new</span> AddonData(isolate);</a>
<a class="sourceLine" id="cb6-36" title="36"></a>
<a class="sourceLine" id="cb6-37" title="37">  <span class="co">// Wrap the data in a `v8::External` so we can pass it to the method we</span></a>
<a class="sourceLine" id="cb6-38" title="38">  <span class="co">// expose.</span></a>
<a class="sourceLine" id="cb6-39" title="39">  Local&lt;External&gt; external = External::New(isolate, data);</a>
<a class="sourceLine" id="cb6-40" title="40"></a>
<a class="sourceLine" id="cb6-41" title="41">  <span class="co">// Expose the method `Method` to JavaScript, and make sure it receives the</span></a>
<a class="sourceLine" id="cb6-42" title="42">  <span class="co">// per-addon-instance data we created above by passing `external` as the</span></a>
<a class="sourceLine" id="cb6-43" title="43">  <span class="co">// third parameter to the `FunctionTemplate` constructor.</span></a>
<a class="sourceLine" id="cb6-44" title="44">  exports-&gt;Set(context,</a>
<a class="sourceLine" id="cb6-45" title="45">               String::NewFromUtf8(isolate, <span class="st">&quot;method&quot;</span>).ToLocalChecked(),</a>
<a class="sourceLine" id="cb6-46" title="46">               FunctionTemplate::New(isolate, Method, external)</a>
<a class="sourceLine" id="cb6-47" title="47">                  -&gt;GetFunction(context).ToLocalChecked()).FromJust();</a>
<a class="sourceLine" id="cb6-48" title="48">}</a></code></pre>
    </div>
    <h4 id="worker-support">Worker support</h4>
    <!-- YAML
changes:
  - version:
    - v14.8.0
    - v12.19.0
    pr-url: https://github.com/nodejs/node/pull/34572
    description: Cleanup hooks may now be asynchronous.
-->
    <p>
      In order to be loaded from multiple Node.js environments, such as a main
      thread and a Worker thread, an add-on needs to either:
    </p>
    <ul>
      <li>Be an Node-API addon, or</li>
      <li>
        Be declared as context-aware using <code>NODE_MODULE_INIT()</code> as
        described above
      </li>
    </ul>
    <p>
      In order to support
      <a href="worker_threads.md#worker_threads_class_worker"
        ><code>Worker</code></a
      >
      threads, addons need to clean up any resources they may have allocated
      when such a thread exists. This can be achieved through the usage of the
      <code>AddEnvironmentCleanupHook()</code> function:
    </p>
    <div class="sourceCode" id="cb7">
      <pre
        class="sourceCode cpp"
      ><code class="sourceCode cpp"><a class="sourceLine" id="cb7-1" title="1"><span class="dt">void</span> AddEnvironmentCleanupHook(v8::Isolate* isolate,</a>
<a class="sourceLine" id="cb7-2" title="2">                               <span class="dt">void</span> (*fun)(<span class="dt">void</span>* arg),</a>
<a class="sourceLine" id="cb7-3" title="3">                               <span class="dt">void</span>* arg);</a></code></pre>
    </div>
    <p>
      This function adds a hook that will run before a given Node.js instance
      shuts down. If necessary, such hooks can be removed before they are run
      using <code>RemoveEnvironmentCleanupHook()</code>, which has the same
      signature. Callbacks are run in last-in first-out order.
    </p>
    <p>
      If necessary, there is an additional pair of
      <code>AddEnvironmentCleanupHook()</code> and
      <code>RemoveEnvironmentCleanupHook()</code> overloads, where the cleanup
      hook takes a callback function. This can be used for shutting down
      asynchronous resources, such as any libuv handles registered by the addon.
    </p>
    <p>
      The following <code>addon.cc</code> uses
      <code>AddEnvironmentCleanupHook</code>:
    </p>
    <div class="sourceCode" id="cb8">
      <pre
        class="sourceCode cpp"
      ><code class="sourceCode cpp"><a class="sourceLine" id="cb8-1" title="1"><span class="co">// addon.cc</span></a>
<a class="sourceLine" id="cb8-2" title="2"><span class="pp">#include </span><span class="im">&lt;node.h&gt;</span></a>
<a class="sourceLine" id="cb8-3" title="3"><span class="pp">#include </span><span class="im">&lt;assert.h&gt;</span></a>
<a class="sourceLine" id="cb8-4" title="4"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb8-5" title="5"></a>
<a class="sourceLine" id="cb8-6" title="6"><span class="kw">using</span> node::AddEnvironmentCleanupHook;</a>
<a class="sourceLine" id="cb8-7" title="7"><span class="kw">using</span> v8::HandleScope;</a>
<a class="sourceLine" id="cb8-8" title="8"><span class="kw">using</span> v8::Isolate;</a>
<a class="sourceLine" id="cb8-9" title="9"><span class="kw">using</span> v8::Local;</a>
<a class="sourceLine" id="cb8-10" title="10"><span class="kw">using</span> v8::Object;</a>
<a class="sourceLine" id="cb8-11" title="11"></a>
<a class="sourceLine" id="cb8-12" title="12"><span class="co">// Note: In a real-world application, do not rely on static/global data.</span></a>
<a class="sourceLine" id="cb8-13" title="13"><span class="at">static</span> <span class="dt">char</span> cookie[] = <span class="st">&quot;yum yum&quot;</span>;</a>
<a class="sourceLine" id="cb8-14" title="14"><span class="at">static</span> <span class="dt">int</span> cleanup_cb1_called = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb8-15" title="15"><span class="at">static</span> <span class="dt">int</span> cleanup_cb2_called = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb8-16" title="16"></a>
<a class="sourceLine" id="cb8-17" title="17"><span class="at">static</span> <span class="dt">void</span> cleanup_cb1(<span class="dt">void</span>* arg) {</a>
<a class="sourceLine" id="cb8-18" title="18">  Isolate* isolate = <span class="kw">static_cast</span>&lt;Isolate*&gt;(arg);</a>
<a class="sourceLine" id="cb8-19" title="19">  HandleScope scope(isolate);</a>
<a class="sourceLine" id="cb8-20" title="20">  Local&lt;Object&gt; obj = Object::New(isolate);</a>
<a class="sourceLine" id="cb8-21" title="21">  <span class="ot">assert</span>(!obj.IsEmpty());  <span class="co">// assert VM is still alive</span></a>
<a class="sourceLine" id="cb8-22" title="22">  <span class="ot">assert</span>(obj-&gt;IsObject());</a>
<a class="sourceLine" id="cb8-23" title="23">  cleanup_cb1_called++;</a>
<a class="sourceLine" id="cb8-24" title="24">}</a>
<a class="sourceLine" id="cb8-25" title="25"></a>
<a class="sourceLine" id="cb8-26" title="26"><span class="at">static</span> <span class="dt">void</span> cleanup_cb2(<span class="dt">void</span>* arg) {</a>
<a class="sourceLine" id="cb8-27" title="27">  <span class="ot">assert</span>(arg == <span class="kw">static_cast</span>&lt;<span class="dt">void</span>*&gt;(cookie));</a>
<a class="sourceLine" id="cb8-28" title="28">  cleanup_cb2_called++;</a>
<a class="sourceLine" id="cb8-29" title="29">}</a>
<a class="sourceLine" id="cb8-30" title="30"></a>
<a class="sourceLine" id="cb8-31" title="31"><span class="at">static</span> <span class="dt">void</span> sanity_check(<span class="dt">void</span>*) {</a>
<a class="sourceLine" id="cb8-32" title="32">  <span class="ot">assert</span>(cleanup_cb1_called == <span class="dv">1</span>);</a>
<a class="sourceLine" id="cb8-33" title="33">  <span class="ot">assert</span>(cleanup_cb2_called == <span class="dv">1</span>);</a>
<a class="sourceLine" id="cb8-34" title="34">}</a>
<a class="sourceLine" id="cb8-35" title="35"></a>
<a class="sourceLine" id="cb8-36" title="36"><span class="co">// Initialize this addon to be context-aware.</span></a>
<a class="sourceLine" id="cb8-37" title="37">NODE_MODULE_INIT(<span class="co">/* exports, module, context */</span>) {</a>
<a class="sourceLine" id="cb8-38" title="38">  Isolate* isolate = context-&gt;GetIsolate();</a>
<a class="sourceLine" id="cb8-39" title="39"></a>
<a class="sourceLine" id="cb8-40" title="40">  AddEnvironmentCleanupHook(isolate, sanity_check, <span class="kw">nullptr</span>);</a>
<a class="sourceLine" id="cb8-41" title="41">  AddEnvironmentCleanupHook(isolate, cleanup_cb2, cookie);</a>
<a class="sourceLine" id="cb8-42" title="42">  AddEnvironmentCleanupHook(isolate, cleanup_cb1, isolate);</a>
<a class="sourceLine" id="cb8-43" title="43">}</a></code></pre>
    </div>
    <p>Test in JavaScript by running:</p>
    <div class="sourceCode" id="cb9">
      <pre
        class="sourceCode js"
      ><code class="sourceCode javascript"><a class="sourceLine" id="cb9-1" title="1"><span class="co">// test.js</span></a>
<a class="sourceLine" id="cb9-2" title="2"><span class="at">require</span>(<span class="st">&#39;./build/Release/addon&#39;</span>)<span class="op">;</span></a></code></pre>
    </div>
    <h3 id="building">Building</h3>
    <p>
      Once the source code has been written, it must be compiled into the binary
      <code>addon.node</code> file. To do so, create a file called
      <code>binding.gyp</code> in the top-level of the project describing the
      build configuration of the module using a JSON-like format. This file is
      used by <a href="https://github.com/nodejs/node-gyp">node-gyp</a>, a tool
      written specifically to compile Node.js addons.
    </p>
    <div class="sourceCode" id="cb10">
      <pre
        class="sourceCode json"
      ><code class="sourceCode json"><a class="sourceLine" id="cb10-1" title="1"><span class="fu">{</span></a>
<a class="sourceLine" id="cb10-2" title="2">  <span class="dt">&quot;targets&quot;</span><span class="fu">:</span> <span class="ot">[</span></a>
<a class="sourceLine" id="cb10-3" title="3">    <span class="fu">{</span></a>
<a class="sourceLine" id="cb10-4" title="4">      <span class="dt">&quot;target_name&quot;</span><span class="fu">:</span> <span class="st">&quot;addon&quot;</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb10-5" title="5">      <span class="dt">&quot;sources&quot;</span><span class="fu">:</span> <span class="ot">[</span> <span class="st">&quot;hello.cc&quot;</span> <span class="ot">]</span></a>
<a class="sourceLine" id="cb10-6" title="6">    <span class="fu">}</span></a>
<a class="sourceLine" id="cb10-7" title="7">  <span class="ot">]</span></a>
<a class="sourceLine" id="cb10-8" title="8"><span class="fu">}</span></a></code></pre>
    </div>
    <p>
      A version of the <code>node-gyp</code> utility is bundled and distributed
      with Node.js as part of <code>npm</code>. This version is not made
      directly available for developers to use and is intended only to support
      the ability to use the <code>npm install</code> command to compile and
      install addons. Developers who wish to use <code>node-gyp</code> directly
      can install it using the command <code>npm install -g node-gyp</code>. See
      the <code>node-gyp</code>
      <a href="https://github.com/nodejs/node-gyp#installation"
        >installation instructions</a
      >
      for more information, including platform-specific requirements.
    </p>
    <p>
      Once the <code>binding.gyp</code> file has been created, use
      <code>node-gyp configure</code> to generate the appropriate project build
      files for the current platform. This will generate either a
      <code>Makefile</code> (on Unix platforms) or a <code>vcxproj</code> file
      (on Windows) in the <code>build/</code> directory.
    </p>
    <p>
      Next, invoke the <code>node-gyp build</code> command to generate the
      compiled <code>addon.node</code> file. This will be put into the
      <code>build/Release/</code> directory.
    </p>
    <p>
      When using <code>npm install</code> to install a Node.js addon, npm uses
      its own bundled version of <code>node-gyp</code> to perform this same set
      of actions, generating a compiled version of the addon for the user’s
      platform on demand.
    </p>
    <p>
      Once built, the binary addon can be used from within Node.js by pointing
      <a href="modules.md#modules_require_id"><code>require()</code></a> to the
      built <code>addon.node</code> module:
    </p>
    <div class="sourceCode" id="cb11">
      <pre
        class="sourceCode js"
      ><code class="sourceCode javascript"><a class="sourceLine" id="cb11-1" title="1"><span class="co">// hello.js</span></a>
<a class="sourceLine" id="cb11-2" title="2"><span class="kw">const</span> addon <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;./build/Release/addon&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb11-3" title="3"></a>
<a class="sourceLine" id="cb11-4" title="4"><span class="va">console</span>.<span class="at">log</span>(<span class="va">addon</span>.<span class="at">hello</span>())<span class="op">;</span></a>
<a class="sourceLine" id="cb11-5" title="5"><span class="co">// Prints: &#39;world&#39;</span></a></code></pre>
    </div>
    <p>
      Because the exact path to the compiled addon binary can vary depending on
      how it is compiled (i.e. sometimes it may be in
      <code>./build/Debug/</code>), addons can use the
      <a href="https://github.com/TooTallNate/node-bindings">bindings</a>
      package to load the compiled module.
    </p>
    <p>
      While the <code>bindings</code> package implementation is more
      sophisticated in how it locates addon modules, it is essentially using a
      <code>try…catch</code> pattern similar to:
    </p>
    <div class="sourceCode" id="cb12">
      <pre
        class="sourceCode js"
      ><code class="sourceCode javascript"><a class="sourceLine" id="cb12-1" title="1"><span class="cf">try</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb12-2" title="2">  <span class="cf">return</span> <span class="at">require</span>(<span class="st">&#39;./build/Release/addon.node&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb12-3" title="3"><span class="op">}</span> <span class="cf">catch</span> (err) <span class="op">{</span></a>
<a class="sourceLine" id="cb12-4" title="4">  <span class="cf">return</span> <span class="at">require</span>(<span class="st">&#39;./build/Debug/addon.node&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb12-5" title="5"><span class="op">}</span></a></code></pre>
    </div>
    <h3 id="linking-to-libraries-included-with-node.js">
      Linking to libraries included with Node.js
    </h3>
    <p>
      Node.js uses statically linked libraries such as V8, libuv and OpenSSL.
      All addons are required to link to V8 and may link to any of the other
      dependencies as well. Typically, this is as simple as including the
      appropriate <code>#include &lt;...&gt;</code> statements (e.g. <code
        >#include &lt;v8.h&gt;</code
      >) and <code>node-gyp</code> will locate the appropriate headers
      automatically. However, there are a few caveats to be aware of:
    </p>
    <ul>
      <li>
        <p>
          When <code>node-gyp</code> runs, it will detect the specific release
          version of Node.js and download either the full source tarball or just
          the headers. If the full source is downloaded, addons will have
          complete access to the full set of Node.js dependencies. However, if
          only the Node.js headers are downloaded, then only the symbols
          exported by Node.js will be available.
        </p>
      </li>
      <li>
        <p>
          <code>node-gyp</code> can be run using the <code>--nodedir</code> flag
          pointing at a local Node.js source image. Using this option, the addon
          will have access to the full set of dependencies.
        </p>
      </li>
    </ul>
    <h3 id="loading-addons-using-require">
      Loading addons using <code>require()</code>
    </h3>
    <p>
      The filename extension of the compiled addon binary is
      <code>.node</code> (as opposed to <code>.dll</code> or <code>.so</code>).
      The
      <a href="modules.md#modules_require_id"><code>require()</code></a>
      function is written to look for files with the <code>.node</code> file
      extension and initialize those as dynamically-linked libraries.
    </p>
    <p>
      When calling
      <a href="modules.md#modules_require_id"><code>require()</code></a
      >, the <code>.node</code> extension can usually be omitted and Node.js
      will still find and initialize the addon. One caveat, however, is that
      Node.js will first attempt to locate and load modules or JavaScript files
      that happen to share the same base name. For instance, if there is a file
      <code>addon.js</code> in the same directory as the binary
      <code>addon.node</code>, then
      <a href="modules.md#modules_require_id"><code>require('addon')</code></a>
      will give precedence to the <code>addon.js</code> file and load it
      instead.
    </p>
    <h2 id="native-abstractions-for-node.js">
      Native abstractions for Node.js
    </h2>
    <p>
      Each of the examples illustrated in this document directly use the Node.js
      and V8 APIs for implementing addons. The V8 API can, and has, changed
      dramatically from one V8 release to the next (and one major Node.js
      release to the next). With each change, addons may need to be updated and
      recompiled in order to continue functioning. The Node.js release schedule
      is designed to minimize the frequency and impact of such changes but there
      is little that Node.js can do to ensure stability of the V8 APIs.
    </p>
    <p>
      The
      <a href="https://github.com/nodejs/nan"
        >Native Abstractions for Node.js</a
      >
      (or <code>nan</code>) provide a set of tools that addon developers are
      recommended to use to keep compatibility between past and future releases
      of V8 and Node.js. See the <code>nan</code>
      <a href="https://github.com/nodejs/nan/tree/HEAD/examples/">examples</a>
      for an illustration of how it can be used.
    </p>
    <h2 id="node-api">Node-API</h2>
    <blockquote>
      <p>Stability: 2 - Stable</p>
    </blockquote>
    <p>
      Node-API is an API for building native addons. It is independent from the
      underlying JavaScript runtime (e.g. V8) and is maintained as part of
      Node.js itself. This API will be Application Binary Interface (ABI) stable
      across versions of Node.js. It is intended to insulate addons from changes
      in the underlying JavaScript engine and allow modules compiled for one
      version to run on later versions of Node.js without recompilation. Addons
      are built/packaged with the same approach/tools outlined in this document
      (node-gyp, etc.). The only difference is the set of APIs that are used by
      the native code. Instead of using the V8 or
      <a href="https://github.com/nodejs/nan"
        >Native Abstractions for Node.js</a
      >
      APIs, the functions available in the Node-API are used.
    </p>
    <p>
      Creating and maintaining an addon that benefits from the ABI stability
      provided by Node-API carries with it certain
      <a href="n-api.md#n_api_implications_of_abi_stability"
        >implementation considerations</a
      >.
    </p>
    <p>
      To use Node-API in the above “Hello world” example, replace the content of
      <code>hello.cc</code> with the following. All other instructions remain
      the same.
    </p>
    <div class="sourceCode" id="cb13">
      <pre
        class="sourceCode cpp"
      ><code class="sourceCode cpp"><a class="sourceLine" id="cb13-1" title="1"><span class="co">// hello.cc using Node-API</span></a>
<a class="sourceLine" id="cb13-2" title="2"><span class="pp">#include </span><span class="im">&lt;node_api.h&gt;</span></a>
<a class="sourceLine" id="cb13-3" title="3"></a>
<a class="sourceLine" id="cb13-4" title="4"><span class="kw">namespace</span> demo {</a>
<a class="sourceLine" id="cb13-5" title="5"></a>
<a class="sourceLine" id="cb13-6" title="6">napi_value Method(napi_env env, napi_callback_info args) {</a>
<a class="sourceLine" id="cb13-7" title="7">  napi_value greeting;</a>
<a class="sourceLine" id="cb13-8" title="8">  napi_status status;</a>
<a class="sourceLine" id="cb13-9" title="9"></a>
<a class="sourceLine" id="cb13-10" title="10">  status = napi_create_string_utf8(env, <span class="st">&quot;world&quot;</span>, NAPI_AUTO_LENGTH, &amp;greeting);</a>
<a class="sourceLine" id="cb13-11" title="11">  <span class="cf">if</span> (status != napi_ok) <span class="cf">return</span> <span class="kw">nullptr</span>;</a>
<a class="sourceLine" id="cb13-12" title="12">  <span class="cf">return</span> greeting;</a>
<a class="sourceLine" id="cb13-13" title="13">}</a>
<a class="sourceLine" id="cb13-14" title="14"></a>
<a class="sourceLine" id="cb13-15" title="15">napi_value init(napi_env env, napi_value exports) {</a>
<a class="sourceLine" id="cb13-16" title="16">  napi_status status;</a>
<a class="sourceLine" id="cb13-17" title="17">  napi_value fn;</a>
<a class="sourceLine" id="cb13-18" title="18"></a>
<a class="sourceLine" id="cb13-19" title="19">  status = napi_create_function(env, <span class="kw">nullptr</span>, <span class="dv">0</span>, Method, <span class="kw">nullptr</span>, &amp;fn);</a>
<a class="sourceLine" id="cb13-20" title="20">  <span class="cf">if</span> (status != napi_ok) <span class="cf">return</span> <span class="kw">nullptr</span>;</a>
<a class="sourceLine" id="cb13-21" title="21"></a>
<a class="sourceLine" id="cb13-22" title="22">  status = napi_set_named_property(env, exports, <span class="st">&quot;hello&quot;</span>, fn);</a>
<a class="sourceLine" id="cb13-23" title="23">  <span class="cf">if</span> (status != napi_ok) <span class="cf">return</span> <span class="kw">nullptr</span>;</a>
<a class="sourceLine" id="cb13-24" title="24">  <span class="cf">return</span> exports;</a>
<a class="sourceLine" id="cb13-25" title="25">}</a>
<a class="sourceLine" id="cb13-26" title="26"></a>
<a class="sourceLine" id="cb13-27" title="27">NAPI_MODULE(NODE_GYP_MODULE_NAME, init)</a>
<a class="sourceLine" id="cb13-28" title="28"></a>
<a class="sourceLine" id="cb13-29" title="29">}  <span class="co">// namespace demo</span></a></code></pre>
    </div>
    <p>
      The functions available and how to use them are documented in
      <a href="n-api.md">C/C++ addons with Node-API</a>.
    </p>
    <h2 id="addon-examples">Addon examples</h2>
    <p>
      Following are some example addons intended to help developers get started.
      The examples use the V8 APIs. Refer to the online
      <a href="https://v8docs.nodesource.com/">V8 reference</a> for help with
      the various V8 calls, and V8’s
      <a href="https://github.com/v8/v8/wiki/Embedder&#39;s%20Guide"
        >Embedder’s Guide</a
      >
      for an explanation of several concepts used such as handles, scopes,
      function templates, etc.
    </p>
    <p>
      Each of these examples using the following <code>binding.gyp</code> file:
    </p>
    <div class="sourceCode" id="cb14">
      <pre
        class="sourceCode json"
      ><code class="sourceCode json"><a class="sourceLine" id="cb14-1" title="1"><span class="fu">{</span></a>
<a class="sourceLine" id="cb14-2" title="2">  <span class="dt">&quot;targets&quot;</span><span class="fu">:</span> <span class="ot">[</span></a>
<a class="sourceLine" id="cb14-3" title="3">    <span class="fu">{</span></a>
<a class="sourceLine" id="cb14-4" title="4">      <span class="dt">&quot;target_name&quot;</span><span class="fu">:</span> <span class="st">&quot;addon&quot;</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb14-5" title="5">      <span class="dt">&quot;sources&quot;</span><span class="fu">:</span> <span class="ot">[</span> <span class="st">&quot;addon.cc&quot;</span> <span class="ot">]</span></a>
<a class="sourceLine" id="cb14-6" title="6">    <span class="fu">}</span></a>
<a class="sourceLine" id="cb14-7" title="7">  <span class="ot">]</span></a>
<a class="sourceLine" id="cb14-8" title="8"><span class="fu">}</span></a></code></pre>
    </div>
    <p>
      In cases where there is more than one <code>.cc</code> file, simply add
      the additional filename to the <code>sources</code> array:
    </p>
    <div class="sourceCode" id="cb15">
      <pre
        class="sourceCode json"
      ><code class="sourceCode json"><a class="sourceLine" id="cb15-1" title="1"><span class="er">&quot;sources&quot;:</span> <span class="ot">[</span><span class="st">&quot;addon.cc&quot;</span><span class="ot">,</span> <span class="st">&quot;myexample.cc&quot;</span><span class="ot">]</span></a></code></pre>
    </div>
    <p>
      Once the <code>binding.gyp</code> file is ready, the example addons can be
      configured and built using <code>node-gyp</code>:
    </p>
    <pre class="console"><code>$ node-gyp configure build</code></pre>
    <h3 id="function-arguments">Function arguments</h3>
    <p>
      Addons will typically expose objects and functions that can be accessed
      from JavaScript running within Node.js. When functions are invoked from
      JavaScript, the input arguments and return value must be mapped to and
      from the C/C++ code.
    </p>
    <p>
      The following example illustrates how to read function arguments passed
      from JavaScript and how to return a result:
    </p>
    <div class="sourceCode" id="cb17">
      <pre
        class="sourceCode cpp"
      ><code class="sourceCode cpp"><a class="sourceLine" id="cb17-1" title="1"><span class="co">// addon.cc</span></a>
<a class="sourceLine" id="cb17-2" title="2"><span class="pp">#include </span><span class="im">&lt;node.h&gt;</span></a>
<a class="sourceLine" id="cb17-3" title="3"></a>
<a class="sourceLine" id="cb17-4" title="4"><span class="kw">namespace</span> demo {</a>
<a class="sourceLine" id="cb17-5" title="5"></a>
<a class="sourceLine" id="cb17-6" title="6"><span class="kw">using</span> v8::Exception;</a>
<a class="sourceLine" id="cb17-7" title="7"><span class="kw">using</span> v8::FunctionCallbackInfo;</a>
<a class="sourceLine" id="cb17-8" title="8"><span class="kw">using</span> v8::Isolate;</a>
<a class="sourceLine" id="cb17-9" title="9"><span class="kw">using</span> v8::Local;</a>
<a class="sourceLine" id="cb17-10" title="10"><span class="kw">using</span> v8::Number;</a>
<a class="sourceLine" id="cb17-11" title="11"><span class="kw">using</span> v8::Object;</a>
<a class="sourceLine" id="cb17-12" title="12"><span class="kw">using</span> v8::String;</a>
<a class="sourceLine" id="cb17-13" title="13"><span class="kw">using</span> v8::Value;</a>
<a class="sourceLine" id="cb17-14" title="14"></a>
<a class="sourceLine" id="cb17-15" title="15"><span class="co">// This is the implementation of the &quot;add&quot; method</span></a>
<a class="sourceLine" id="cb17-16" title="16"><span class="co">// Input arguments are passed using the</span></a>
<a class="sourceLine" id="cb17-17" title="17"><span class="co">// const FunctionCallbackInfo&lt;Value&gt;&amp; args struct</span></a>
<a class="sourceLine" id="cb17-18" title="18"><span class="dt">void</span> Add(<span class="at">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args) {</a>
<a class="sourceLine" id="cb17-19" title="19">  Isolate* isolate = args.GetIsolate();</a>
<a class="sourceLine" id="cb17-20" title="20"></a>
<a class="sourceLine" id="cb17-21" title="21">  <span class="co">// Check the number of arguments passed.</span></a>
<a class="sourceLine" id="cb17-22" title="22">  <span class="cf">if</span> (args.Length() &lt; <span class="dv">2</span>) {</a>
<a class="sourceLine" id="cb17-23" title="23">    <span class="co">// Throw an Error that is passed back to JavaScript</span></a>
<a class="sourceLine" id="cb17-24" title="24">    isolate-&gt;ThrowException(Exception::TypeError(</a>
<a class="sourceLine" id="cb17-25" title="25">        String::NewFromUtf8(isolate,</a>
<a class="sourceLine" id="cb17-26" title="26">                            <span class="st">&quot;Wrong number of arguments&quot;</span>).ToLocalChecked()));</a>
<a class="sourceLine" id="cb17-27" title="27">    <span class="cf">return</span>;</a>
<a class="sourceLine" id="cb17-28" title="28">  }</a>
<a class="sourceLine" id="cb17-29" title="29"></a>
<a class="sourceLine" id="cb17-30" title="30">  <span class="co">// Check the argument types</span></a>
<a class="sourceLine" id="cb17-31" title="31">  <span class="cf">if</span> (!args[<span class="dv">0</span>]-&gt;IsNumber() || !args[<span class="dv">1</span>]-&gt;IsNumber()) {</a>
<a class="sourceLine" id="cb17-32" title="32">    isolate-&gt;ThrowException(Exception::TypeError(</a>
<a class="sourceLine" id="cb17-33" title="33">        String::NewFromUtf8(isolate,</a>
<a class="sourceLine" id="cb17-34" title="34">                            <span class="st">&quot;Wrong arguments&quot;</span>).ToLocalChecked()));</a>
<a class="sourceLine" id="cb17-35" title="35">    <span class="cf">return</span>;</a>
<a class="sourceLine" id="cb17-36" title="36">  }</a>
<a class="sourceLine" id="cb17-37" title="37"></a>
<a class="sourceLine" id="cb17-38" title="38">  <span class="co">// Perform the operation</span></a>
<a class="sourceLine" id="cb17-39" title="39">  <span class="dt">double</span> value =</a>
<a class="sourceLine" id="cb17-40" title="40">      args[<span class="dv">0</span>].As&lt;Number&gt;()-&gt;Value() + args[<span class="dv">1</span>].As&lt;Number&gt;()-&gt;Value();</a>
<a class="sourceLine" id="cb17-41" title="41">  Local&lt;Number&gt; num = Number::New(isolate, value);</a>
<a class="sourceLine" id="cb17-42" title="42"></a>
<a class="sourceLine" id="cb17-43" title="43">  <span class="co">// Set the return value (using the passed in</span></a>
<a class="sourceLine" id="cb17-44" title="44">  <span class="co">// FunctionCallbackInfo&lt;Value&gt;&amp;)</span></a>
<a class="sourceLine" id="cb17-45" title="45">  args.GetReturnValue().Set(num);</a>
<a class="sourceLine" id="cb17-46" title="46">}</a>
<a class="sourceLine" id="cb17-47" title="47"></a>
<a class="sourceLine" id="cb17-48" title="48"><span class="dt">void</span> Init(Local&lt;Object&gt; exports) {</a>
<a class="sourceLine" id="cb17-49" title="49">  NODE_SET_METHOD(exports, <span class="st">&quot;add&quot;</span>, Add);</a>
<a class="sourceLine" id="cb17-50" title="50">}</a>
<a class="sourceLine" id="cb17-51" title="51"></a>
<a class="sourceLine" id="cb17-52" title="52">NODE_MODULE(NODE_GYP_MODULE_NAME, Init)</a>
<a class="sourceLine" id="cb17-53" title="53"></a>
<a class="sourceLine" id="cb17-54" title="54">}  <span class="co">// namespace demo</span></a></code></pre>
    </div>
    <p>
      Once compiled, the example addon can be required and used from within
      Node.js:
    </p>
    <div class="sourceCode" id="cb18">
      <pre
        class="sourceCode js"
      ><code class="sourceCode javascript"><a class="sourceLine" id="cb18-1" title="1"><span class="co">// test.js</span></a>
<a class="sourceLine" id="cb18-2" title="2"><span class="kw">const</span> addon <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;./build/Release/addon&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb18-3" title="3"></a>
<a class="sourceLine" id="cb18-4" title="4"><span class="va">console</span>.<span class="at">log</span>(<span class="st">&#39;This should be eight:&#39;</span><span class="op">,</span> <span class="va">addon</span>.<span class="at">add</span>(<span class="dv">3</span><span class="op">,</span> <span class="dv">5</span>))<span class="op">;</span></a></code></pre>
    </div>
    <h3 id="callbacks">Callbacks</h3>
    <p>
      It is common practice within addons to pass JavaScript functions to a C++
      function and execute them from there. The following example illustrates
      how to invoke such callbacks:
    </p>
    <div class="sourceCode" id="cb19">
      <pre
        class="sourceCode cpp"
      ><code class="sourceCode cpp"><a class="sourceLine" id="cb19-1" title="1"><span class="co">// addon.cc</span></a>
<a class="sourceLine" id="cb19-2" title="2"><span class="pp">#include </span><span class="im">&lt;node.h&gt;</span></a>
<a class="sourceLine" id="cb19-3" title="3"></a>
<a class="sourceLine" id="cb19-4" title="4"><span class="kw">namespace</span> demo {</a>
<a class="sourceLine" id="cb19-5" title="5"></a>
<a class="sourceLine" id="cb19-6" title="6"><span class="kw">using</span> v8::Context;</a>
<a class="sourceLine" id="cb19-7" title="7"><span class="kw">using</span> v8::Function;</a>
<a class="sourceLine" id="cb19-8" title="8"><span class="kw">using</span> v8::FunctionCallbackInfo;</a>
<a class="sourceLine" id="cb19-9" title="9"><span class="kw">using</span> v8::Isolate;</a>
<a class="sourceLine" id="cb19-10" title="10"><span class="kw">using</span> v8::Local;</a>
<a class="sourceLine" id="cb19-11" title="11"><span class="kw">using</span> v8::Null;</a>
<a class="sourceLine" id="cb19-12" title="12"><span class="kw">using</span> v8::Object;</a>
<a class="sourceLine" id="cb19-13" title="13"><span class="kw">using</span> v8::String;</a>
<a class="sourceLine" id="cb19-14" title="14"><span class="kw">using</span> v8::Value;</a>
<a class="sourceLine" id="cb19-15" title="15"></a>
<a class="sourceLine" id="cb19-16" title="16"><span class="dt">void</span> RunCallback(<span class="at">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args) {</a>
<a class="sourceLine" id="cb19-17" title="17">  Isolate* isolate = args.GetIsolate();</a>
<a class="sourceLine" id="cb19-18" title="18">  Local&lt;Context&gt; context = isolate-&gt;GetCurrentContext();</a>
<a class="sourceLine" id="cb19-19" title="19">  Local&lt;Function&gt; cb = Local&lt;Function&gt;::Cast(args[<span class="dv">0</span>]);</a>
<a class="sourceLine" id="cb19-20" title="20">  <span class="at">const</span> <span class="dt">unsigned</span> argc = <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb19-21" title="21">  Local&lt;Value&gt; argv[argc] = {</a>
<a class="sourceLine" id="cb19-22" title="22">      String::NewFromUtf8(isolate,</a>
<a class="sourceLine" id="cb19-23" title="23">                          <span class="st">&quot;hello world&quot;</span>).ToLocalChecked() };</a>
<a class="sourceLine" id="cb19-24" title="24">  cb-&gt;Call(context, Null(isolate), argc, argv).ToLocalChecked();</a>
<a class="sourceLine" id="cb19-25" title="25">}</a>
<a class="sourceLine" id="cb19-26" title="26"></a>
<a class="sourceLine" id="cb19-27" title="27"><span class="dt">void</span> Init(Local&lt;Object&gt; exports, Local&lt;Object&gt; module) {</a>
<a class="sourceLine" id="cb19-28" title="28">  NODE_SET_METHOD(module, <span class="st">&quot;exports&quot;</span>, RunCallback);</a>
<a class="sourceLine" id="cb19-29" title="29">}</a>
<a class="sourceLine" id="cb19-30" title="30"></a>
<a class="sourceLine" id="cb19-31" title="31">NODE_MODULE(NODE_GYP_MODULE_NAME, Init)</a>
<a class="sourceLine" id="cb19-32" title="32"></a>
<a class="sourceLine" id="cb19-33" title="33">}  <span class="co">// namespace demo</span></a></code></pre>
    </div>
    <p>
      This example uses a two-argument form of <code>Init()</code> that receives
      the full <code>module</code> object as the second argument. This allows
      the addon to completely overwrite <code>exports</code> with a single
      function instead of adding the function as a property of
      <code>exports</code>.
    </p>
    <p>To test it, run the following JavaScript:</p>
    <div class="sourceCode" id="cb20">
      <pre
        class="sourceCode js"
      ><code class="sourceCode javascript"><a class="sourceLine" id="cb20-1" title="1"><span class="co">// test.js</span></a>
<a class="sourceLine" id="cb20-2" title="2"><span class="kw">const</span> addon <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;./build/Release/addon&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb20-3" title="3"></a>
<a class="sourceLine" id="cb20-4" title="4"><span class="at">addon</span>((msg) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb20-5" title="5">  <span class="va">console</span>.<span class="at">log</span>(msg)<span class="op">;</span></a>
<a class="sourceLine" id="cb20-6" title="6"><span class="co">// Prints: &#39;hello world&#39;</span></a>
<a class="sourceLine" id="cb20-7" title="7"><span class="op">}</span>)<span class="op">;</span></a></code></pre>
    </div>
    <p>In this example, the callback function is invoked synchronously.</p>
    <h3 id="object-factory">Object factory</h3>
    <p>
      Addons can create and return new objects from within a C++ function as
      illustrated in the following example. An object is created and returned
      with a property <code>msg</code> that echoes the string passed to
      <code>createObject()</code>:
    </p>
    <div class="sourceCode" id="cb21">
      <pre
        class="sourceCode cpp"
      ><code class="sourceCode cpp"><a class="sourceLine" id="cb21-1" title="1"><span class="co">// addon.cc</span></a>
<a class="sourceLine" id="cb21-2" title="2"><span class="pp">#include </span><span class="im">&lt;node.h&gt;</span></a>
<a class="sourceLine" id="cb21-3" title="3"></a>
<a class="sourceLine" id="cb21-4" title="4"><span class="kw">namespace</span> demo {</a>
<a class="sourceLine" id="cb21-5" title="5"></a>
<a class="sourceLine" id="cb21-6" title="6"><span class="kw">using</span> v8::Context;</a>
<a class="sourceLine" id="cb21-7" title="7"><span class="kw">using</span> v8::FunctionCallbackInfo;</a>
<a class="sourceLine" id="cb21-8" title="8"><span class="kw">using</span> v8::Isolate;</a>
<a class="sourceLine" id="cb21-9" title="9"><span class="kw">using</span> v8::Local;</a>
<a class="sourceLine" id="cb21-10" title="10"><span class="kw">using</span> v8::Object;</a>
<a class="sourceLine" id="cb21-11" title="11"><span class="kw">using</span> v8::String;</a>
<a class="sourceLine" id="cb21-12" title="12"><span class="kw">using</span> v8::Value;</a>
<a class="sourceLine" id="cb21-13" title="13"></a>
<a class="sourceLine" id="cb21-14" title="14"><span class="dt">void</span> CreateObject(<span class="at">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args) {</a>
<a class="sourceLine" id="cb21-15" title="15">  Isolate* isolate = args.GetIsolate();</a>
<a class="sourceLine" id="cb21-16" title="16">  Local&lt;Context&gt; context = isolate-&gt;GetCurrentContext();</a>
<a class="sourceLine" id="cb21-17" title="17"></a>
<a class="sourceLine" id="cb21-18" title="18">  Local&lt;Object&gt; obj = Object::New(isolate);</a>
<a class="sourceLine" id="cb21-19" title="19">  obj-&gt;Set(context,</a>
<a class="sourceLine" id="cb21-20" title="20">           String::NewFromUtf8(isolate,</a>
<a class="sourceLine" id="cb21-21" title="21">                               <span class="st">&quot;msg&quot;</span>).ToLocalChecked(),</a>
<a class="sourceLine" id="cb21-22" title="22">                               args[<span class="dv">0</span>]-&gt;ToString(context).ToLocalChecked())</a>
<a class="sourceLine" id="cb21-23" title="23">           .FromJust();</a>
<a class="sourceLine" id="cb21-24" title="24"></a>
<a class="sourceLine" id="cb21-25" title="25">  args.GetReturnValue().Set(obj);</a>
<a class="sourceLine" id="cb21-26" title="26">}</a>
<a class="sourceLine" id="cb21-27" title="27"></a>
<a class="sourceLine" id="cb21-28" title="28"><span class="dt">void</span> Init(Local&lt;Object&gt; exports, Local&lt;Object&gt; module) {</a>
<a class="sourceLine" id="cb21-29" title="29">  NODE_SET_METHOD(module, <span class="st">&quot;exports&quot;</span>, CreateObject);</a>
<a class="sourceLine" id="cb21-30" title="30">}</a>
<a class="sourceLine" id="cb21-31" title="31"></a>
<a class="sourceLine" id="cb21-32" title="32">NODE_MODULE(NODE_GYP_MODULE_NAME, Init)</a>
<a class="sourceLine" id="cb21-33" title="33"></a>
<a class="sourceLine" id="cb21-34" title="34">}  <span class="co">// namespace demo</span></a></code></pre>
    </div>
    <p>To test it in JavaScript:</p>
    <div class="sourceCode" id="cb22">
      <pre
        class="sourceCode js"
      ><code class="sourceCode javascript"><a class="sourceLine" id="cb22-1" title="1"><span class="co">// test.js</span></a>
<a class="sourceLine" id="cb22-2" title="2"><span class="kw">const</span> addon <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;./build/Release/addon&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb22-3" title="3"></a>
<a class="sourceLine" id="cb22-4" title="4"><span class="kw">const</span> obj1 <span class="op">=</span> <span class="at">addon</span>(<span class="st">&#39;hello&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb22-5" title="5"><span class="kw">const</span> obj2 <span class="op">=</span> <span class="at">addon</span>(<span class="st">&#39;world&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb22-6" title="6"><span class="va">console</span>.<span class="at">log</span>(<span class="va">obj1</span>.<span class="at">msg</span><span class="op">,</span> <span class="va">obj2</span>.<span class="at">msg</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb22-7" title="7"><span class="co">// Prints: &#39;hello world&#39;</span></a></code></pre>
    </div>
    <h3 id="function-factory">Function factory</h3>
    <p>
      Another common scenario is creating JavaScript functions that wrap C++
      functions and returning those back to JavaScript:
    </p>
    <div class="sourceCode" id="cb23">
      <pre
        class="sourceCode cpp"
      ><code class="sourceCode cpp"><a class="sourceLine" id="cb23-1" title="1"><span class="co">// addon.cc</span></a>
<a class="sourceLine" id="cb23-2" title="2"><span class="pp">#include </span><span class="im">&lt;node.h&gt;</span></a>
<a class="sourceLine" id="cb23-3" title="3"></a>
<a class="sourceLine" id="cb23-4" title="4"><span class="kw">namespace</span> demo {</a>
<a class="sourceLine" id="cb23-5" title="5"></a>
<a class="sourceLine" id="cb23-6" title="6"><span class="kw">using</span> v8::Context;</a>
<a class="sourceLine" id="cb23-7" title="7"><span class="kw">using</span> v8::Function;</a>
<a class="sourceLine" id="cb23-8" title="8"><span class="kw">using</span> v8::FunctionCallbackInfo;</a>
<a class="sourceLine" id="cb23-9" title="9"><span class="kw">using</span> v8::FunctionTemplate;</a>
<a class="sourceLine" id="cb23-10" title="10"><span class="kw">using</span> v8::Isolate;</a>
<a class="sourceLine" id="cb23-11" title="11"><span class="kw">using</span> v8::Local;</a>
<a class="sourceLine" id="cb23-12" title="12"><span class="kw">using</span> v8::Object;</a>
<a class="sourceLine" id="cb23-13" title="13"><span class="kw">using</span> v8::String;</a>
<a class="sourceLine" id="cb23-14" title="14"><span class="kw">using</span> v8::Value;</a>
<a class="sourceLine" id="cb23-15" title="15"></a>
<a class="sourceLine" id="cb23-16" title="16"><span class="dt">void</span> MyFunction(<span class="at">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args) {</a>
<a class="sourceLine" id="cb23-17" title="17">  Isolate* isolate = args.GetIsolate();</a>
<a class="sourceLine" id="cb23-18" title="18">  args.GetReturnValue().Set(String::NewFromUtf8(</a>
<a class="sourceLine" id="cb23-19" title="19">      isolate, <span class="st">&quot;hello world&quot;</span>).ToLocalChecked());</a>
<a class="sourceLine" id="cb23-20" title="20">}</a>
<a class="sourceLine" id="cb23-21" title="21"></a>
<a class="sourceLine" id="cb23-22" title="22"><span class="dt">void</span> CreateFunction(<span class="at">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args) {</a>
<a class="sourceLine" id="cb23-23" title="23">  Isolate* isolate = args.GetIsolate();</a>
<a class="sourceLine" id="cb23-24" title="24"></a>
<a class="sourceLine" id="cb23-25" title="25">  Local&lt;Context&gt; context = isolate-&gt;GetCurrentContext();</a>
<a class="sourceLine" id="cb23-26" title="26">  Local&lt;FunctionTemplate&gt; tpl = FunctionTemplate::New(isolate, MyFunction);</a>
<a class="sourceLine" id="cb23-27" title="27">  Local&lt;Function&gt; fn = tpl-&gt;GetFunction(context).ToLocalChecked();</a>
<a class="sourceLine" id="cb23-28" title="28"></a>
<a class="sourceLine" id="cb23-29" title="29">  <span class="co">// omit this to make it anonymous</span></a>
<a class="sourceLine" id="cb23-30" title="30">  fn-&gt;SetName(String::NewFromUtf8(</a>
<a class="sourceLine" id="cb23-31" title="31">      isolate, <span class="st">&quot;theFunction&quot;</span>).ToLocalChecked());</a>
<a class="sourceLine" id="cb23-32" title="32"></a>
<a class="sourceLine" id="cb23-33" title="33">  args.GetReturnValue().Set(fn);</a>
<a class="sourceLine" id="cb23-34" title="34">}</a>
<a class="sourceLine" id="cb23-35" title="35"></a>
<a class="sourceLine" id="cb23-36" title="36"><span class="dt">void</span> Init(Local&lt;Object&gt; exports, Local&lt;Object&gt; module) {</a>
<a class="sourceLine" id="cb23-37" title="37">  NODE_SET_METHOD(module, <span class="st">&quot;exports&quot;</span>, CreateFunction);</a>
<a class="sourceLine" id="cb23-38" title="38">}</a>
<a class="sourceLine" id="cb23-39" title="39"></a>
<a class="sourceLine" id="cb23-40" title="40">NODE_MODULE(NODE_GYP_MODULE_NAME, Init)</a>
<a class="sourceLine" id="cb23-41" title="41"></a>
<a class="sourceLine" id="cb23-42" title="42">}  <span class="co">// namespace demo</span></a></code></pre>
    </div>
    <p>To test:</p>
    <div class="sourceCode" id="cb24">
      <pre
        class="sourceCode js"
      ><code class="sourceCode javascript"><a class="sourceLine" id="cb24-1" title="1"><span class="co">// test.js</span></a>
<a class="sourceLine" id="cb24-2" title="2"><span class="kw">const</span> addon <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;./build/Release/addon&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb24-3" title="3"></a>
<a class="sourceLine" id="cb24-4" title="4"><span class="kw">const</span> fn <span class="op">=</span> <span class="at">addon</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb24-5" title="5"><span class="va">console</span>.<span class="at">log</span>(<span class="at">fn</span>())<span class="op">;</span></a>
<a class="sourceLine" id="cb24-6" title="6"><span class="co">// Prints: &#39;hello world&#39;</span></a></code></pre>
    </div>
    <h3 id="wrapping-c-objects">Wrapping C++ objects</h3>
    <p>
      It is also possible to wrap C++ objects/classes in a way that allows new
      instances to be created using the JavaScript <code>new</code> operator:
    </p>
    <div class="sourceCode" id="cb25">
      <pre
        class="sourceCode cpp"
      ><code class="sourceCode cpp"><a class="sourceLine" id="cb25-1" title="1"><span class="co">// addon.cc</span></a>
<a class="sourceLine" id="cb25-2" title="2"><span class="pp">#include </span><span class="im">&lt;node.h&gt;</span></a>
<a class="sourceLine" id="cb25-3" title="3"><span class="pp">#include </span><span class="im">&quot;myobject.h&quot;</span></a>
<a class="sourceLine" id="cb25-4" title="4"></a>
<a class="sourceLine" id="cb25-5" title="5"><span class="kw">namespace</span> demo {</a>
<a class="sourceLine" id="cb25-6" title="6"></a>
<a class="sourceLine" id="cb25-7" title="7"><span class="kw">using</span> v8::Local;</a>
<a class="sourceLine" id="cb25-8" title="8"><span class="kw">using</span> v8::Object;</a>
<a class="sourceLine" id="cb25-9" title="9"></a>
<a class="sourceLine" id="cb25-10" title="10"><span class="dt">void</span> InitAll(Local&lt;Object&gt; exports) {</a>
<a class="sourceLine" id="cb25-11" title="11">  MyObject::Init(exports);</a>
<a class="sourceLine" id="cb25-12" title="12">}</a>
<a class="sourceLine" id="cb25-13" title="13"></a>
<a class="sourceLine" id="cb25-14" title="14">NODE_MODULE(NODE_GYP_MODULE_NAME, InitAll)</a>
<a class="sourceLine" id="cb25-15" title="15"></a>
<a class="sourceLine" id="cb25-16" title="16">}  <span class="co">// namespace demo</span></a></code></pre>
    </div>
    <p>
      Then, in <code>myobject.h</code>, the wrapper class inherits from
      <code>node::ObjectWrap</code>:
    </p>
    <div class="sourceCode" id="cb26">
      <pre
        class="sourceCode cpp"
      ><code class="sourceCode cpp"><a class="sourceLine" id="cb26-1" title="1"><span class="co">// myobject.h</span></a>
<a class="sourceLine" id="cb26-2" title="2"><span class="pp">#ifndef MYOBJECT_H</span></a>
<a class="sourceLine" id="cb26-3" title="3"><span class="pp">#define M</span>YOBJECT_H</a>
<a class="sourceLine" id="cb26-4" title="4"></a>
<a class="sourceLine" id="cb26-5" title="5"><span class="pp">#include </span><span class="im">&lt;node.h&gt;</span></a>
<a class="sourceLine" id="cb26-6" title="6"><span class="pp">#include </span><span class="im">&lt;node_object_wrap.h&gt;</span></a>
<a class="sourceLine" id="cb26-7" title="7"></a>
<a class="sourceLine" id="cb26-8" title="8"><span class="kw">namespace</span> demo {</a>
<a class="sourceLine" id="cb26-9" title="9"></a>
<a class="sourceLine" id="cb26-10" title="10"><span class="kw">class</span> MyObject : <span class="kw">public</span> node::ObjectWrap {</a>
<a class="sourceLine" id="cb26-11" title="11"> <span class="kw">public</span>:</a>
<a class="sourceLine" id="cb26-12" title="12">  <span class="at">static</span> <span class="dt">void</span> Init(v8::Local&lt;v8::Object&gt; exports);</a>
<a class="sourceLine" id="cb26-13" title="13"></a>
<a class="sourceLine" id="cb26-14" title="14"> <span class="kw">private</span>:</a>
<a class="sourceLine" id="cb26-15" title="15">  <span class="kw">explicit</span> MyObject(<span class="dt">double</span> value = <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb26-16" title="16">  ~MyObject();</a>
<a class="sourceLine" id="cb26-17" title="17"></a>
<a class="sourceLine" id="cb26-18" title="18">  <span class="at">static</span> <span class="dt">void</span> New(<span class="at">const</span> v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; args);</a>
<a class="sourceLine" id="cb26-19" title="19">  <span class="at">static</span> <span class="dt">void</span> PlusOne(<span class="at">const</span> v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; args);</a>
<a class="sourceLine" id="cb26-20" title="20"></a>
<a class="sourceLine" id="cb26-21" title="21">  <span class="dt">double</span> <span class="va">value_</span>;</a>
<a class="sourceLine" id="cb26-22" title="22">};</a>
<a class="sourceLine" id="cb26-23" title="23"></a>
<a class="sourceLine" id="cb26-24" title="24">}  <span class="co">// namespace demo</span></a>
<a class="sourceLine" id="cb26-25" title="25"></a>
<a class="sourceLine" id="cb26-26" title="26"><span class="pp">#endif</span></a></code></pre>
    </div>
    <p>
      In <code>myobject.cc</code>, implement the various methods that are to be
      exposed. Below, the method <code>plusOne()</code> is exposed by adding it
      to the constructor’s prototype:
    </p>
    <div class="sourceCode" id="cb27">
      <pre
        class="sourceCode cpp"
      ><code class="sourceCode cpp"><a class="sourceLine" id="cb27-1" title="1"><span class="co">// myobject.cc</span></a>
<a class="sourceLine" id="cb27-2" title="2"><span class="pp">#include </span><span class="im">&quot;myobject.h&quot;</span></a>
<a class="sourceLine" id="cb27-3" title="3"></a>
<a class="sourceLine" id="cb27-4" title="4"><span class="kw">namespace</span> demo {</a>
<a class="sourceLine" id="cb27-5" title="5"></a>
<a class="sourceLine" id="cb27-6" title="6"><span class="kw">using</span> v8::Context;</a>
<a class="sourceLine" id="cb27-7" title="7"><span class="kw">using</span> v8::Function;</a>
<a class="sourceLine" id="cb27-8" title="8"><span class="kw">using</span> v8::FunctionCallbackInfo;</a>
<a class="sourceLine" id="cb27-9" title="9"><span class="kw">using</span> v8::FunctionTemplate;</a>
<a class="sourceLine" id="cb27-10" title="10"><span class="kw">using</span> v8::Isolate;</a>
<a class="sourceLine" id="cb27-11" title="11"><span class="kw">using</span> v8::Local;</a>
<a class="sourceLine" id="cb27-12" title="12"><span class="kw">using</span> v8::Number;</a>
<a class="sourceLine" id="cb27-13" title="13"><span class="kw">using</span> v8::Object;</a>
<a class="sourceLine" id="cb27-14" title="14"><span class="kw">using</span> v8::ObjectTemplate;</a>
<a class="sourceLine" id="cb27-15" title="15"><span class="kw">using</span> v8::String;</a>
<a class="sourceLine" id="cb27-16" title="16"><span class="kw">using</span> v8::Value;</a>
<a class="sourceLine" id="cb27-17" title="17"></a>
<a class="sourceLine" id="cb27-18" title="18">MyObject::MyObject(<span class="dt">double</span> value) : <span class="va">value_</span>(value) {</a>
<a class="sourceLine" id="cb27-19" title="19">}</a>
<a class="sourceLine" id="cb27-20" title="20"></a>
<a class="sourceLine" id="cb27-21" title="21">MyObject::~MyObject() {</a>
<a class="sourceLine" id="cb27-22" title="22">}</a>
<a class="sourceLine" id="cb27-23" title="23"></a>
<a class="sourceLine" id="cb27-24" title="24"><span class="dt">void</span> MyObject::Init(Local&lt;Object&gt; exports) {</a>
<a class="sourceLine" id="cb27-25" title="25">  Isolate* isolate = exports-&gt;GetIsolate();</a>
<a class="sourceLine" id="cb27-26" title="26">  Local&lt;Context&gt; context = isolate-&gt;GetCurrentContext();</a>
<a class="sourceLine" id="cb27-27" title="27"></a>
<a class="sourceLine" id="cb27-28" title="28">  Local&lt;ObjectTemplate&gt; addon_data_tpl = ObjectTemplate::New(isolate);</a>
<a class="sourceLine" id="cb27-29" title="29">  addon_data_tpl-&gt;SetInternalFieldCount(<span class="dv">1</span>);  <span class="co">// 1 field for the MyObject::New()</span></a>
<a class="sourceLine" id="cb27-30" title="30">  Local&lt;Object&gt; addon_data =</a>
<a class="sourceLine" id="cb27-31" title="31">      addon_data_tpl-&gt;NewInstance(context).ToLocalChecked();</a>
<a class="sourceLine" id="cb27-32" title="32"></a>
<a class="sourceLine" id="cb27-33" title="33">  <span class="co">// Prepare constructor template</span></a>
<a class="sourceLine" id="cb27-34" title="34">  Local&lt;FunctionTemplate&gt; tpl = FunctionTemplate::New(isolate, New, addon_data);</a>
<a class="sourceLine" id="cb27-35" title="35">  tpl-&gt;SetClassName(String::NewFromUtf8(isolate, <span class="st">&quot;MyObject&quot;</span>).ToLocalChecked());</a>
<a class="sourceLine" id="cb27-36" title="36">  tpl-&gt;InstanceTemplate()-&gt;SetInternalFieldCount(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb27-37" title="37"></a>
<a class="sourceLine" id="cb27-38" title="38">  <span class="co">// Prototype</span></a>
<a class="sourceLine" id="cb27-39" title="39">  NODE_SET_PROTOTYPE_METHOD(tpl, <span class="st">&quot;plusOne&quot;</span>, PlusOne);</a>
<a class="sourceLine" id="cb27-40" title="40"></a>
<a class="sourceLine" id="cb27-41" title="41">  Local&lt;Function&gt; constructor = tpl-&gt;GetFunction(context).ToLocalChecked();</a>
<a class="sourceLine" id="cb27-42" title="42">  addon_data-&gt;SetInternalField(<span class="dv">0</span>, constructor);</a>
<a class="sourceLine" id="cb27-43" title="43">  exports-&gt;Set(context, String::NewFromUtf8(</a>
<a class="sourceLine" id="cb27-44" title="44">      isolate, <span class="st">&quot;MyObject&quot;</span>).ToLocalChecked(),</a>
<a class="sourceLine" id="cb27-45" title="45">      constructor).FromJust();</a>
<a class="sourceLine" id="cb27-46" title="46">}</a>
<a class="sourceLine" id="cb27-47" title="47"></a>
<a class="sourceLine" id="cb27-48" title="48"><span class="dt">void</span> MyObject::New(<span class="at">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args) {</a>
<a class="sourceLine" id="cb27-49" title="49">  Isolate* isolate = args.GetIsolate();</a>
<a class="sourceLine" id="cb27-50" title="50">  Local&lt;Context&gt; context = isolate-&gt;GetCurrentContext();</a>
<a class="sourceLine" id="cb27-51" title="51"></a>
<a class="sourceLine" id="cb27-52" title="52">  <span class="cf">if</span> (args.IsConstructCall()) {</a>
<a class="sourceLine" id="cb27-53" title="53">    <span class="co">// Invoked as constructor: `new MyObject(...)`</span></a>
<a class="sourceLine" id="cb27-54" title="54">    <span class="dt">double</span> value = args[<span class="dv">0</span>]-&gt;IsUndefined() ?</a>
<a class="sourceLine" id="cb27-55" title="55">        <span class="dv">0</span> : args[<span class="dv">0</span>]-&gt;NumberValue(context).FromMaybe(<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb27-56" title="56">    MyObject* obj = <span class="kw">new</span> MyObject(value);</a>
<a class="sourceLine" id="cb27-57" title="57">    obj-&gt;Wrap(args.This());</a>
<a class="sourceLine" id="cb27-58" title="58">    args.GetReturnValue().Set(args.This());</a>
<a class="sourceLine" id="cb27-59" title="59">  } <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb27-60" title="60">    <span class="co">// Invoked as plain function `MyObject(...)`, turn into construct call.</span></a>
<a class="sourceLine" id="cb27-61" title="61">    <span class="at">const</span> <span class="dt">int</span> argc = <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb27-62" title="62">    Local&lt;Value&gt; argv[argc] = { args[<span class="dv">0</span>] };</a>
<a class="sourceLine" id="cb27-63" title="63">    Local&lt;Function&gt; cons =</a>
<a class="sourceLine" id="cb27-64" title="64">        args.Data().As&lt;Object&gt;()-&gt;GetInternalField(<span class="dv">0</span>).As&lt;Function&gt;();</a>
<a class="sourceLine" id="cb27-65" title="65">    Local&lt;Object&gt; result =</a>
<a class="sourceLine" id="cb27-66" title="66">        cons-&gt;NewInstance(context, argc, argv).ToLocalChecked();</a>
<a class="sourceLine" id="cb27-67" title="67">    args.GetReturnValue().Set(result);</a>
<a class="sourceLine" id="cb27-68" title="68">  }</a>
<a class="sourceLine" id="cb27-69" title="69">}</a>
<a class="sourceLine" id="cb27-70" title="70"></a>
<a class="sourceLine" id="cb27-71" title="71"><span class="dt">void</span> MyObject::PlusOne(<span class="at">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args) {</a>
<a class="sourceLine" id="cb27-72" title="72">  Isolate* isolate = args.GetIsolate();</a>
<a class="sourceLine" id="cb27-73" title="73"></a>
<a class="sourceLine" id="cb27-74" title="74">  MyObject* obj = ObjectWrap::Unwrap&lt;MyObject&gt;(args.Holder());</a>
<a class="sourceLine" id="cb27-75" title="75">  obj-&gt;<span class="va">value_</span> += <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb27-76" title="76"></a>
<a class="sourceLine" id="cb27-77" title="77">  args.GetReturnValue().Set(Number::New(isolate, obj-&gt;<span class="va">value_</span>));</a>
<a class="sourceLine" id="cb27-78" title="78">}</a>
<a class="sourceLine" id="cb27-79" title="79"></a>
<a class="sourceLine" id="cb27-80" title="80">}  <span class="co">// namespace demo</span></a></code></pre>
    </div>
    <p>
      To build this example, the <code>myobject.cc</code> file must be added to
      the <code>binding.gyp</code>:
    </p>
    <div class="sourceCode" id="cb28">
      <pre
        class="sourceCode json"
      ><code class="sourceCode json"><a class="sourceLine" id="cb28-1" title="1"><span class="fu">{</span></a>
<a class="sourceLine" id="cb28-2" title="2">  <span class="dt">&quot;targets&quot;</span><span class="fu">:</span> <span class="ot">[</span></a>
<a class="sourceLine" id="cb28-3" title="3">    <span class="fu">{</span></a>
<a class="sourceLine" id="cb28-4" title="4">      <span class="dt">&quot;target_name&quot;</span><span class="fu">:</span> <span class="st">&quot;addon&quot;</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb28-5" title="5">      <span class="dt">&quot;sources&quot;</span><span class="fu">:</span> <span class="ot">[</span></a>
<a class="sourceLine" id="cb28-6" title="6">        <span class="st">&quot;addon.cc&quot;</span><span class="ot">,</span></a>
<a class="sourceLine" id="cb28-7" title="7">        <span class="st">&quot;myobject.cc&quot;</span></a>
<a class="sourceLine" id="cb28-8" title="8">      <span class="ot">]</span></a>
<a class="sourceLine" id="cb28-9" title="9">    <span class="fu">}</span></a>
<a class="sourceLine" id="cb28-10" title="10">  <span class="ot">]</span></a>
<a class="sourceLine" id="cb28-11" title="11"><span class="fu">}</span></a></code></pre>
    </div>
    <p>Test it with:</p>
    <div class="sourceCode" id="cb29">
      <pre
        class="sourceCode js"
      ><code class="sourceCode javascript"><a class="sourceLine" id="cb29-1" title="1"><span class="co">// test.js</span></a>
<a class="sourceLine" id="cb29-2" title="2"><span class="kw">const</span> addon <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;./build/Release/addon&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb29-3" title="3"></a>
<a class="sourceLine" id="cb29-4" title="4"><span class="kw">const</span> obj <span class="op">=</span> <span class="kw">new</span> <span class="va">addon</span>.<span class="at">MyObject</span>(<span class="dv">10</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb29-5" title="5"><span class="va">console</span>.<span class="at">log</span>(<span class="va">obj</span>.<span class="at">plusOne</span>())<span class="op">;</span></a>
<a class="sourceLine" id="cb29-6" title="6"><span class="co">// Prints: 11</span></a>
<a class="sourceLine" id="cb29-7" title="7"><span class="va">console</span>.<span class="at">log</span>(<span class="va">obj</span>.<span class="at">plusOne</span>())<span class="op">;</span></a>
<a class="sourceLine" id="cb29-8" title="8"><span class="co">// Prints: 12</span></a>
<a class="sourceLine" id="cb29-9" title="9"><span class="va">console</span>.<span class="at">log</span>(<span class="va">obj</span>.<span class="at">plusOne</span>())<span class="op">;</span></a>
<a class="sourceLine" id="cb29-10" title="10"><span class="co">// Prints: 13</span></a></code></pre>
    </div>
    <p>
      The destructor for a wrapper object will run when the object is
      garbage-collected. For destructor testing, there are command-line flags
      that can be used to make it possible to force garbage collection. These
      flags are provided by the underlying V8 JavaScript engine. They are
      subject to change or removal at any time. They are not documented by
      Node.js or V8, and they should never be used outside of testing.
    </p>
    <h3 id="factory-of-wrapped-objects">Factory of wrapped objects</h3>
    <p>
      Alternatively, it is possible to use a factory pattern to avoid explicitly
      creating object instances using the JavaScript <code>new</code> operator:
    </p>
    <div class="sourceCode" id="cb30">
      <pre
        class="sourceCode js"
      ><code class="sourceCode javascript"><a class="sourceLine" id="cb30-1" title="1"><span class="kw">const</span> obj <span class="op">=</span> <span class="va">addon</span>.<span class="at">createObject</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb30-2" title="2"><span class="co">// instead of:</span></a>
<a class="sourceLine" id="cb30-3" title="3"><span class="co">// const obj = new addon.Object();</span></a></code></pre>
    </div>
    <p>
      First, the <code>createObject()</code> method is implemented in
      <code>addon.cc</code>:
    </p>
    <div class="sourceCode" id="cb31">
      <pre
        class="sourceCode cpp"
      ><code class="sourceCode cpp"><a class="sourceLine" id="cb31-1" title="1"><span class="co">// addon.cc</span></a>
<a class="sourceLine" id="cb31-2" title="2"><span class="pp">#include </span><span class="im">&lt;node.h&gt;</span></a>
<a class="sourceLine" id="cb31-3" title="3"><span class="pp">#include </span><span class="im">&quot;myobject.h&quot;</span></a>
<a class="sourceLine" id="cb31-4" title="4"></a>
<a class="sourceLine" id="cb31-5" title="5"><span class="kw">namespace</span> demo {</a>
<a class="sourceLine" id="cb31-6" title="6"></a>
<a class="sourceLine" id="cb31-7" title="7"><span class="kw">using</span> v8::FunctionCallbackInfo;</a>
<a class="sourceLine" id="cb31-8" title="8"><span class="kw">using</span> v8::Isolate;</a>
<a class="sourceLine" id="cb31-9" title="9"><span class="kw">using</span> v8::Local;</a>
<a class="sourceLine" id="cb31-10" title="10"><span class="kw">using</span> v8::Object;</a>
<a class="sourceLine" id="cb31-11" title="11"><span class="kw">using</span> v8::String;</a>
<a class="sourceLine" id="cb31-12" title="12"><span class="kw">using</span> v8::Value;</a>
<a class="sourceLine" id="cb31-13" title="13"></a>
<a class="sourceLine" id="cb31-14" title="14"><span class="dt">void</span> CreateObject(<span class="at">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args) {</a>
<a class="sourceLine" id="cb31-15" title="15">  MyObject::NewInstance(args);</a>
<a class="sourceLine" id="cb31-16" title="16">}</a>
<a class="sourceLine" id="cb31-17" title="17"></a>
<a class="sourceLine" id="cb31-18" title="18"><span class="dt">void</span> InitAll(Local&lt;Object&gt; exports, Local&lt;Object&gt; module) {</a>
<a class="sourceLine" id="cb31-19" title="19">  MyObject::Init(exports-&gt;GetIsolate());</a>
<a class="sourceLine" id="cb31-20" title="20"></a>
<a class="sourceLine" id="cb31-21" title="21">  NODE_SET_METHOD(module, <span class="st">&quot;exports&quot;</span>, CreateObject);</a>
<a class="sourceLine" id="cb31-22" title="22">}</a>
<a class="sourceLine" id="cb31-23" title="23"></a>
<a class="sourceLine" id="cb31-24" title="24">NODE_MODULE(NODE_GYP_MODULE_NAME, InitAll)</a>
<a class="sourceLine" id="cb31-25" title="25"></a>
<a class="sourceLine" id="cb31-26" title="26">}  <span class="co">// namespace demo</span></a></code></pre>
    </div>
    <p>
      In <code>myobject.h</code>, the static method
      <code>NewInstance()</code> is added to handle instantiating the object.
      This method takes the place of using <code>new</code> in JavaScript:
    </p>
    <div class="sourceCode" id="cb32">
      <pre
        class="sourceCode cpp"
      ><code class="sourceCode cpp"><a class="sourceLine" id="cb32-1" title="1"><span class="co">// myobject.h</span></a>
<a class="sourceLine" id="cb32-2" title="2"><span class="pp">#ifndef MYOBJECT_H</span></a>
<a class="sourceLine" id="cb32-3" title="3"><span class="pp">#define M</span>YOBJECT_H</a>
<a class="sourceLine" id="cb32-4" title="4"></a>
<a class="sourceLine" id="cb32-5" title="5"><span class="pp">#include </span><span class="im">&lt;node.h&gt;</span></a>
<a class="sourceLine" id="cb32-6" title="6"><span class="pp">#include </span><span class="im">&lt;node_object_wrap.h&gt;</span></a>
<a class="sourceLine" id="cb32-7" title="7"></a>
<a class="sourceLine" id="cb32-8" title="8"><span class="kw">namespace</span> demo {</a>
<a class="sourceLine" id="cb32-9" title="9"></a>
<a class="sourceLine" id="cb32-10" title="10"><span class="kw">class</span> MyObject : <span class="kw">public</span> node::ObjectWrap {</a>
<a class="sourceLine" id="cb32-11" title="11"> <span class="kw">public</span>:</a>
<a class="sourceLine" id="cb32-12" title="12">  <span class="at">static</span> <span class="dt">void</span> Init(v8::Isolate* isolate);</a>
<a class="sourceLine" id="cb32-13" title="13">  <span class="at">static</span> <span class="dt">void</span> NewInstance(<span class="at">const</span> v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; args);</a>
<a class="sourceLine" id="cb32-14" title="14"></a>
<a class="sourceLine" id="cb32-15" title="15"> <span class="kw">private</span>:</a>
<a class="sourceLine" id="cb32-16" title="16">  <span class="kw">explicit</span> MyObject(<span class="dt">double</span> value = <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb32-17" title="17">  ~MyObject();</a>
<a class="sourceLine" id="cb32-18" title="18"></a>
<a class="sourceLine" id="cb32-19" title="19">  <span class="at">static</span> <span class="dt">void</span> New(<span class="at">const</span> v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; args);</a>
<a class="sourceLine" id="cb32-20" title="20">  <span class="at">static</span> <span class="dt">void</span> PlusOne(<span class="at">const</span> v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; args);</a>
<a class="sourceLine" id="cb32-21" title="21">  <span class="at">static</span> v8::Global&lt;v8::Function&gt; constructor;</a>
<a class="sourceLine" id="cb32-22" title="22">  <span class="dt">double</span> <span class="va">value_</span>;</a>
<a class="sourceLine" id="cb32-23" title="23">};</a>
<a class="sourceLine" id="cb32-24" title="24"></a>
<a class="sourceLine" id="cb32-25" title="25">}  <span class="co">// namespace demo</span></a>
<a class="sourceLine" id="cb32-26" title="26"></a>
<a class="sourceLine" id="cb32-27" title="27"><span class="pp">#endif</span></a></code></pre>
    </div>
    <p>
      The implementation in <code>myobject.cc</code> is similar to the previous
      example:
    </p>
    <div class="sourceCode" id="cb33">
      <pre
        class="sourceCode cpp"
      ><code class="sourceCode cpp"><a class="sourceLine" id="cb33-1" title="1"><span class="co">// myobject.cc</span></a>
<a class="sourceLine" id="cb33-2" title="2"><span class="pp">#include </span><span class="im">&lt;node.h&gt;</span></a>
<a class="sourceLine" id="cb33-3" title="3"><span class="pp">#include </span><span class="im">&quot;myobject.h&quot;</span></a>
<a class="sourceLine" id="cb33-4" title="4"></a>
<a class="sourceLine" id="cb33-5" title="5"><span class="kw">namespace</span> demo {</a>
<a class="sourceLine" id="cb33-6" title="6"></a>
<a class="sourceLine" id="cb33-7" title="7"><span class="kw">using</span> node::AddEnvironmentCleanupHook;</a>
<a class="sourceLine" id="cb33-8" title="8"><span class="kw">using</span> v8::Context;</a>
<a class="sourceLine" id="cb33-9" title="9"><span class="kw">using</span> v8::Function;</a>
<a class="sourceLine" id="cb33-10" title="10"><span class="kw">using</span> v8::FunctionCallbackInfo;</a>
<a class="sourceLine" id="cb33-11" title="11"><span class="kw">using</span> v8::FunctionTemplate;</a>
<a class="sourceLine" id="cb33-12" title="12"><span class="kw">using</span> v8::Global;</a>
<a class="sourceLine" id="cb33-13" title="13"><span class="kw">using</span> v8::Isolate;</a>
<a class="sourceLine" id="cb33-14" title="14"><span class="kw">using</span> v8::Local;</a>
<a class="sourceLine" id="cb33-15" title="15"><span class="kw">using</span> v8::Number;</a>
<a class="sourceLine" id="cb33-16" title="16"><span class="kw">using</span> v8::Object;</a>
<a class="sourceLine" id="cb33-17" title="17"><span class="kw">using</span> v8::String;</a>
<a class="sourceLine" id="cb33-18" title="18"><span class="kw">using</span> v8::Value;</a>
<a class="sourceLine" id="cb33-19" title="19"></a>
<a class="sourceLine" id="cb33-20" title="20"><span class="co">// Warning! This is not thread-safe, this addon cannot be used for worker</span></a>
<a class="sourceLine" id="cb33-21" title="21"><span class="co">// threads.</span></a>
<a class="sourceLine" id="cb33-22" title="22">Global&lt;Function&gt; MyObject::constructor;</a>
<a class="sourceLine" id="cb33-23" title="23"></a>
<a class="sourceLine" id="cb33-24" title="24">MyObject::MyObject(<span class="dt">double</span> value) : <span class="va">value_</span>(value) {</a>
<a class="sourceLine" id="cb33-25" title="25">}</a>
<a class="sourceLine" id="cb33-26" title="26"></a>
<a class="sourceLine" id="cb33-27" title="27">MyObject::~MyObject() {</a>
<a class="sourceLine" id="cb33-28" title="28">}</a>
<a class="sourceLine" id="cb33-29" title="29"></a>
<a class="sourceLine" id="cb33-30" title="30"><span class="dt">void</span> MyObject::Init(Isolate* isolate) {</a>
<a class="sourceLine" id="cb33-31" title="31">  <span class="co">// Prepare constructor template</span></a>
<a class="sourceLine" id="cb33-32" title="32">  Local&lt;FunctionTemplate&gt; tpl = FunctionTemplate::New(isolate, New);</a>
<a class="sourceLine" id="cb33-33" title="33">  tpl-&gt;SetClassName(String::NewFromUtf8(isolate, <span class="st">&quot;MyObject&quot;</span>).ToLocalChecked());</a>
<a class="sourceLine" id="cb33-34" title="34">  tpl-&gt;InstanceTemplate()-&gt;SetInternalFieldCount(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb33-35" title="35"></a>
<a class="sourceLine" id="cb33-36" title="36">  <span class="co">// Prototype</span></a>
<a class="sourceLine" id="cb33-37" title="37">  NODE_SET_PROTOTYPE_METHOD(tpl, <span class="st">&quot;plusOne&quot;</span>, PlusOne);</a>
<a class="sourceLine" id="cb33-38" title="38"></a>
<a class="sourceLine" id="cb33-39" title="39">  Local&lt;Context&gt; context = isolate-&gt;GetCurrentContext();</a>
<a class="sourceLine" id="cb33-40" title="40">  constructor.Reset(isolate, tpl-&gt;GetFunction(context).ToLocalChecked());</a>
<a class="sourceLine" id="cb33-41" title="41"></a>
<a class="sourceLine" id="cb33-42" title="42">  AddEnvironmentCleanupHook(isolate, [](<span class="dt">void</span>*) {</a>
<a class="sourceLine" id="cb33-43" title="43">    constructor.Reset();</a>
<a class="sourceLine" id="cb33-44" title="44">  }, <span class="kw">nullptr</span>);</a>
<a class="sourceLine" id="cb33-45" title="45">}</a>
<a class="sourceLine" id="cb33-46" title="46"></a>
<a class="sourceLine" id="cb33-47" title="47"><span class="dt">void</span> MyObject::New(<span class="at">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args) {</a>
<a class="sourceLine" id="cb33-48" title="48">  Isolate* isolate = args.GetIsolate();</a>
<a class="sourceLine" id="cb33-49" title="49">  Local&lt;Context&gt; context = isolate-&gt;GetCurrentContext();</a>
<a class="sourceLine" id="cb33-50" title="50"></a>
<a class="sourceLine" id="cb33-51" title="51">  <span class="cf">if</span> (args.IsConstructCall()) {</a>
<a class="sourceLine" id="cb33-52" title="52">    <span class="co">// Invoked as constructor: `new MyObject(...)`</span></a>
<a class="sourceLine" id="cb33-53" title="53">    <span class="dt">double</span> value = args[<span class="dv">0</span>]-&gt;IsUndefined() ?</a>
<a class="sourceLine" id="cb33-54" title="54">        <span class="dv">0</span> : args[<span class="dv">0</span>]-&gt;NumberValue(context).FromMaybe(<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb33-55" title="55">    MyObject* obj = <span class="kw">new</span> MyObject(value);</a>
<a class="sourceLine" id="cb33-56" title="56">    obj-&gt;Wrap(args.This());</a>
<a class="sourceLine" id="cb33-57" title="57">    args.GetReturnValue().Set(args.This());</a>
<a class="sourceLine" id="cb33-58" title="58">  } <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb33-59" title="59">    <span class="co">// Invoked as plain function `MyObject(...)`, turn into construct call.</span></a>
<a class="sourceLine" id="cb33-60" title="60">    <span class="at">const</span> <span class="dt">int</span> argc = <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb33-61" title="61">    Local&lt;Value&gt; argv[argc] = { args[<span class="dv">0</span>] };</a>
<a class="sourceLine" id="cb33-62" title="62">    Local&lt;Function&gt; cons = Local&lt;Function&gt;::New(isolate, constructor);</a>
<a class="sourceLine" id="cb33-63" title="63">    Local&lt;Object&gt; instance =</a>
<a class="sourceLine" id="cb33-64" title="64">        cons-&gt;NewInstance(context, argc, argv).ToLocalChecked();</a>
<a class="sourceLine" id="cb33-65" title="65">    args.GetReturnValue().Set(instance);</a>
<a class="sourceLine" id="cb33-66" title="66">  }</a>
<a class="sourceLine" id="cb33-67" title="67">}</a>
<a class="sourceLine" id="cb33-68" title="68"></a>
<a class="sourceLine" id="cb33-69" title="69"><span class="dt">void</span> MyObject::NewInstance(<span class="at">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args) {</a>
<a class="sourceLine" id="cb33-70" title="70">  Isolate* isolate = args.GetIsolate();</a>
<a class="sourceLine" id="cb33-71" title="71"></a>
<a class="sourceLine" id="cb33-72" title="72">  <span class="at">const</span> <span class="dt">unsigned</span> argc = <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb33-73" title="73">  Local&lt;Value&gt; argv[argc] = { args[<span class="dv">0</span>] };</a>
<a class="sourceLine" id="cb33-74" title="74">  Local&lt;Function&gt; cons = Local&lt;Function&gt;::New(isolate, constructor);</a>
<a class="sourceLine" id="cb33-75" title="75">  Local&lt;Context&gt; context = isolate-&gt;GetCurrentContext();</a>
<a class="sourceLine" id="cb33-76" title="76">  Local&lt;Object&gt; instance =</a>
<a class="sourceLine" id="cb33-77" title="77">      cons-&gt;NewInstance(context, argc, argv).ToLocalChecked();</a>
<a class="sourceLine" id="cb33-78" title="78"></a>
<a class="sourceLine" id="cb33-79" title="79">  args.GetReturnValue().Set(instance);</a>
<a class="sourceLine" id="cb33-80" title="80">}</a>
<a class="sourceLine" id="cb33-81" title="81"></a>
<a class="sourceLine" id="cb33-82" title="82"><span class="dt">void</span> MyObject::PlusOne(<span class="at">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args) {</a>
<a class="sourceLine" id="cb33-83" title="83">  Isolate* isolate = args.GetIsolate();</a>
<a class="sourceLine" id="cb33-84" title="84"></a>
<a class="sourceLine" id="cb33-85" title="85">  MyObject* obj = ObjectWrap::Unwrap&lt;MyObject&gt;(args.Holder());</a>
<a class="sourceLine" id="cb33-86" title="86">  obj-&gt;<span class="va">value_</span> += <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb33-87" title="87"></a>
<a class="sourceLine" id="cb33-88" title="88">  args.GetReturnValue().Set(Number::New(isolate, obj-&gt;<span class="va">value_</span>));</a>
<a class="sourceLine" id="cb33-89" title="89">}</a>
<a class="sourceLine" id="cb33-90" title="90"></a>
<a class="sourceLine" id="cb33-91" title="91">}  <span class="co">// namespace demo</span></a></code></pre>
    </div>
    <p>
      Once again, to build this example, the <code>myobject.cc</code> file must
      be added to the <code>binding.gyp</code>:
    </p>
    <div class="sourceCode" id="cb34">
      <pre
        class="sourceCode json"
      ><code class="sourceCode json"><a class="sourceLine" id="cb34-1" title="1"><span class="fu">{</span></a>
<a class="sourceLine" id="cb34-2" title="2">  <span class="dt">&quot;targets&quot;</span><span class="fu">:</span> <span class="ot">[</span></a>
<a class="sourceLine" id="cb34-3" title="3">    <span class="fu">{</span></a>
<a class="sourceLine" id="cb34-4" title="4">      <span class="dt">&quot;target_name&quot;</span><span class="fu">:</span> <span class="st">&quot;addon&quot;</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb34-5" title="5">      <span class="dt">&quot;sources&quot;</span><span class="fu">:</span> <span class="ot">[</span></a>
<a class="sourceLine" id="cb34-6" title="6">        <span class="st">&quot;addon.cc&quot;</span><span class="ot">,</span></a>
<a class="sourceLine" id="cb34-7" title="7">        <span class="st">&quot;myobject.cc&quot;</span></a>
<a class="sourceLine" id="cb34-8" title="8">      <span class="ot">]</span></a>
<a class="sourceLine" id="cb34-9" title="9">    <span class="fu">}</span></a>
<a class="sourceLine" id="cb34-10" title="10">  <span class="ot">]</span></a>
<a class="sourceLine" id="cb34-11" title="11"><span class="fu">}</span></a></code></pre>
    </div>
    <p>Test it with:</p>
    <div class="sourceCode" id="cb35">
      <pre
        class="sourceCode js"
      ><code class="sourceCode javascript"><a class="sourceLine" id="cb35-1" title="1"><span class="co">// test.js</span></a>
<a class="sourceLine" id="cb35-2" title="2"><span class="kw">const</span> createObject <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;./build/Release/addon&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb35-3" title="3"></a>
<a class="sourceLine" id="cb35-4" title="4"><span class="kw">const</span> obj <span class="op">=</span> <span class="at">createObject</span>(<span class="dv">10</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb35-5" title="5"><span class="va">console</span>.<span class="at">log</span>(<span class="va">obj</span>.<span class="at">plusOne</span>())<span class="op">;</span></a>
<a class="sourceLine" id="cb35-6" title="6"><span class="co">// Prints: 11</span></a>
<a class="sourceLine" id="cb35-7" title="7"><span class="va">console</span>.<span class="at">log</span>(<span class="va">obj</span>.<span class="at">plusOne</span>())<span class="op">;</span></a>
<a class="sourceLine" id="cb35-8" title="8"><span class="co">// Prints: 12</span></a>
<a class="sourceLine" id="cb35-9" title="9"><span class="va">console</span>.<span class="at">log</span>(<span class="va">obj</span>.<span class="at">plusOne</span>())<span class="op">;</span></a>
<a class="sourceLine" id="cb35-10" title="10"><span class="co">// Prints: 13</span></a>
<a class="sourceLine" id="cb35-11" title="11"></a>
<a class="sourceLine" id="cb35-12" title="12"><span class="kw">const</span> obj2 <span class="op">=</span> <span class="at">createObject</span>(<span class="dv">20</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb35-13" title="13"><span class="va">console</span>.<span class="at">log</span>(<span class="va">obj2</span>.<span class="at">plusOne</span>())<span class="op">;</span></a>
<a class="sourceLine" id="cb35-14" title="14"><span class="co">// Prints: 21</span></a>
<a class="sourceLine" id="cb35-15" title="15"><span class="va">console</span>.<span class="at">log</span>(<span class="va">obj2</span>.<span class="at">plusOne</span>())<span class="op">;</span></a>
<a class="sourceLine" id="cb35-16" title="16"><span class="co">// Prints: 22</span></a>
<a class="sourceLine" id="cb35-17" title="17"><span class="va">console</span>.<span class="at">log</span>(<span class="va">obj2</span>.<span class="at">plusOne</span>())<span class="op">;</span></a>
<a class="sourceLine" id="cb35-18" title="18"><span class="co">// Prints: 23</span></a></code></pre>
    </div>
    <h3 id="passing-wrapped-objects-around">Passing wrapped objects around</h3>
    <p>
      In addition to wrapping and returning C++ objects, it is possible to pass
      wrapped objects around by unwrapping them with the Node.js helper function
      <code>node::ObjectWrap::Unwrap</code>. The following examples shows a
      function <code>add()</code> that can take two
      <code>MyObject</code> objects as input arguments:
    </p>
    <div class="sourceCode" id="cb36">
      <pre
        class="sourceCode cpp"
      ><code class="sourceCode cpp"><a class="sourceLine" id="cb36-1" title="1"><span class="co">// addon.cc</span></a>
<a class="sourceLine" id="cb36-2" title="2"><span class="pp">#include </span><span class="im">&lt;node.h&gt;</span></a>
<a class="sourceLine" id="cb36-3" title="3"><span class="pp">#include </span><span class="im">&lt;node_object_wrap.h&gt;</span></a>
<a class="sourceLine" id="cb36-4" title="4"><span class="pp">#include </span><span class="im">&quot;myobject.h&quot;</span></a>
<a class="sourceLine" id="cb36-5" title="5"></a>
<a class="sourceLine" id="cb36-6" title="6"><span class="kw">namespace</span> demo {</a>
<a class="sourceLine" id="cb36-7" title="7"></a>
<a class="sourceLine" id="cb36-8" title="8"><span class="kw">using</span> v8::Context;</a>
<a class="sourceLine" id="cb36-9" title="9"><span class="kw">using</span> v8::FunctionCallbackInfo;</a>
<a class="sourceLine" id="cb36-10" title="10"><span class="kw">using</span> v8::Isolate;</a>
<a class="sourceLine" id="cb36-11" title="11"><span class="kw">using</span> v8::Local;</a>
<a class="sourceLine" id="cb36-12" title="12"><span class="kw">using</span> v8::Number;</a>
<a class="sourceLine" id="cb36-13" title="13"><span class="kw">using</span> v8::Object;</a>
<a class="sourceLine" id="cb36-14" title="14"><span class="kw">using</span> v8::String;</a>
<a class="sourceLine" id="cb36-15" title="15"><span class="kw">using</span> v8::Value;</a>
<a class="sourceLine" id="cb36-16" title="16"></a>
<a class="sourceLine" id="cb36-17" title="17"><span class="dt">void</span> CreateObject(<span class="at">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args) {</a>
<a class="sourceLine" id="cb36-18" title="18">  MyObject::NewInstance(args);</a>
<a class="sourceLine" id="cb36-19" title="19">}</a>
<a class="sourceLine" id="cb36-20" title="20"></a>
<a class="sourceLine" id="cb36-21" title="21"><span class="dt">void</span> Add(<span class="at">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args) {</a>
<a class="sourceLine" id="cb36-22" title="22">  Isolate* isolate = args.GetIsolate();</a>
<a class="sourceLine" id="cb36-23" title="23">  Local&lt;Context&gt; context = isolate-&gt;GetCurrentContext();</a>
<a class="sourceLine" id="cb36-24" title="24"></a>
<a class="sourceLine" id="cb36-25" title="25">  MyObject* obj1 = node::ObjectWrap::Unwrap&lt;MyObject&gt;(</a>
<a class="sourceLine" id="cb36-26" title="26">      args[<span class="dv">0</span>]-&gt;ToObject(context).ToLocalChecked());</a>
<a class="sourceLine" id="cb36-27" title="27">  MyObject* obj2 = node::ObjectWrap::Unwrap&lt;MyObject&gt;(</a>
<a class="sourceLine" id="cb36-28" title="28">      args[<span class="dv">1</span>]-&gt;ToObject(context).ToLocalChecked());</a>
<a class="sourceLine" id="cb36-29" title="29"></a>
<a class="sourceLine" id="cb36-30" title="30">  <span class="dt">double</span> sum = obj1-&gt;value() + obj2-&gt;value();</a>
<a class="sourceLine" id="cb36-31" title="31">  args.GetReturnValue().Set(Number::New(isolate, sum));</a>
<a class="sourceLine" id="cb36-32" title="32">}</a>
<a class="sourceLine" id="cb36-33" title="33"></a>
<a class="sourceLine" id="cb36-34" title="34"><span class="dt">void</span> InitAll(Local&lt;Object&gt; exports) {</a>
<a class="sourceLine" id="cb36-35" title="35">  MyObject::Init(exports-&gt;GetIsolate());</a>
<a class="sourceLine" id="cb36-36" title="36"></a>
<a class="sourceLine" id="cb36-37" title="37">  NODE_SET_METHOD(exports, <span class="st">&quot;createObject&quot;</span>, CreateObject);</a>
<a class="sourceLine" id="cb36-38" title="38">  NODE_SET_METHOD(exports, <span class="st">&quot;add&quot;</span>, Add);</a>
<a class="sourceLine" id="cb36-39" title="39">}</a>
<a class="sourceLine" id="cb36-40" title="40"></a>
<a class="sourceLine" id="cb36-41" title="41">NODE_MODULE(NODE_GYP_MODULE_NAME, InitAll)</a>
<a class="sourceLine" id="cb36-42" title="42"></a>
<a class="sourceLine" id="cb36-43" title="43">}  <span class="co">// namespace demo</span></a></code></pre>
    </div>
    <p>
      In <code>myobject.h</code>, a new public method is added to allow access
      to private values after unwrapping the object.
    </p>
    <div class="sourceCode" id="cb37">
      <pre
        class="sourceCode cpp"
      ><code class="sourceCode cpp"><a class="sourceLine" id="cb37-1" title="1"><span class="co">// myobject.h</span></a>
<a class="sourceLine" id="cb37-2" title="2"><span class="pp">#ifndef MYOBJECT_H</span></a>
<a class="sourceLine" id="cb37-3" title="3"><span class="pp">#define M</span>YOBJECT_H</a>
<a class="sourceLine" id="cb37-4" title="4"></a>
<a class="sourceLine" id="cb37-5" title="5"><span class="pp">#include </span><span class="im">&lt;node.h&gt;</span></a>
<a class="sourceLine" id="cb37-6" title="6"><span class="pp">#include </span><span class="im">&lt;node_object_wrap.h&gt;</span></a>
<a class="sourceLine" id="cb37-7" title="7"></a>
<a class="sourceLine" id="cb37-8" title="8"><span class="kw">namespace</span> demo {</a>
<a class="sourceLine" id="cb37-9" title="9"></a>
<a class="sourceLine" id="cb37-10" title="10"><span class="kw">class</span> MyObject : <span class="kw">public</span> node::ObjectWrap {</a>
<a class="sourceLine" id="cb37-11" title="11"> <span class="kw">public</span>:</a>
<a class="sourceLine" id="cb37-12" title="12">  <span class="at">static</span> <span class="dt">void</span> Init(v8::Isolate* isolate);</a>
<a class="sourceLine" id="cb37-13" title="13">  <span class="at">static</span> <span class="dt">void</span> NewInstance(<span class="at">const</span> v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; args);</a>
<a class="sourceLine" id="cb37-14" title="14">  <span class="kw">inline</span> <span class="dt">double</span> value() <span class="at">const</span> { <span class="cf">return</span> <span class="va">value_</span>; }</a>
<a class="sourceLine" id="cb37-15" title="15"></a>
<a class="sourceLine" id="cb37-16" title="16"> <span class="kw">private</span>:</a>
<a class="sourceLine" id="cb37-17" title="17">  <span class="kw">explicit</span> MyObject(<span class="dt">double</span> value = <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb37-18" title="18">  ~MyObject();</a>
<a class="sourceLine" id="cb37-19" title="19"></a>
<a class="sourceLine" id="cb37-20" title="20">  <span class="at">static</span> <span class="dt">void</span> New(<span class="at">const</span> v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; args);</a>
<a class="sourceLine" id="cb37-21" title="21">  <span class="at">static</span> v8::Global&lt;v8::Function&gt; constructor;</a>
<a class="sourceLine" id="cb37-22" title="22">  <span class="dt">double</span> <span class="va">value_</span>;</a>
<a class="sourceLine" id="cb37-23" title="23">};</a>
<a class="sourceLine" id="cb37-24" title="24"></a>
<a class="sourceLine" id="cb37-25" title="25">}  <span class="co">// namespace demo</span></a>
<a class="sourceLine" id="cb37-26" title="26"></a>
<a class="sourceLine" id="cb37-27" title="27"><span class="pp">#endif</span></a></code></pre>
    </div>
    <p>The implementation of <code>myobject.cc</code> is similar to before:</p>
    <div class="sourceCode" id="cb38">
      <pre
        class="sourceCode cpp"
      ><code class="sourceCode cpp"><a class="sourceLine" id="cb38-1" title="1"><span class="co">// myobject.cc</span></a>
<a class="sourceLine" id="cb38-2" title="2"><span class="pp">#include </span><span class="im">&lt;node.h&gt;</span></a>
<a class="sourceLine" id="cb38-3" title="3"><span class="pp">#include </span><span class="im">&quot;myobject.h&quot;</span></a>
<a class="sourceLine" id="cb38-4" title="4"></a>
<a class="sourceLine" id="cb38-5" title="5"><span class="kw">namespace</span> demo {</a>
<a class="sourceLine" id="cb38-6" title="6"></a>
<a class="sourceLine" id="cb38-7" title="7"><span class="kw">using</span> node::AddEnvironmentCleanupHook;</a>
<a class="sourceLine" id="cb38-8" title="8"><span class="kw">using</span> v8::Context;</a>
<a class="sourceLine" id="cb38-9" title="9"><span class="kw">using</span> v8::Function;</a>
<a class="sourceLine" id="cb38-10" title="10"><span class="kw">using</span> v8::FunctionCallbackInfo;</a>
<a class="sourceLine" id="cb38-11" title="11"><span class="kw">using</span> v8::FunctionTemplate;</a>
<a class="sourceLine" id="cb38-12" title="12"><span class="kw">using</span> v8::Global;</a>
<a class="sourceLine" id="cb38-13" title="13"><span class="kw">using</span> v8::Isolate;</a>
<a class="sourceLine" id="cb38-14" title="14"><span class="kw">using</span> v8::Local;</a>
<a class="sourceLine" id="cb38-15" title="15"><span class="kw">using</span> v8::Object;</a>
<a class="sourceLine" id="cb38-16" title="16"><span class="kw">using</span> v8::String;</a>
<a class="sourceLine" id="cb38-17" title="17"><span class="kw">using</span> v8::Value;</a>
<a class="sourceLine" id="cb38-18" title="18"></a>
<a class="sourceLine" id="cb38-19" title="19"><span class="co">// Warning! This is not thread-safe, this addon cannot be used for worker</span></a>
<a class="sourceLine" id="cb38-20" title="20"><span class="co">// threads.</span></a>
<a class="sourceLine" id="cb38-21" title="21">Global&lt;Function&gt; MyObject::constructor;</a>
<a class="sourceLine" id="cb38-22" title="22"></a>
<a class="sourceLine" id="cb38-23" title="23">MyObject::MyObject(<span class="dt">double</span> value) : <span class="va">value_</span>(value) {</a>
<a class="sourceLine" id="cb38-24" title="24">}</a>
<a class="sourceLine" id="cb38-25" title="25"></a>
<a class="sourceLine" id="cb38-26" title="26">MyObject::~MyObject() {</a>
<a class="sourceLine" id="cb38-27" title="27">}</a>
<a class="sourceLine" id="cb38-28" title="28"></a>
<a class="sourceLine" id="cb38-29" title="29"><span class="dt">void</span> MyObject::Init(Isolate* isolate) {</a>
<a class="sourceLine" id="cb38-30" title="30">  <span class="co">// Prepare constructor template</span></a>
<a class="sourceLine" id="cb38-31" title="31">  Local&lt;FunctionTemplate&gt; tpl = FunctionTemplate::New(isolate, New);</a>
<a class="sourceLine" id="cb38-32" title="32">  tpl-&gt;SetClassName(String::NewFromUtf8(isolate, <span class="st">&quot;MyObject&quot;</span>).ToLocalChecked());</a>
<a class="sourceLine" id="cb38-33" title="33">  tpl-&gt;InstanceTemplate()-&gt;SetInternalFieldCount(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb38-34" title="34"></a>
<a class="sourceLine" id="cb38-35" title="35">  Local&lt;Context&gt; context = isolate-&gt;GetCurrentContext();</a>
<a class="sourceLine" id="cb38-36" title="36">  constructor.Reset(isolate, tpl-&gt;GetFunction(context).ToLocalChecked());</a>
<a class="sourceLine" id="cb38-37" title="37"></a>
<a class="sourceLine" id="cb38-38" title="38">  AddEnvironmentCleanupHook(isolate, [](<span class="dt">void</span>*) {</a>
<a class="sourceLine" id="cb38-39" title="39">    constructor.Reset();</a>
<a class="sourceLine" id="cb38-40" title="40">  }, <span class="kw">nullptr</span>);</a>
<a class="sourceLine" id="cb38-41" title="41">}</a>
<a class="sourceLine" id="cb38-42" title="42"></a>
<a class="sourceLine" id="cb38-43" title="43"><span class="dt">void</span> MyObject::New(<span class="at">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args) {</a>
<a class="sourceLine" id="cb38-44" title="44">  Isolate* isolate = args.GetIsolate();</a>
<a class="sourceLine" id="cb38-45" title="45">  Local&lt;Context&gt; context = isolate-&gt;GetCurrentContext();</a>
<a class="sourceLine" id="cb38-46" title="46"></a>
<a class="sourceLine" id="cb38-47" title="47">  <span class="cf">if</span> (args.IsConstructCall()) {</a>
<a class="sourceLine" id="cb38-48" title="48">    <span class="co">// Invoked as constructor: `new MyObject(...)`</span></a>
<a class="sourceLine" id="cb38-49" title="49">    <span class="dt">double</span> value = args[<span class="dv">0</span>]-&gt;IsUndefined() ?</a>
<a class="sourceLine" id="cb38-50" title="50">        <span class="dv">0</span> : args[<span class="dv">0</span>]-&gt;NumberValue(context).FromMaybe(<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb38-51" title="51">    MyObject* obj = <span class="kw">new</span> MyObject(value);</a>
<a class="sourceLine" id="cb38-52" title="52">    obj-&gt;Wrap(args.This());</a>
<a class="sourceLine" id="cb38-53" title="53">    args.GetReturnValue().Set(args.This());</a>
<a class="sourceLine" id="cb38-54" title="54">  } <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb38-55" title="55">    <span class="co">// Invoked as plain function `MyObject(...)`, turn into construct call.</span></a>
<a class="sourceLine" id="cb38-56" title="56">    <span class="at">const</span> <span class="dt">int</span> argc = <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb38-57" title="57">    Local&lt;Value&gt; argv[argc] = { args[<span class="dv">0</span>] };</a>
<a class="sourceLine" id="cb38-58" title="58">    Local&lt;Function&gt; cons = Local&lt;Function&gt;::New(isolate, constructor);</a>
<a class="sourceLine" id="cb38-59" title="59">    Local&lt;Object&gt; instance =</a>
<a class="sourceLine" id="cb38-60" title="60">        cons-&gt;NewInstance(context, argc, argv).ToLocalChecked();</a>
<a class="sourceLine" id="cb38-61" title="61">    args.GetReturnValue().Set(instance);</a>
<a class="sourceLine" id="cb38-62" title="62">  }</a>
<a class="sourceLine" id="cb38-63" title="63">}</a>
<a class="sourceLine" id="cb38-64" title="64"></a>
<a class="sourceLine" id="cb38-65" title="65"><span class="dt">void</span> MyObject::NewInstance(<span class="at">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args) {</a>
<a class="sourceLine" id="cb38-66" title="66">  Isolate* isolate = args.GetIsolate();</a>
<a class="sourceLine" id="cb38-67" title="67"></a>
<a class="sourceLine" id="cb38-68" title="68">  <span class="at">const</span> <span class="dt">unsigned</span> argc = <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb38-69" title="69">  Local&lt;Value&gt; argv[argc] = { args[<span class="dv">0</span>] };</a>
<a class="sourceLine" id="cb38-70" title="70">  Local&lt;Function&gt; cons = Local&lt;Function&gt;::New(isolate, constructor);</a>
<a class="sourceLine" id="cb38-71" title="71">  Local&lt;Context&gt; context = isolate-&gt;GetCurrentContext();</a>
<a class="sourceLine" id="cb38-72" title="72">  Local&lt;Object&gt; instance =</a>
<a class="sourceLine" id="cb38-73" title="73">      cons-&gt;NewInstance(context, argc, argv).ToLocalChecked();</a>
<a class="sourceLine" id="cb38-74" title="74"></a>
<a class="sourceLine" id="cb38-75" title="75">  args.GetReturnValue().Set(instance);</a>
<a class="sourceLine" id="cb38-76" title="76">}</a>
<a class="sourceLine" id="cb38-77" title="77"></a>
<a class="sourceLine" id="cb38-78" title="78">}  <span class="co">// namespace demo</span></a></code></pre>
    </div>
    <p>Test it with:</p>
    <div class="sourceCode" id="cb39">
      <pre
        class="sourceCode js"
      ><code class="sourceCode javascript"><a class="sourceLine" id="cb39-1" title="1"><span class="co">// test.js</span></a>
<a class="sourceLine" id="cb39-2" title="2"><span class="kw">const</span> addon <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;./build/Release/addon&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb39-3" title="3"></a>
<a class="sourceLine" id="cb39-4" title="4"><span class="kw">const</span> obj1 <span class="op">=</span> <span class="va">addon</span>.<span class="at">createObject</span>(<span class="dv">10</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb39-5" title="5"><span class="kw">const</span> obj2 <span class="op">=</span> <span class="va">addon</span>.<span class="at">createObject</span>(<span class="dv">20</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb39-6" title="6"><span class="kw">const</span> result <span class="op">=</span> <span class="va">addon</span>.<span class="at">add</span>(obj1<span class="op">,</span> obj2)<span class="op">;</span></a>
<a class="sourceLine" id="cb39-7" title="7"></a>
<a class="sourceLine" id="cb39-8" title="8"><span class="va">console</span>.<span class="at">log</span>(result)<span class="op">;</span></a>
<a class="sourceLine" id="cb39-9" title="9"><span class="co">// Prints: 30</span></a></code></pre>
    </div>
  </body>
</html>
