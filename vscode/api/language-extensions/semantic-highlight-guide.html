<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <meta charset="utf-8" />
    <meta name="generator" content="pandoc" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=yes"
    />
    <title>semantic-highlight-guide</title>
    <style type="text/css">
      code {
        white-space: pre-wrap;
      }
      span.smallcaps {
        font-variant: small-caps;
      }
      span.underline {
        text-decoration: underline;
      }
      div.column {
        display: inline-block;
        vertical-align: top;
        width: 50%;
      }
    </style>
    <style type="text/css">
      a.sourceLine {
        display: inline-block;
        line-height: 1.25;
      }
      a.sourceLine {
        pointer-events: none;
        color: inherit;
        text-decoration: inherit;
      }
      a.sourceLine:empty {
        height: 1.2em;
      }
      .sourceCode {
        overflow: visible;
      }
      code.sourceCode {
        white-space: pre;
        position: relative;
      }
      div.sourceCode {
        margin: 1em 0;
      }
      pre.sourceCode {
        margin: 0;
      }
      @media screen {
        div.sourceCode {
          overflow: auto;
        }
      }
      @media print {
        code.sourceCode {
          white-space: pre-wrap;
        }
        a.sourceLine {
          text-indent: -1em;
          padding-left: 1em;
        }
      }
      pre.numberSource a.sourceLine {
        position: relative;
        left: -4em;
      }
      pre.numberSource a.sourceLine::before {
        content: attr(title);
        position: relative;
        left: -1em;
        text-align: right;
        vertical-align: baseline;
        border: none;
        pointer-events: all;
        display: inline-block;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        -khtml-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        padding: 0 4px;
        width: 4em;
        color: #aaaaaa;
      }
      pre.numberSource {
        margin-left: 3em;
        border-left: 1px solid #aaaaaa;
        padding-left: 4px;
      }
      div.sourceCode {
      }
      @media screen {
        a.sourceLine::before {
          text-decoration: underline;
        }
      }
      code span.al {
        color: #ff0000;
        font-weight: bold;
      } /* Alert */
      code span.an {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* Annotation */
      code span.at {
        color: #7d9029;
      } /* Attribute */
      code span.bn {
        color: #40a070;
      } /* BaseN */
      code span.bu {
      } /* BuiltIn */
      code span.cf {
        color: #007020;
        font-weight: bold;
      } /* ControlFlow */
      code span.ch {
        color: #4070a0;
      } /* Char */
      code span.cn {
        color: #880000;
      } /* Constant */
      code span.co {
        color: #60a0b0;
        font-style: italic;
      } /* Comment */
      code span.cv {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* CommentVar */
      code span.do {
        color: #ba2121;
        font-style: italic;
      } /* Documentation */
      code span.dt {
        color: #902000;
      } /* DataType */
      code span.dv {
        color: #40a070;
      } /* DecVal */
      code span.er {
        color: #ff0000;
        font-weight: bold;
      } /* Error */
      code span.ex {
      } /* Extension */
      code span.fl {
        color: #40a070;
      } /* Float */
      code span.fu {
        color: #06287e;
      } /* Function */
      code span.im {
      } /* Import */
      code span.in {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* Information */
      code span.kw {
        color: #007020;
        font-weight: bold;
      } /* Keyword */
      code span.op {
        color: #666666;
      } /* Operator */
      code span.ot {
        color: #007020;
      } /* Other */
      code span.pp {
        color: #bc7a00;
      } /* Preprocessor */
      code span.sc {
        color: #4070a0;
      } /* SpecialChar */
      code span.ss {
        color: #bb6688;
      } /* SpecialString */
      code span.st {
        color: #4070a0;
      } /* String */
      code span.va {
        color: #19177c;
      } /* Variable */
      code span.vs {
        color: #4070a0;
      } /* VerbatimString */
      code span.wa {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* Warning */
    </style>
  </head>
  <body>
    <h1 id="semantic-highlight-guide">Semantic Highlight Guide</h1>
    <p>
      Semantic highlighting is an addition to syntax highlighting as described in the
      <a href="/api/language-extensions/syntax-highlight-guide">Syntax Highlight Guide</a>.
      Visual Studio Code uses TextMate grammars as the main tokenization engine. TextMate
      grammars work on a single file as input and break it up based on lexical rules
      expressed in regular expressions.
    </p>
    <p>
      Semantic tokenization allows language servers to provide additional token information
      based on the language server’s knowledge on how to resolve symbols in the context of a
      project. Themes can opt in to use semantic tokens to improve and refine the syntax
      highlighting from grammars. The editor applies the highlighting from semantic tokens
      on top of the highlighting from grammars.
    </p>
    <p>Here’s an example of what semantic highlighting can add:</p>
    <p>Without semantic highlighting:</p>
    <figure>
      <img
        src="images/semantic-highlighting/no-semantic-highlighting.png"
        alt="without semantic highlighting"
      />
      <figcaption>without semantic highlighting</figcaption>
    </figure>
    <p>With semantic highlighting:</p>
    <figure>
      <img
        src="images/semantic-highlighting/with-semantic-highlighting.png"
        alt="with semantic highlighting"
      />
      <figcaption>with semantic highlighting</figcaption>
    </figure>
    <p>Notice the color differences based on language service symbol understanding:</p>
    <ul>
      <li>line 10: <code>languageModes</code> is colored as a parameter</li>
      <li>
        line 11: <code>Range</code> and <code>Position</code> are colored as classes and
        <code>document</code> as a parameter.
      </li>
      <li>line 13: <code>getFoldingRanges</code> is colored as a function.</li>
    </ul>
    <h2 id="semantic-token-provider">Semantic token provider</h2>
    <p>
      To implement semantic highlighting, language extensions can register a
      <code>semantic token provider</code> by document language and/or file name. The editor
      will make requests to the providers when semantic tokens are needed.
    </p>
    <div class="sourceCode" id="cb1">
      <pre
        class="sourceCode ts"
      ><code class="sourceCode typescript"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">const</span> tokenTypes <span class="op">=</span> <span class="op">[</span><span class="st">&#39;class&#39;</span><span class="op">,</span> <span class="st">&#39;interface&#39;</span><span class="op">,</span> <span class="st">&#39;enum&#39;</span><span class="op">,</span> <span class="st">&#39;function&#39;</span><span class="op">,</span> <span class="st">&#39;variable&#39;</span><span class="op">];</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="kw">const</span> tokenModifiers <span class="op">=</span> <span class="op">[</span><span class="st">&#39;declaration&#39;</span><span class="op">,</span> <span class="st">&#39;documentation&#39;</span><span class="op">];</span></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="kw">const</span> legend <span class="op">=</span> <span class="kw">new</span> <span class="va">vscode</span><span class="op">.</span><span class="fu">SemanticTokensLegend</span>(tokenTypes<span class="op">,</span> tokenModifiers)<span class="op">;</span></a>
<a class="sourceLine" id="cb1-4" title="4"></a>
<a class="sourceLine" id="cb1-5" title="5"><span class="kw">const</span> provider<span class="op">:</span> <span class="va">vscode</span><span class="op">.</span><span class="at">DocumentSemanticTokensProvider</span> <span class="op">=</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb1-6" title="6">  <span class="fu">provideDocumentSemanticTokens</span>(document<span class="op">:</span> <span class="va">vscode</span><span class="op">.</span><span class="at">TextDocument</span>)<span class="op">:</span> <span class="va">vscode</span><span class="op">.</span><span class="at">ProviderResult</span><span class="op">&lt;</span><span class="va">vscode</span><span class="op">.</span><span class="at">SemanticTokens</span><span class="op">&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb1-7" title="7">    <span class="co">// analyze the document and return semantic tokens</span></a>
<a class="sourceLine" id="cb1-8" title="8"></a>
<a class="sourceLine" id="cb1-9" title="9">    <span class="kw">const</span> tokensBuilder <span class="op">=</span> <span class="kw">new</span> <span class="va">vscode</span><span class="op">.</span><span class="fu">SemanticTokensBuilder</span>(legend)<span class="op">;</span></a>
<a class="sourceLine" id="cb1-10" title="10">    <span class="co">// on line 1, characters 1-5 are a class declaration</span></a>
<a class="sourceLine" id="cb1-11" title="11">    <span class="va">tokensBuilder</span><span class="op">.</span><span class="fu">push</span>(</a>
<a class="sourceLine" id="cb1-12" title="12">      <span class="kw">new</span> <span class="va">vscode</span><span class="op">.</span><span class="fu">Range</span>(<span class="kw">new</span> <span class="va">vscode</span><span class="op">.</span><span class="fu">Position</span>(<span class="dv">1</span><span class="op">,</span> <span class="dv">1</span>)<span class="op">,</span> <span class="kw">new</span> <span class="va">vscode</span><span class="op">.</span><span class="fu">Position</span>(<span class="dv">1</span><span class="op">,</span> <span class="dv">5</span>))<span class="op">,</span></a>
<a class="sourceLine" id="cb1-13" title="13">      <span class="st">&#39;class&#39;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb1-14" title="14">      <span class="op">[</span><span class="st">&#39;declaration&#39;</span><span class="op">],</span></a>
<a class="sourceLine" id="cb1-15" title="15">    )<span class="op">;</span></a>
<a class="sourceLine" id="cb1-16" title="16">    <span class="cf">return</span> <span class="va">tokensBuilder</span><span class="op">.</span><span class="fu">build</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb1-17" title="17">  <span class="op">}</span></a>
<a class="sourceLine" id="cb1-18" title="18"><span class="op">};</span></a>
<a class="sourceLine" id="cb1-19" title="19"></a>
<a class="sourceLine" id="cb1-20" title="20"><span class="kw">const</span> selector <span class="op">=</span> <span class="op">{</span> language<span class="op">:</span> <span class="st">&#39;java&#39;</span><span class="op">,</span> scheme<span class="op">:</span> <span class="st">&#39;file&#39;</span> <span class="op">};</span> <span class="co">// register for all Java documents from the local file system</span></a>
<a class="sourceLine" id="cb1-21" title="21"></a>
<a class="sourceLine" id="cb1-22" title="22"><span class="va">vscode</span><span class="op">.</span><span class="va">languages</span><span class="op">.</span><span class="fu">registerDocumentSemanticTokensProvider</span>(selector<span class="op">,</span> provider<span class="op">,</span> legend)<span class="op">;</span></a></code></pre>
    </div>
    <p>
      The semantic token provider API comes in two flavors to accommodate a language
      server’s capabilities:
    </p>
    <ul>
      <li>
        <p>
          <code>DocumentSemanticTokensProvider</code> - Always takes a full document as
          input.
        </p>
        <ul>
          <li>
            <code>provideDocumentSemanticTokens</code> - Provides all tokens of a document.
          </li>
          <li>
            <code>provideDocumentSemanticTokensEdits</code>- Provides all tokens of a
            document as a delta to the previous response.
          </li>
        </ul>
      </li>
      <li>
        <p><code>DocumentRangeSemanticTokensProvider</code> - Works only on a range.</p>
        <ul>
          <li>
            <code>provideDocumentRangeSemanticTokens</code> - Provides all tokens of a
            document range.
          </li>
        </ul>
      </li>
    </ul>
    <p>
      Each token returned by the provider comes with a classification that consists of a
      token type, any number of token modifiers, and a token language.
    </p>
    <p>
      As seen in the example above, the provider names the types and modifiers it’s going to
      use in a <code>SemanticTokensLegend</code>. That allows the <code>provide</code> APIs
      to return token types and modifies as an index to the legend.
    </p>
    <h2 id="semantic-token-classification">Semantic token classification</h2>
    <p>
      The output of a semantic token provider consists of tokens. Each token has a range and
      a token classification that describes what kind of syntax element the token
      represents. Optionally, the classification can also name a language, if the token is
      part of an embedded language.
    </p>
    <p>
      To describe the kind of syntax element, semantic token types and modifiers are used.
      This information is similar to the TextMate scopes described in the
      <a href="/api/language-extensions/syntax-highlight-guide">Syntax Highlight Guide</a>,
      but we wanted to come up with a dedicated and cleaner classification system.
    </p>
    <p>
      VS Code comes with a set of standard semantic token types and modifiers for all
      semantic token providers to use. Still, semantic token providers are free to define
      new types and modifiers and create a subtype of the standard types.
    </p>
    <h3 id="standard-token-types-and-modifiers">Standard token types and modifiers</h3>
    <p>
      The standard types and modifiers cover common concepts used by many languages. While
      each language might use a different terminology for some types and modifiers, by
      adhering to the standard classifications, it will be possible for theme authors to
      define theming rules that work across languages.
    </p>
    <p>
      These are the standard semantic token types and semantic token modifiers predefined by
      VS Code:
    </p>
    <p>Standard token types:</p>
    <table>
      <colgroup>
        <col style="width: 47%" />
        <col style="width: 52%" />
      </colgroup>
      <thead>
        <tr class="header">
          <th>ID</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
        <tr class="odd">
          <td><code>namespace</code></td>
          <td>
            For identifiers that declare or reference a namespace, module, or package.
          </td>
        </tr>
        <tr class="even">
          <td><code>class</code></td>
          <td>For identifiers that declare or reference a class type.</td>
        </tr>
        <tr class="odd">
          <td><code>enum</code></td>
          <td>For identifiers that declare or reference an enumeration type.</td>
        </tr>
        <tr class="even">
          <td><code>interface</code></td>
          <td>For identifiers that declare or reference an interface type.</td>
        </tr>
        <tr class="odd">
          <td><code>struct</code></td>
          <td>For identifiers that declare or reference a struct type.</td>
        </tr>
        <tr class="even">
          <td><code>typeParameter</code></td>
          <td>For identifiers that declare or reference a type parameter.</td>
        </tr>
        <tr class="odd">
          <td><code>type</code></td>
          <td>
            For identifiers that declare or reference a type that is not covered above.
          </td>
        </tr>
        <tr class="even">
          <td><code>parameter</code></td>
          <td>
            For identifiers that declare or reference a function or method parameters.
          </td>
        </tr>
        <tr class="odd">
          <td><code>variable</code></td>
          <td>For identifiers that declare or reference a local or global variable.</td>
        </tr>
        <tr class="even">
          <td><code>property</code></td>
          <td>
            For identifiers that declare or reference a member property, member field, or
            member variable.
          </td>
        </tr>
        <tr class="odd">
          <td><code>enumMember</code></td>
          <td>
            For identifiers that declare an enumeration property, constant, or member.
          </td>
        </tr>
        <tr class="even">
          <td><code>event</code></td>
          <td>For identifiers that declare an event property.</td>
        </tr>
        <tr class="odd">
          <td><code>function</code></td>
          <td>For identifiers that declare a function.</td>
        </tr>
        <tr class="even">
          <td><code>method</code></td>
          <td>For identifiers that declare a member function or method.</td>
        </tr>
        <tr class="odd">
          <td><code>macro</code></td>
          <td>For identifiers that declare a macro.</td>
        </tr>
        <tr class="even">
          <td><code>label</code></td>
          <td>For identifiers that declare a label.</td>
        </tr>
        <tr class="odd">
          <td><code>comment</code></td>
          <td>For tokens that represent a comment.</td>
        </tr>
        <tr class="even">
          <td><code>string</code></td>
          <td>For tokens that represent a string literal.</td>
        </tr>
        <tr class="odd">
          <td><code>keyword</code></td>
          <td>For tokens that represent a language keyword.</td>
        </tr>
        <tr class="even">
          <td><code>number</code></td>
          <td>For tokens that represent a number literal.</td>
        </tr>
        <tr class="odd">
          <td><code>regexp</code></td>
          <td>For tokens that represent a regular expression literal.</td>
        </tr>
        <tr class="even">
          <td><code>operator</code></td>
          <td>For tokens that represent an operator.</td>
        </tr>
      </tbody>
    </table>
    <p>Standard token modifiers:</p>
    <table>
      <thead>
        <tr class="header">
          <th>ID</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
        <tr class="odd">
          <td><code>declaration</code></td>
          <td>For declarations of symbols.</td>
        </tr>
        <tr class="even">
          <td><code>definition</code></td>
          <td>For definitions of symbols, for example, in header files.</td>
        </tr>
        <tr class="odd">
          <td><code>readonly</code></td>
          <td>For readonly variables and member fields (constants).</td>
        </tr>
        <tr class="even">
          <td><code>static</code></td>
          <td>For class members (static members).</td>
        </tr>
        <tr class="odd">
          <td><code>deprecated</code></td>
          <td>For symbols that should no longer be used.</td>
        </tr>
        <tr class="even">
          <td><code>abstract</code></td>
          <td>For types and member functions that are abstract.</td>
        </tr>
        <tr class="odd">
          <td><code>async</code></td>
          <td>For functions that are marked async.</td>
        </tr>
        <tr class="even">
          <td><code>modification</code></td>
          <td>For variable references where the variable is assigned to.</td>
        </tr>
        <tr class="odd">
          <td><code>documentation</code></td>
          <td>For occurrences of symbols in documentation.</td>
        </tr>
        <tr class="even">
          <td><code>defaultLibrary</code></td>
          <td>For symbols that are part of the standard library.</td>
        </tr>
      </tbody>
    </table>
    <p>
      Along with the standard types and modifiers, VS Code defines a mapping of types and
      modifiers to similar TextMate scopes. That’s covered in the section
      <a href="#semantic-token-scope-map">Semantic Token Scope Map</a>.
    </p>
    <h3 id="custom-token-types-and-modifiers">Custom token types and modifiers</h3>
    <p>
      If necessary, extensions can declare new types and modifiers or create sub types of
      existing types through the <code>semanticTokenTypes</code> and
      <code>semanticTokenModifiers</code> contribution points in their extension’s
      <code>package.json</code>:
    </p>
    <div class="sourceCode" id="cb2">
      <pre
        class="sourceCode json"
      ><code class="sourceCode json"><a class="sourceLine" id="cb2-1" title="1"><span class="fu">{</span></a>
<a class="sourceLine" id="cb2-2" title="2">  <span class="dt">&quot;contributes&quot;</span><span class="fu">:</span> <span class="fu">{</span></a>
<a class="sourceLine" id="cb2-3" title="3">    <span class="dt">&quot;semanticTokenTypes&quot;</span><span class="fu">:</span> <span class="ot">[</span><span class="fu">{</span></a>
<a class="sourceLine" id="cb2-4" title="4">      <span class="dt">&quot;id&quot;</span><span class="fu">:</span> <span class="st">&quot;templateType&quot;</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb2-5" title="5">      <span class="dt">&quot;superType&quot;</span><span class="fu">:</span> <span class="st">&quot;type&quot;</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb2-6" title="6">      <span class="dt">&quot;description&quot;</span><span class="fu">:</span> <span class="st">&quot;A template type.&quot;</span></a>
<a class="sourceLine" id="cb2-7" title="7">    <span class="fu">}</span><span class="ot">]</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb2-8" title="8">    <span class="dt">&quot;semanticTokenModifiers&quot;</span><span class="fu">:</span> <span class="ot">[</span><span class="fu">{</span></a>
<a class="sourceLine" id="cb2-9" title="9">      <span class="dt">&quot;id&quot;</span><span class="fu">:</span> <span class="st">&quot;native&quot;</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb2-10" title="10">      <span class="dt">&quot;description&quot;</span><span class="fu">:</span> <span class="st">&quot;Annotates a symbol that is implemented natively&quot;</span></a>
<a class="sourceLine" id="cb2-11" title="11">    <span class="fu">}</span><span class="ot">]</span></a>
<a class="sourceLine" id="cb2-12" title="12">  <span class="fu">}</span></a>
<a class="sourceLine" id="cb2-13" title="13"><span class="fu">}</span></a></code></pre>
    </div>
    <p>
      In the example above, an extension declares a new type <code>templateType</code> and a
      new modifier <code>native</code>. By naming <code>type</code> as the super type, the
      new type will inherit the styling rules that have already been defined for
      <code>type</code>.
    </p>
    <p>
      Along with custom token types, extensions can define how these are mapped to TextMate
      scopes. This is described in the
      <a href="#custom-textmate-scope-mappings">Custom Mappings</a> section.
    </p>
    <h2 id="enablement-of-semantic-highlighting">Enablement of semantic highlighting</h2>
    <p>
      Whether semantic tokens are computed and highlighted is decided by the setting
      <code>editor.semanticHighlighting.enabled</code>. It can have values
      <code>true</code>, <code>false</code>, and <code>configuredByTheme</code>.
    </p>
    <ul>
      <li>
        <code>true</code> and <code>false</code> turn semantic highlighting on or off for
        all themes.
      </li>
      <li>
        <code>configuredByTheme</code> is the default and lets each theme control whether
        semantic highlighting is enabled or not. All the themes that ship with VS Code (for
        example, the “Dark+” default) have semantic highlighting enabled by default.
      </li>
    </ul>
    <p>
      Language extensions that depend on semantic tokens can override the default for their
      language in their <code>package.json</code>:
    </p>
    <div class="sourceCode" id="cb3">
      <pre
        class="sourceCode json"
      ><code class="sourceCode json"><a class="sourceLine" id="cb3-1" title="1"><span class="fu">{</span></a>
<a class="sourceLine" id="cb3-2" title="2">  <span class="dt">&quot;configurationDefaults&quot;</span><span class="fu">:</span> <span class="fu">{</span></a>
<a class="sourceLine" id="cb3-3" title="3">    <span class="dt">&quot;[languageId]&quot;</span><span class="fu">:</span> <span class="fu">{</span></a>
<a class="sourceLine" id="cb3-4" title="4">      <span class="dt">&quot;editor.semanticHighlighting.enabled&quot;</span><span class="fu">:</span> <span class="kw">true</span></a>
<a class="sourceLine" id="cb3-5" title="5">    <span class="fu">}</span></a>
<a class="sourceLine" id="cb3-6" title="6">  <span class="fu">}</span></a>
<a class="sourceLine" id="cb3-7" title="7"><span class="fu">}</span></a></code></pre>
    </div>
    <h2 id="theming">Theming</h2>
    <p>
      Theming is about assigning colors and styles to tokens. Theming rules are specified in
      Color Theme files (JSON format). Users can also customize the theming rules in the
      user settings.
    </p>
    <h3 id="semantic-coloring-in-color-themes">Semantic coloring in Color Themes</h3>
    <p>
      Two new properties have been added to the Color Theme file format in order to support
      highlighting based on semantic tokens.
    </p>
    <p>
      The property <code>semanticHighlighting</code> defines whether the theme is ready for
      highlighting using semantic tokens. It is false by default, but we encourage all
      themes to enable it. The property is used when the setting
      <code>editor.semanticHighlighting.enabled</code> is set to
      <code>configuredByTheme</code>.
    </p>
    <p>
      The property <code>semanticTokenColors</code> allows a theme to define new coloring
      rules that match against the semantic token types and modifiers that are emitted by
      the semantic token providers.
    </p>
    <pre class="jsonc"><code>{
  &quot;name&quot;: &quot;Red Theme&quot;,
  &quot;tokenColors&quot;: [
    {
      &quot;scope&quot;: &quot;comment&quot;,
      &quot;settings&quot;: {
        &quot;foreground&quot;: &quot;#dd0000&quot;,
        &quot;fontStyle&quot;: &quot;italic&quot;
      }
    }
  ],
  &quot;semanticHighlighting&quot;: true,
  &quot;semanticTokenColors&quot;: {
    &quot;variable.readonly:java&quot;: &quot;#ff0011&quot;
  }
}</code></pre>
    <p>
      <code>variable.readonly:java</code> is called a selector and has the form
      <code>(*|tokenType)(.tokenModifier)*(:tokenLanguage)?</code>.
    </p>
    <p>
      The value describes the style if the rule matches. It is either a string, representing
      the foreground color, or an object, in the form
      <code
        >{ foreground: string, bold: boolean, italic: boolean, underline: boolean }</code
      >
      or <code>{ foreground: string, fontStyle: string }</code> as used for TextMate theme
      rule in <code>tokenColors</code>.
    </p>
    <p>
      The foreground needs to follow a color format as described in
      <a href="/api/references/theme-color#color-formats">Color formats</a>. Transparency is
      not supported.
    </p>
    <p>Here are other examples of selectors and styles:</p>
    <ul>
      <li><code>"*.declaration": { "bold": true } // all declarations are bold</code></li>
      <li>
        <code
          >"class:java": { "foreground": "#0f0", "italic": true } // classes in java</code
        >
      </li>
    </ul>
    <p>
      If no rule matches or the theme has no <code>semanticTokenColors</code> section (but
      <code>semanticHighlighting</code> enabled), VS Code uses the
      <a href="#semantic-token-scope-map">Semantic Token Scope Map</a> to evaluate a
      TextMate scope for the given semantic token. That scope is matched against the themes
      TextMate theming rules in <code>tokenColors</code>.
    </p>
    <h2 id="semantic-token-scope-map">Semantic token scope map</h2>
    <p>
      In order to make semantic highlighting work for themes that have not defined any
      specific semantic rules and to serve as fallback for custom token types and modifiers,
      VS Code maintains a map from semantic token selectors to TextMate scopes.
    </p>
    <p>
      If a theme has semantic highlighting enabled, but does not contain a rule for the
      given semantic token, these TextMate scopes are used to find a TextMate theming rule
      instead.
    </p>
    <h3 id="predefined-textmate-scope-mappings">Predefined TextMate scope mappings</h3>
    <p>The following table lists the currently predefined mappings.</p>
    <table>
      <thead>
        <tr class="header">
          <th>Semantic Token Selector</th>
          <th>Fallback TextMate Scope</th>
        </tr>
      </thead>
      <tbody>
        <tr class="odd">
          <td><code>namespace</code></td>
          <td><code>entity.name.namespace</code></td>
        </tr>
        <tr class="even">
          <td><code>type</code></td>
          <td><code>entity.name.type</code></td>
        </tr>
        <tr class="odd">
          <td><code>type.defaultLibrary</code></td>
          <td><code>support.type</code></td>
        </tr>
        <tr class="even">
          <td><code>struct</code></td>
          <td><code>storage.type.struct</code></td>
        </tr>
        <tr class="odd">
          <td><code>class</code></td>
          <td><code>entity.name.type.class</code></td>
        </tr>
        <tr class="even">
          <td><code>class.defaultLibrary</code></td>
          <td><code>support.class</code></td>
        </tr>
        <tr class="odd">
          <td><code>interface</code></td>
          <td><code>entity.name.type.interface</code></td>
        </tr>
        <tr class="even">
          <td><code>enum</code></td>
          <td><code>entity.name.type.enum</code></td>
        </tr>
        <tr class="odd">
          <td><code>function</code></td>
          <td><code>entity.name.function</code></td>
        </tr>
        <tr class="even">
          <td><code>function.defaultLibrary</code></td>
          <td><code>support.function</code></td>
        </tr>
        <tr class="odd">
          <td><code>method</code></td>
          <td><code>entity.name.function.member</code></td>
        </tr>
        <tr class="even">
          <td><code>macro</code></td>
          <td><code>entity.name.function.macro</code></td>
        </tr>
        <tr class="odd">
          <td><code>variable</code></td>
          <td><code>variable.other.readwrite</code> , <code>entity.name.variable</code></td>
        </tr>
        <tr class="even">
          <td><code>variable.readonly</code></td>
          <td><code>variable.other.constant</code></td>
        </tr>
        <tr class="odd">
          <td><code>variable.readonly.defaultLibrary</code></td>
          <td><code>support.constant</code></td>
        </tr>
        <tr class="even">
          <td><code>parameter</code></td>
          <td><code>variable.parameter</code></td>
        </tr>
        <tr class="odd">
          <td><code>property</code></td>
          <td><code>variable.other.property</code></td>
        </tr>
        <tr class="even">
          <td><code>property.readonly</code></td>
          <td><code>variable.other.constant.property</code></td>
        </tr>
        <tr class="odd">
          <td><code>enumMember</code></td>
          <td><code>variable.other.enummember</code></td>
        </tr>
        <tr class="even">
          <td><code>event</code></td>
          <td><code>variable.other.event</code></td>
        </tr>
      </tbody>
    </table>
    <h3 id="custom-textmate-scope-mappings">Custom TextMate scope mappings</h3>
    <p>
      This map can be extended by extensions through the
      <code>semanticTokenScopes</code> contribution point in their
      <code>package.json</code>.
    </p>
    <p>There are two use cases for extensions to do that:</p>
    <ul>
      <li>
        <p>
          The extension that defines custom token types and token modifiers provides
          TextMate scopes as fallback when a theme does not define a theming rule for the
          added semantic token type or modifiers:
        </p>
        <div class="sourceCode" id="cb5">
          <pre
            class="sourceCode json"
          ><code class="sourceCode json"><a class="sourceLine" id="cb5-1" title="1"><span class="fu">{</span></a>
<a class="sourceLine" id="cb5-2" title="2">  <span class="dt">&quot;contributes&quot;</span><span class="fu">:</span> <span class="fu">{</span></a>
<a class="sourceLine" id="cb5-3" title="3">    <span class="dt">&quot;semanticTokenScopes&quot;</span><span class="fu">:</span> <span class="ot">[</span></a>
<a class="sourceLine" id="cb5-4" title="4">      <span class="fu">{</span></a>
<a class="sourceLine" id="cb5-5" title="5">        <span class="dt">&quot;scopes&quot;</span><span class="fu">:</span> <span class="fu">{</span></a>
<a class="sourceLine" id="cb5-6" title="6">          <span class="dt">&quot;templateType&quot;</span><span class="fu">:</span> <span class="ot">[</span> <span class="st">&quot;entity.name.type.template&quot;</span> <span class="ot">]</span></a>
<a class="sourceLine" id="cb5-7" title="7">        <span class="fu">}</span></a>
<a class="sourceLine" id="cb5-8" title="8">      <span class="fu">}</span></a>
<a class="sourceLine" id="cb5-9" title="9">    <span class="ot">]</span></a>
<a class="sourceLine" id="cb5-10" title="10">  <span class="fu">}</span></a>
<a class="sourceLine" id="cb5-11" title="11"><span class="fu">}</span></a></code></pre>
        </div>
      </li>
      <li>
        <p>
          The provider of a TextMate grammar can describe the language-specific scopes. That
          helps with themes that contain language-specific theming rules.
        </p>
        <div class="sourceCode" id="cb6">
          <pre
            class="sourceCode json"
          ><code class="sourceCode json"><a class="sourceLine" id="cb6-1" title="1"><span class="fu">{</span></a>
<a class="sourceLine" id="cb6-2" title="2">  <span class="dt">&quot;contributes&quot;</span><span class="fu">:</span> <span class="fu">{</span></a>
<a class="sourceLine" id="cb6-3" title="3">    <span class="dt">&quot;semanticTokenScopes&quot;</span><span class="fu">:</span> <span class="ot">[</span></a>
<a class="sourceLine" id="cb6-4" title="4">      <span class="fu">{</span></a>
<a class="sourceLine" id="cb6-5" title="5">        <span class="dt">&quot;language&quot;</span><span class="fu">:</span> <span class="st">&quot;typescript&quot;</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb6-6" title="6">        <span class="dt">&quot;scopes&quot;</span><span class="fu">:</span> <span class="fu">{</span></a>
<a class="sourceLine" id="cb6-7" title="7">          <span class="dt">&quot;property.readonly&quot;</span><span class="fu">:</span> <span class="ot">[</span><span class="st">&quot;variable.other.constant.property.ts&quot;</span><span class="ot">]</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb6-8" title="8">        <span class="fu">}</span></a>
<a class="sourceLine" id="cb6-9" title="9">      <span class="fu">}</span></a>
<a class="sourceLine" id="cb6-10" title="10">    <span class="ot">]</span></a>
<a class="sourceLine" id="cb6-11" title="11">  <span class="fu">}</span></a>
<a class="sourceLine" id="cb6-12" title="12"><span class="fu">}</span></a></code></pre>
        </div>
      </li>
    </ul>
    <h2 id="try-it-out">Try it out</h2>
    <p>
      We have a
      <a
        href="https://github.com/microsoft/vscode-extension-samples/tree/main/semantic-tokens-sample"
        >Semantic Tokens sample</a
      >
      that illustrates how to create a semantic token provider.
    </p>
    <p>
      The
      <a href="/api/language-extensions/syntax-highlight-guide#scope-inspector"
        >scope inspector</a
      >
      tool allows you to explore what semantic tokens are present in a source file and what
      theme rules they match to. To see semantic token, use a built-in theme (for example,
      Dark+) on a TypeScript file.
    </p>
  </body>
</html>
