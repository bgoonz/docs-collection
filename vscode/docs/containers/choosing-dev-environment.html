<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <meta charset="utf-8" />
    <meta name="generator" content="pandoc" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=yes"
    />
    <title>choosing-dev-environment</title>
    <style type="text/css">
      code {
        white-space: pre-wrap;
      }
      span.smallcaps {
        font-variant: small-caps;
      }
      span.underline {
        text-decoration: underline;
      }
      div.column {
        display: inline-block;
        vertical-align: top;
        width: 50%;
      }
    </style>
    <style type="text/css">
      a.sourceLine {
        display: inline-block;
        line-height: 1.25;
      }
      a.sourceLine {
        pointer-events: none;
        color: inherit;
        text-decoration: inherit;
      }
      a.sourceLine:empty {
        height: 1.2em;
      }
      .sourceCode {
        overflow: visible;
      }
      code.sourceCode {
        white-space: pre;
        position: relative;
      }
      div.sourceCode {
        margin: 1em 0;
      }
      pre.sourceCode {
        margin: 0;
      }
      @media screen {
        div.sourceCode {
          overflow: auto;
        }
      }
      @media print {
        code.sourceCode {
          white-space: pre-wrap;
        }
        a.sourceLine {
          text-indent: -1em;
          padding-left: 1em;
        }
      }
      pre.numberSource a.sourceLine {
        position: relative;
        left: -4em;
      }
      pre.numberSource a.sourceLine::before {
        content: attr(title);
        position: relative;
        left: -1em;
        text-align: right;
        vertical-align: baseline;
        border: none;
        pointer-events: all;
        display: inline-block;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        -khtml-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        padding: 0 4px;
        width: 4em;
        color: #aaaaaa;
      }
      pre.numberSource {
        margin-left: 3em;
        border-left: 1px solid #aaaaaa;
        padding-left: 4px;
      }
      div.sourceCode {
      }
      @media screen {
        a.sourceLine::before {
          text-decoration: underline;
        }
      }
      code span.al {
        color: #ff0000;
        font-weight: bold;
      } /* Alert */
      code span.an {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* Annotation */
      code span.at {
        color: #7d9029;
      } /* Attribute */
      code span.bn {
        color: #40a070;
      } /* BaseN */
      code span.bu {
      } /* BuiltIn */
      code span.cf {
        color: #007020;
        font-weight: bold;
      } /* ControlFlow */
      code span.ch {
        color: #4070a0;
      } /* Char */
      code span.cn {
        color: #880000;
      } /* Constant */
      code span.co {
        color: #60a0b0;
        font-style: italic;
      } /* Comment */
      code span.cv {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* CommentVar */
      code span.do {
        color: #ba2121;
        font-style: italic;
      } /* Documentation */
      code span.dt {
        color: #902000;
      } /* DataType */
      code span.dv {
        color: #40a070;
      } /* DecVal */
      code span.er {
        color: #ff0000;
        font-weight: bold;
      } /* Error */
      code span.ex {
      } /* Extension */
      code span.fl {
        color: #40a070;
      } /* Float */
      code span.fu {
        color: #06287e;
      } /* Function */
      code span.im {
      } /* Import */
      code span.in {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* Information */
      code span.kw {
        color: #007020;
        font-weight: bold;
      } /* Keyword */
      code span.op {
        color: #666666;
      } /* Operator */
      code span.ot {
        color: #007020;
      } /* Other */
      code span.pp {
        color: #bc7a00;
      } /* Preprocessor */
      code span.sc {
        color: #4070a0;
      } /* SpecialChar */
      code span.ss {
        color: #bb6688;
      } /* SpecialString */
      code span.st {
        color: #4070a0;
      } /* String */
      code span.va {
        color: #19177c;
      } /* Variable */
      code span.vs {
        color: #4070a0;
      } /* VerbatimString */
      code span.wa {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* Warning */
    </style>
  </head>
  <body>
    <h1 id="your-development-environment">Your development environment</h1>
    <p>
      You can choose whether to develop a container-based service in the
      <strong>local environment</strong>, or in a
      <strong>remote environment</strong>. The local environment is the
      operating system of your developer workstation; using the local
      environment means you build and run your service container(s) using Docker
      installed on your workstation. Docker is supported on Windows, macOS, and
      various Linux distributions; for system and hardware requirements, refer
      to
      <a href="https://docs.docker.com/get-docker/">Docker installation page</a
      >.
    </p>
    <p>
      <a href="/docs/remote/remote-overview.md"
        >A remote development environment</a
      >
      is different from your developer workstation. It can be a remote machine
      accessible via SSH, a virtual machine running on your developer
      workstation, or a development container. A remote environment can have
      advantages over the local environment, the main one being the ability to
      use the same operating system during development, and when your service is
      running in production. To use a remote environment, you need to ensure
      that <code>docker</code> command (Docker CLI)
      <a href="#enabling-docker-cli-inside-a-remote-development-environment"
        >is available and functional within that environment</a
      >.
    </p>
    <p>
      The second important choice is whether to debug your service running as an
      ordinary process, or debug your service running in a container.
    </p>
    <h2 id="guidelines-for-choosing-a-development-environment">
      Guidelines for choosing a development environment
    </h2>
    <ol type="1">
      <li>
        <p>Use the local environment when you are not concerned about:</p>
        <ul>
          <li>
            Using the same OS for development and inside the service container.
          </li>
          <li>
            Installing necessary tools and dependencies on top of your local
            environment.
          </li>
        </ul>
      </li>
      <li>
        <p>
          Consider using a
          <a href="/docs/remote/containers.md">development container</a> first,
          if you need a remote environment.
        </p>
        <ul>
          <li>
            On Windows, using
            <a href="#windows-subsystem-for-linux"
              >Windows Subsystem for Linux (WSL)</a
            >
            is good option.
          </li>
        </ul>
      </li>
      <li>
        <p>
          Debugging your service running in a container is possible, but brings
          additional complexity. Use normal debugging by default, and debugging
          in the container when you need it.
        </p>
      </li>
    </ol>
    <blockquote>
      <p>
        The Docker extension natively supports container debugging for .NET-,
        Node.js-, and Python-based services.
      </p>
    </blockquote>
    <h2 id="enabling-docker-cli-inside-a-remote-development-environment">
      Enabling Docker CLI inside a remote development environment
    </h2>
    <p>
      The way to enable Docker CLI inside a remote development environment
      varies depending on the type of remote environment you choose.
    </p>
    <h3 id="development-container">Development container</h3>
    <p>
      For a development container, you should redirect the Docker CLI inside the
      container to the Docker daemon running on the local machine.
    </p>
    <p>
      First, make sure Docker CLI is installed into your development container.
      The exact steps
      <a href="https://docs.docker.com/install/"
        >depend on the Linux distribution the container is using</a
      >.
    </p>
    <p>
      Here is an example for Ubuntu-based distros (from a
      <code>.devcontainer/Dockerfile</code>):
    </p>
    <pre class="cli"><code>    ...
    &amp;&amp; apt-get -y install software-properties-common \
    &amp;&amp; curl -fsSL https://download.docker.com/linux/ubuntu/gpg | apt-key add - 2&gt;/dev/null \
    &amp;&amp; add-apt-repository &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu bionic stable&quot; \
    &amp;&amp; apt-get update -y \
    &amp;&amp; apt-get install -y docker-ce-cli \
    &amp;&amp; apt-get install -y python python-pip \
    &amp;&amp; pip install docker-compose \
    ...</code></pre>
    <p>
      Next, ensure that Docker socket is mapped into the development container
      (in <code>.devcontainer/devcontainer.json</code>):
    </p>
    <div class="sourceCode" id="cb2">
      <pre
        class="sourceCode json"
      ><code class="sourceCode json"><a class="sourceLine" id="cb2-1" title="1">    <span class="er">...</span></a>
<a class="sourceLine" id="cb2-2" title="2">    <span class="er">&quot;runArgs&quot;:</span> <span class="ot">[</span> <span class="st">&quot;-v&quot;</span><span class="ot">,</span> <span class="st">&quot;/var/run/docker.sock:/var/run/docker.sock&quot;</span><span class="ot">]</span></a>
<a class="sourceLine" id="cb2-3" title="3">    <span class="er">...</span></a></code></pre>
    </div>
    <h3 id="windows-subsystem-for-linux">Windows Subsystem for Linux</h3>
    <p>
      Windows Subsystem for Linux represents a great choice for container-based
      service development on Windows.
      <a href="https://docs.microsoft.com/windows/wsl/wsl2-index"
        >Windows Subsystem for Linux version 2 (WSL 2)</a
      >
      is strongly recommended. Docker Desktop for Windows has been updated to
      work with WSL 2 and has a graphical setting to enable Docker CLI inside
      WSL 2 distribution(s):
    </p>
    <figure>
      <img
        src="images/devenv/devenv-enable-docker-wsl2.png"
        alt="Enable Docker inside WSL 2 distribution"
      />
      <figcaption>Enable Docker inside WSL 2 distribution</figcaption>
    </figure>
    <blockquote>
      <p>
        To use WSL 2 for Docker development you will need Windows 10 version
        2004 or newer, and Docker Desktop for Windows version 2.2.0.5 or newer.
      </p>
      <p>
        The old version of WSL (WSL 1) does not provide an easy way to connect
        to the Docker daemon on the host.
      </p>
    </blockquote>
    <h3 id="remote-machine">Remote machine</h3>
    <p>
      The recommended way to enable container development with a remote machine
      is to do
      <a href="https://docs.docker.com/install/">a full Docker installation</a>
      on the machine, including Docker daemon.
    </p>
    <blockquote>
      <p>
        <strong>Note</strong>: Docker Desktop product is supported only on
        physical Windows and macOS machines, not virtual machines. If you want
        to use a virtual machine as a remote development environment, we
        recommend to use a Linux VM with
        <a href="https://docs.docker.com/engine/">Docker Engine</a>.
      </p>
    </blockquote>
    <p>
      After Docker is installed and working on the remote machine, you can use
      VS Code’s
      <a
        href="https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-ssh"
        >Remote - SSH</a
      >
      extension from the
      <a
        href="https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.vscode-remote-extensionpack"
        >Remote Development</a
      >
      extension pack to connect to your remote machine and work there.
    </p>
    <ol type="1">
      <li>
        <p>
          Open VS Code Command Palette
          (<code>kb(workbench.action.showCommands)</code>) and run command
          <strong>Remote-SSH: Add new SSH host…</strong>. Follow the prompts to
          set up a connection to the target host.
        </p>
      </li>
      <li>
        <p>
          Run command <strong>Remote-SSH: Connect to host…</strong> and connect
          to the host.
        </p>
      </li>
      <li>
        <p>
          A new VS Code window opens, running in the context of the target
          machine. If you’re using password authentication, the password will be
          prompted here. We strongly recommend that you set up
          <a href="https://www.ssh.com/ssh/public-key-authentication"
            >SSH key authentication</a
          >, for ease of use.
        </p>
      </li>
      <li>
        <p>
          In the Extensions view, install the Docker extension (on the remote
          host) (a reload may be required after this step):
        </p>
        <figure>
          <img
            src="images/devenv/install-in-ssh.png"
            alt="Screenshot - Installing the Docker extension"
          />
          <figcaption>Screenshot - Installing the Docker extension</figcaption>
        </figure>
      </li>
    </ol>
    <blockquote>
      <p>
        <strong>NOTE</strong>: If you are using the Docker extension to build
        Docker images and have source code, the approach above probably means
        you have your source enlistment on the remote host, rather than on your
        developer workstation. If you are just using the Docker extension for
        the Docker Explorer features, then you can disregard this.
      </p>
    </blockquote>
    <h3 id="local-linux-vm">Local Linux VM</h3>
    <p>
      To use a Linux virtual machine running on your developer workstation, you
      should <a href="https://docs.docker.com/install/">install Docker</a> on
      the VM in the same way as you would install it on a remote machine, and
      use the
      <a
        href="https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-ssh"
        >VS Code Remote-SSH</a
      >
      extension to connect to the VM.
    </p>
    <p>
      Alternatively, you can install just the Docker CLI inside your development
      environment and point the CLI to the Docker host (engine) running on the
      developer workstation using the
      <a href="https://docs.docker.com/engine/context/working-with-contexts/"
        >Docker context mechanism</a
      >. The main concern with this approach is to ensure network connectivity
      from the VM to the Docker engine on the host, and to do so in a secure
      way. One option is to use
      <a href="/docs/containers/ssh.md">SSH tunneling</a> to the developer
      workstation. Another option is to
      <a href="https://docs.docker.com/engine/security/https/"
        >have the Docker engine listen on an HTTPS port</a
      >. You need to be proficient with SSH and public-key infrastructure (PKI)
      to use the host Docker engine from the Docker CLI running inside the VM.
      For most users, we recommend full Docker installation inside the virtual
      machine.
    </p>
    <h2 id="debugging-in-a-container">Debugging in a container</h2>
    <p>
      The Docker extension supports debugging .NET Core-based and Node.js-based
      services running inside a container. Other programming languages are not
      supported at this time.
    </p>
    <p>
      Debugging in a container may be harder to set up than regular debugging
      because a container is a stronger isolation mechanism than a process. In
      particular:
    </p>
    <ul>
      <li>
        The debug engine running inside VS Code process needs to communicate
        with the service process being debugged. In the case of a service
        running inside a container, this implies network communication via a
        common network (typically Docker host network). The container needs to
        have appropriate ports exposed via the Docker host network for the debug
        engine to connect to the service process (Node.js), or debugger proxy
        running inside the container (.NET Core).
      </li>
      <li>
        Source file information generated during build time is valid in the
        context of the build environment (where VS Code is running). The
        container filesystem is different from the build environment filesystem,
        and paths to source files need to be re-mapped in order for the debugger
        to display correct source file when a breakpoint is hit.
      </li>
    </ul>
    <p>
      Because of the concerns above, it is generally recommended to use regular
      debugging, and employ debugging in a container when necessary.
    </p>
    <p>
      For more information about how to set up debugging inside a container see
      <a href="/docs/containers/quickstart-aspnet-core.md"
        >ASP.NET Core quickstart</a
      >, <a href="/docs/containers/quickstart-node.md">Node.js quickstart</a>,
      and
      <a href="/docs/containers/reference.md"
        >Docker extension task properties</a
      >
      (<code>docker-build</code> and <code>docker-run</code> tasks).
    </p>
    <h2 id="next-steps">Next steps</h2>
    <p>Read on to learn more about</p>
    <ul>
      <li>
        <a href="/docs/containers/quickstart-node.md"
          >Build and run a Node.js app in a container</a
        >
      </li>
      <li>
        <a href="/docs/containers/quickstart-aspnet-core.md"
          >Build and run a .NET Core app in a container</a
        >
      </li>
    </ul>
  </body>
</html>
