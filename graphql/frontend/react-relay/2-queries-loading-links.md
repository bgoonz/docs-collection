### Preparing the React components

The first piece of functionality that youâ€™ll implement in the app is loading and displaying a list of `Link` elements. Youâ€™ll walk up our way in the React component hierarchy and start with the component thatâ€™ll render a single link.

Create a new file called `Link.js` in the `components` directory and add the following code:

    import React, { Component } from 'react'

    class Link extends Component {

      render() {
        return (
          <div>
            <div>{this.props.link.description} ({this.props.link.url})</div>
          </div>
        )
      }

      _voteForLink = async () => {
        // ... you'll implement this in chapter 6
      }

    }

    export default Link

This is a simple React component that expects a `link` in its `props` and renders the linkâ€™s `description` and `url`. Easy as pie! ğŸ°

Next, youâ€™ll implement the component that renders a list of links.

Again, in the `components` directory, go ahead and create a new file called `LinkList.js` and add the following code:

    import React, { Component } from 'react'
    import Link from './Link'

    class LinkList extends Component {

      render() {

        const linksToRender = [{
          id: '1',
          description: 'The coolest GraphQL backend ğŸ˜',
          url: 'https://www.graph.cool'
        }, {
          id: '2',
          description: 'Highly performant GraphQL client from Facebook',
          url: 'https://facebook.github.io/relay/'
        }]

        return (
          <div>
            {linksToRender.map(link => (
              <Link key={link.id} link={link}/>
            ))}
          </div>
        )
      }

    }

    export default LinkList

Here, youâ€™re using mock data for now to make sure the component setup works. Youâ€™ll soon replace this with some actual data thatâ€™s loaded from the server - patience, young Padawan!

To complete the setup, open `App.js` and replace the current contents with the following:

    import React, { Component } from 'react'
    import LinkList from './LinkList'

    class App extends Component {
      render() {
        return (
          <LinkList />
        )
      }
    }

    export default App

> Note: The project that was generated by `create-react-app` uses semicolons and double quotes for strings. All the code that youâ€™re going to write in this tutorial will use **no semicolons** and **single quotes**.

Run the app by calling `yarn start` to check if everything works so far! The app should now display the two links from the `linksToRender` array:

![Run the app by calling `yarn start`](http://imgur.com/J79QBD7.png)

### Loading Data from the Server

In this section, youâ€™ll learn how you can actually load data from the server instead of rendering the links simply from a local array.

But before you go and make the required changes, a bit of theory!

#### Colocation and GraphQL Fragments

One of the most powerful concepts of Relay is called _colocation_. This means that a React component declares its data dependencies right next to (i.e.Â in the same file) where itâ€™s defined. This happens in the form of [GraphQL fragments](http://graphql.org/learn/queries/#fragments).

This effectively means that youâ€™ll never write any actual GraphQL queries yourself. This is unlike the approach thatâ€™s taken in Apollo, where youâ€™re also able to colocate data dependencies and React components - but are most commonly doing so by writing actual _queries_ instead of _fragments_.

But if youâ€™re never writing any queries in Relay, how can the GraphQL server respond with sensible data?

Thatâ€™s the cool part about Relay! Under the hood, it will figure out the most efficient way for your React components to fetch the data thatâ€™s required for them to render, based on the data dependencies they declared in their fragments.

You donâ€™t have to worry about fetching the data one bit - all networking and caching logic is abstracted away and you can focus on writing your React components and what data they need! Declarative data fetching ftw ğŸ˜

#### Fragment Containers

The way to declare the data dependencies alongside your React components is by using the [`FragmentContainer`](https://facebook.github.io/relay/docs/fragment-container.html) API.

The function `createFragmentContainer` is a higher-order component that takes in two arguments:

1.  A React component for which you want to declare some data dependencies
2.  Data dependencies written as a GraphQL fragment and wrapper using the `graphql` function

Go ahead and write the fragment containers for the two components that you added before.

Open `Link.js` and add the following import to its top:

    import {
      createFragmentContainer,
      graphql
    } from 'react-relay'

All thatâ€™s done there is importing the required Relay modules that you need to create the fragment container.

Now also adjust the export at the bottom of the file by replacing the current `export default Link` statement with the following:

    export default createFragmentContainer(Link, graphql`
      fragment Link_link on Link {
        id
        description
        url
      }
    `)

Hereâ€™s where it gets interesting! Letâ€™s examine this part step-by-step:

Youâ€™re using the `createFragmentContainer` higher-order component and pass in two arguments - exactly as we said before. The first argument is simply the React component, here thatâ€™s the `Link`. The second argument are its data requirements in the form of a GraphQL fragment tagged with the `graphql` function. The `Link` component needs access to the `description` and `url` of a link item. The `id` is required so that Relay can uniquely identify the link items when storing and retrieving them in the cache.

One important note here is that there is a [_naming convention_](https://facebook.github.io/relay/docs/fragment-container.html#data-dependencies-with-graphql) for the fragments youâ€™re creating! Each fragment should be named according to the _file_ and the _prop_ that will get injected into the component: `<FileName>_<propName>`

In your case, the file is called `Link.js` and the prop in the component should be called `link`. So you end up with `Link_link` for the name of the fragment.

Great work so far! Go and add the fragment container for `LinkList` as well.

Open `LinkList.js` and add the same import statement to the top as before:

    import {
      createFragmentContainer,
      graphql
    } from 'react-relay'

Then replace the `export default LinkList` with the following:

    export default createFragmentContainer(LinkList, graphql`
      fragment LinkList_viewer on Viewer {
        allLinks(last: 100, orderBy: createdAt_DESC) @connection(key: "LinkList_allLinks", filters: []) {
          edges {
            node {
              ...Link_link
            }
          }
        }
      }
    `)

Similar to the `Link` component, youâ€™re passing the `LinkList` component along with its data requirements into `createFragmentContainer`. The `LinkList` needs access to a list of links - here youâ€™re simply asking for the last 100 links to display. In the last chapter of this tutorial, youâ€™ll implement a proper [pagination](https://facebook.github.io/relay/docs/pagination-container.html) approach.

> Note: In Relay, _lists_ are represented with the concept of [_connections_](https://facebook.github.io/relay/docs/graphql-connections.html). This facilitates the implementation of a [cursor-based pagination](https://facebook.github.io/relay/graphql/connections.htm) approach on the client. Relay also requires you to always specify a _limit_ of items that you want to fetch from the server, so you have to pass the `first` or `last` argument when fetching items from a connection.

Notice that youâ€™re again following the same naming convention and name the fragment `LinkList_viewer`. `LinkList.js` is the name of the file and `viewer` is the prop that you expect in the component.

Youâ€™re also reusing the `Link_link` fragment that you wrote in `Link.js`. Thatâ€™s because the `LinkList` is higher in the React component (and Relay container) tree, so it needs to include all the fragments of its children!

The [`@connection`](https://www.graph.cool/docs/tutorials/relay-modern-connection-directive-ujaesaen0s/) directive is required for updating the cache later on - you need it so you can refer to that particular connection (identified by the key `LinkList_allLinks`) in the cache.

Finally, you also need to delete the mock data and use the data thatâ€™ll be injected by Relay to render the `Link` elements.

Open `LinkList.js` and update `render` to look as follows:

    render() {
      return (
        <div>
          {this.props.viewer.allLinks.edges.map(({node}) =>
              <Link key={node.__id} link={node} />
          )}
        </div>
      )
    }

#### Rendering Queries

Now it starts to get interesting! What happens with these fragments? When are they used and whatâ€™s the query Relay actually sends to the server?

Meet the [`QueryRenderer`](https://facebook.github.io/relay/docs/query-renderer.html):

> `QueryRenderer` is the root of a Relay tree. It takes a query, fetches the data and calls the `render` callback with the data.

So, here is where it all adds up. React components are wrapped with GraphQL fragments to become Relay containers. When doing so, they retain the same hierarchical structure as the pure React components and form a _tree_. At the root of that tree thereâ€™s the `QueryRenderer`, which also is a higher-order component that will take care of composing the actual query.

So, go and add the `QueryRenderer` in a new component!

Create a new file called `LinkListPage.js` and add the following import to the top:

    import React, { Component } from 'react'
    import {
      QueryRenderer,
      graphql
    } from 'react-relay'
    import environment from '../Environment'
    import LinkList from './LinkList'

A `QueryRenderer` needs at least three things when being instantiated:

1.  A Relay `environment` which is why youâ€™re importing it here.
2.  A root `query` which will be the basis for the query that gets sent to the server.
3.  A `render` function that specifies what should be rendered in _loading_, _error_ and _success_ cases.

Youâ€™ll write the root `query` first.

Still in `LinkListPage.js`, add the following code right after the import statements:

    const LinkListPageQuery = graphql`
      query LinkListPageQuery {
        viewer {
          ...LinkList_viewer
        }
      }
    `

Notice how youâ€™re now actually reusing the fragment `LinkList_viewer` from the `LinkList` component.

Still in `LinkListPage.js`, copy the following code at the bottom of the file:

    class LinkListPage extends Component {

      render() {
        return (
          <QueryRenderer
            environment={environment}
            query={LinkListPageQuery}
            render={({error, props}) => {
              if (error) {
                return <div>{error.message}</div>
              } else if (props) {
                return <LinkList viewer={props.viewer} />
              }
              return <div>Loading</div>
            }}
          />
        )
      }

    }

    export default LinkListPage

As discussed before, youâ€™re using the `QueryRenderer` and provide the three required props. The `render` function receives the result thatâ€™s returned by the server and passes it down to its children.

Lastly, you need to make sure that the `LinkListPage` is rendered on the root of your component hierarchy.

Open `App.js` and replace its contents so that `render` returns the `LinkListPage`:

    import React, { Component } from 'react'
    import LinkListPage from './LinkListPage'

    class App extends Component {
      render() {
        return (
          <LinkListPage />
        )
      }
    }

    export default App

#### Running the App

If youâ€™re just running the app now, youâ€™ll be disappointed that it throws some errors:

    Failed to compile.
    ./src/components/LinkListPage.js
    Module not found: Can't resolve './__generated__/LinkListPageQuery.graphql' in '.../hackernews-react-relay/src/components'

Thatâ€™s because weâ€™ve skipped the _compilation_ of the GraphQL code that makes for much of Relayâ€™s actual power! You already installed the `relay-compiler` as a dev dependency, this allows you to add it as a script to `package.json` as explained [here](https://facebook.github.io/relay/docs/en/installation-and-setup.html#set-up-relay-compiler). However, to keep things a bit more simple in this tutorial youâ€™ll just install it globally for now (feel free to choose the other setup described in the Relay docs).

In your terminal, install the `relay-compiler` globally with the following command:

    npm install -g relay-compiler

The compiler can be invoked using the `relay-compiler` command in the terminal where you have to provide two arguments:

1.  `--src`: The path to all your files that contain `graphql` code
2.  `--schema`: The path to your full GraphQL schema that you already downloaded in the previous chapter

In a terminal, navigate to the projectâ€™s root directory and invoke the Relay Compiler with the following command:

    relay-compiler --src ./src --schema ./schema.graphql

Now - when running the `relay-compiler` youâ€™ll actually see another error message. Thatâ€™s disappointing, but donâ€™t worry - itâ€™s not your fault this time. This happens because of a [bug in the Relay Compiler](https://github.com/facebook/relay/issues/1835) that breaks the compilation when there are non-nullable types on the connection types in the schema. You can work around the issue by manually adjusting it, which is not something you should be doing under normal circumstances but for the purpose of this tutorial it will be fine.

In fact, we already did the fixes for you. So you now have to copy the contents from the modified schema stored at <https://graphqlbin.com/hn-relay-full.graphql> into `hackernews-react-relay/schema.graphql`.

Now you can run the Relay Compiler again!

Once again, in a terminal, navigate to the projectâ€™s root directory and invoke the Relay Compiler:

    relay-compiler --src ./src --schema ./schema.graphql

The `relay-compiler` will now scan all files in `src` and look for `graphql` code. It then takes this code and generates corresponding Javascript representations for it (which again will be the input for the Babel compilation step). These Javascript representations are stored in `./src/__generated__`.

Hereâ€™s what the terminal output will look like:

    $ relay-compiler --src ./src --schema ./schema.graphql
    HINT: pass --watch to keep watching for changes.
    Parsed default in 0.06s

    Writing default
    Writer time: 0.27s [0.08s compiling, 0.19s generating, 0.00s extra]
    Created:
     - Link_link.flow.js
     - Link_link.graphql.js
     - LinkList_viewer.flow.js
     - LinkList_viewer.graphql.js
     - LinkListPageQuery.graphql.js
    Unchanged: 0 files
    Written default in 0.33s

Youâ€™ll also notice that the `__generated__` directory was now created and contains all the files that were generated by the compiler:

    .
    â””â”€â”€ src
     Â Â  â””â”€â”€ components
     Â Â   Â Â  â””â”€â”€ __generated__
     Â Â   Â Â      â”œâ”€â”€ LinkListPageQuery.graphql.js
     Â Â   Â Â      â”œâ”€â”€ LinkList_viewer.flow.js
     Â Â   Â Â      â”œâ”€â”€ LinkList_viewer.graphql.js
     Â Â   Â Â      â”œâ”€â”€ Link_link.flow.js
     Â Â   Â Â      â””â”€â”€ Link_link.graphql.js

Thatâ€™s it, you can now run the app and youâ€™ll see the same links that you initially added with the two mutations in the Playground rendered in the app!

By the way, if youâ€™re curious to see what the actual query looked like that the `QueryRenderer` composed for you and that was sent over to the server, you can inspect the _Networking_-tab of your browserâ€™s dev tools:

![The query in QueryRenderer](http://imgur.com/222Prig.png)

Awesome! You can now move on to learn about mutations in Relay.
