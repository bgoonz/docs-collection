<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Introduction</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">Introduction</h1>
</header>
<h3 id="motivation">Motivation</h3>
<p><a href="https://www.ruby-lang.org/en/">Ruby</a> is general purpose programming language optimized for programmer happiness. One of its most popular frameworks for building web applications is called <a href="http://rubyonrails.org/">Ruby on Rails</a>.</p>
<p>The Ruby ecosystem was one of the first to adopt <a href="http://graphql.org/">GraphQL</a>. A couple of popular Ruby on Rails applications like <a href="https://github.com/">Github</a> and <a href="https://www.shopify.com/">Shopify</a> are using it in production already.</p>
<p>In this chapter you’ll learn how to build your very own <a href="http://graphql.org/">GraphQL</a> server using the following technologies:</p>
<ul>
<li><a href="http://rubyonrails.org/">Ruby on Rails</a>: the most popular library for building applications in <a href="https://www.ruby-lang.org/en/">Ruby</a></li>
<li><a href="http://graphql-ruby.org/">GraphQL Gem</a>: the most popular library for building <a href="http://graphql.org/">GraphQL</a> applications</li>
<li><a href="https://github.com/graphql/graphiql">GraphiQL</a>: An in-browser IDE for exploring <a href="http://graphql.org/">GraphQL</a>, which comes bundled with <a href="http://graphql-ruby.org/">GraphQL Gem</a></li>
</ul>
<h3 id="what-is-a-graphql-server">What is a GraphQL Server?</h3>
<p>A GraphQL server should be able to:</p>
<ul>
<li>Receive requests following the GraphQL format, for example:</li>
</ul>
<pre class="graphql(nocopy)"><code>{ &quot;query&quot;: &quot;query { allLinks { url } }&quot; }</code></pre>
<ul>
<li>Connect to any necessary databases or services responsible for storing/fetching the actual data.</li>
<li>Return a GraphQL response with the requested data, such as this:</li>
</ul>
<pre class="graphql(nocopy)"><code>{ &quot;data&quot;: { &quot;allLinks&quot;: { &quot;url&quot;: &quot;http://graphql.org/&quot; } } }</code></pre>
<ul>
<li>Validate incoming requests against the schema definition and the supported format. For example, if a query is made with an unknown field, the response should be something like:</li>
</ul>
<pre class="graphql(nocopy)"><code>{
  &quot;errors&quot;: [{
    &quot;message&quot;: &quot;Cannot query field \&quot;unknown\&quot; on type \&quot;Link\&quot;.&quot;
  }]
}</code></pre>
<p>These are the basic features all GraphQL servers have, but of course, they can do much more as needed. You can read in more detail about the expected behavior of a GraphQL server in the <a href="https://graphql.org/">official specification</a>.</p>
<h3 id="schema-driven-development">Schema-Driven Development</h3>
<p>An important thing to note about building a GraphQL server is that the main development process will revolve around the schema definition. You’ll see in this chapter that the main steps we’ll follow will be something like this:</p>
<ol type="1">
<li>Define your types and the appropriate queries and mutations for them.</li>
<li>Implement functions called <strong>resolvers</strong> to handle these types and their fields.</li>
<li>As new requirements arrive, go back to step 1 to update the schema and continue through the other steps.</li>
</ol>
<p>The schema is a <em>contract</em> agreed on between the frontend and backend, so keeping it at the center allows both sides of the development to evolve without going off the spec. This also makes it easier to parallelize the work, since the frontend can move on with full knowledge of the API from the start, using a simple mocking service which can later be easily replaced with the final server.</p>
</body>
</html>
