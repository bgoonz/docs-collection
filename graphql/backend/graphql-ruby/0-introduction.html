<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <meta charset="utf-8" />
    <meta name="generator" content="pandoc" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=yes"
    />
    <title>Introduction</title>
    <style type="text/css">
      code {
        white-space: pre-wrap;
      }
      span.smallcaps {
        font-variant: small-caps;
      }
      span.underline {
        text-decoration: underline;
      }
      div.column {
        display: inline-block;
        vertical-align: top;
        width: 50%;
      }
    </style>
  </head>
  <body>
    <header id="title-block-header">
      <h1 class="title">Introduction</h1>
    </header>
    <h3 id="motivation">Motivation</h3>
    <p>
      <a href="https://www.ruby-lang.org/en/">Ruby</a> is general purpose
      programming language optimized for programmer happiness. One of its most
      popular frameworks for building web applications is called
      <a href="http://rubyonrails.org/">Ruby on Rails</a>.
    </p>
    <p>
      The Ruby ecosystem was one of the first to adopt
      <a href="http://graphql.org/">GraphQL</a>. A couple of popular Ruby on
      Rails applications like <a href="https://github.com/">Github</a> and
      <a href="https://www.shopify.com/">Shopify</a> are using it in production
      already.
    </p>
    <p>
      In this chapter you’ll learn how to build your very own
      <a href="http://graphql.org/">GraphQL</a> server using the following
      technologies:
    </p>
    <ul>
      <li>
        <a href="http://rubyonrails.org/">Ruby on Rails</a>: the most popular
        library for building applications in
        <a href="https://www.ruby-lang.org/en/">Ruby</a>
      </li>
      <li>
        <a href="http://graphql-ruby.org/">GraphQL Gem</a>: the most popular
        library for building
        <a href="http://graphql.org/">GraphQL</a> applications
      </li>
      <li>
        <a href="https://github.com/graphql/graphiql">GraphiQL</a>: An
        in-browser IDE for exploring <a href="http://graphql.org/">GraphQL</a>,
        which comes bundled with
        <a href="http://graphql-ruby.org/">GraphQL Gem</a>
      </li>
    </ul>
    <h3 id="what-is-a-graphql-server">What is a GraphQL Server?</h3>
    <p>A GraphQL server should be able to:</p>
    <ul>
      <li>Receive requests following the GraphQL format, for example:</li>
    </ul>
    <pre
      class="graphql(nocopy)"
    ><code>{ &quot;query&quot;: &quot;query { allLinks { url } }&quot; }</code></pre>
    <ul>
      <li>
        Connect to any necessary databases or services responsible for
        storing/fetching the actual data.
      </li>
      <li>Return a GraphQL response with the requested data, such as this:</li>
    </ul>
    <pre
      class="graphql(nocopy)"
    ><code>{ &quot;data&quot;: { &quot;allLinks&quot;: { &quot;url&quot;: &quot;http://graphql.org/&quot; } } }</code></pre>
    <ul>
      <li>
        Validate incoming requests against the schema definition and the
        supported format. For example, if a query is made with an unknown field,
        the response should be something like:
      </li>
    </ul>
    <pre class="graphql(nocopy)"><code>{
  &quot;errors&quot;: [{
    &quot;message&quot;: &quot;Cannot query field \&quot;unknown\&quot; on type \&quot;Link\&quot;.&quot;
  }]
}</code></pre>
    <p>
      These are the basic features all GraphQL servers have, but of course, they
      can do much more as needed. You can read in more detail about the expected
      behavior of a GraphQL server in the
      <a href="https://graphql.org/">official specification</a>.
    </p>
    <h3 id="schema-driven-development">Schema-Driven Development</h3>
    <p>
      An important thing to note about building a GraphQL server is that the
      main development process will revolve around the schema definition. You’ll
      see in this chapter that the main steps we’ll follow will be something
      like this:
    </p>
    <ol type="1">
      <li>
        Define your types and the appropriate queries and mutations for them.
      </li>
      <li>
        Implement functions called <strong>resolvers</strong> to handle these
        types and their fields.
      </li>
      <li>
        As new requirements arrive, go back to step 1 to update the schema and
        continue through the other steps.
      </li>
    </ol>
    <p>
      The schema is a <em>contract</em> agreed on between the frontend and
      backend, so keeping it at the center allows both sides of the development
      to evolve without going off the spec. This also makes it easier to
      parallelize the work, since the frontend can move on with full knowledge
      of the API from the start, using a simple mocking service which can later
      be easily replaced with the final server.
    </p>
  </body>
</html>
