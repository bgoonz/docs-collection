<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Filtering</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">Filtering</h1>
</header>
<p>Another important <a href="https://news.ycombinator.com/">Hackernews</a> feature is searching the links, so you’re going to be adding support for that now. You already know that it’s possible to pass input data to mutations, via arguments. Now you’re going to use this same concept to apply optional filters to the existing <code>allLinks</code> query.</p>
<p>For this part of the tutorial, we are going to use <a href="https://github.com/rstankov/SearchObjectGraphQL">SearchObject::Plugin::GraphQL</a>, gem used for making more advanced GraphQL search/filter resolvers.</p>
<p><Instruction></p>
<p>Add the following lines to your <code>Gemfile</code>:</p>
<pre class="ruby(path=&quot;.../graphql-ruby/gemfile&quot;)"><code>gem &#39;search_object_graphql&#39;, &#39;0.3.1&#39;</code></pre>
<p></Instruction></p>
<p><Instruction></p>
<p>Then run:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb2-1" title="1"><span class="ex">bundle</span> install</a></code></pre></div>
<p></Instruction></p>
<p><Instruction></p>
<p>And restart the server.</p>
<p></Instruction></p>
<p>This would install <a href="https://github.com/rstankov/SearchObjectGraphQL">SearchObject</a> and you can use it.</p>
<p><Instruction></p>
<p>Create a search resolver:</p>
<pre class="ruby(path=&quot;.../graphql-ruby/app/graphql/resolvers/links_search.rb&quot;)"><code>require &#39;search_object&#39;
require &#39;search_object/plugin/graphql&#39;

class Resolvers::LinksSearch
  # include SearchObject for GraphQL
  include SearchObject.module(:graphql)

  # scope is starting point for search
  scope { Link.all }

  type types[Types::LinkType]

  # inline input type definition for the advanced filter
  class LinkFilter &lt; ::Types::BaseInputObject
    argument :OR, [self], required: false
    argument :description_contains, String, required: false
    argument :url_contains, String, required: false
  end

  # when &quot;filter&quot; is passed &quot;apply_filter&quot; would be called to narrow the scope
  option :filter, type: LinkFilter, with: :apply_filter

  # apply_filter recursively loops through &quot;OR&quot; branches
  def apply_filter(scope, value)
    branches = normalize_filters(value).reduce { |a, b| a.or(b) }
    scope.merge branches
  end

  def normalize_filters(value, branches = [])
    scope = Link.all
    scope = scope.where(&#39;description LIKE ?&#39;, &quot;%#{value[:description_contains]}%&quot;) if value[:description_contains]
    scope = scope.where(&#39;url LIKE ?&#39;, &quot;%#{value[:url_contains]}%&quot;) if value[:url_contains]

    branches &lt;&lt; scope

    value[:OR].reduce(branches) { |s, v| normalize_filters(v, s) } if value[:OR].present?

    branches
  end
end</code></pre>
<p></Instruction></p>
<p>This resolver contains all logic related to find links. Over time you can add more rules.</p>
<p><a href="https://github.com/rstankov/SearchObjectGraphQL">SearchObject</a> can be used as a <a href="https://graphql-ruby.org/api-doc/1.10.2/GraphQL/Schema/Resolver.html">GraphQL::Schema::Resolver</a>.</p>
<p><Instruction></p>
<p>Use <code>LinksSearch</code> for finding links:</p>
<pre class="ruby(path=&quot;.../graphql-ruby/app/graphql/types/query_type.rb&quot;)"><code>module Types
  class QueryType &lt; BaseObject
    field :all_links, resolver: Resolvers::LinksSearch
  end
end</code></pre>
<p></Instruction></p>
<p>Try your new filter out now:</p>
<figure>
<img src="https://i.imgur.com/9DCu9VL.png" alt="Try your new filter out" /><figcaption>Try your new filter out</figcaption>
</figure>
<p>You can even do more complicated searches:</p>
<figure>
<img src="https://i.imgur.com/8oBkRfJ.png" alt="You can even do more complicated searches" /><figcaption>You can even do more complicated searches</figcaption>
</figure>
<p><Instruction></p>
<p>Here is the unit test for <code>LinksSearch</code>:</p>
<pre class="ruby(path=&quot;.../graphql-ruby/test/graphql/resolvers/links_search_test.rb&quot;)"><code>require &#39;test_helper&#39;

module Resolvers
  class LinksSearchTest &lt; ActiveSupport::TestCase
    def find(args)
      ::Resolvers::LinksSearch.call(nil, args, nil)
    end

    # those helpers should be handled with something like `factory_bot` gem
    def create_user
      User.create name: &#39;test&#39;, email: &#39;test@example.com&#39;, password: &#39;123456&#39;
    end

    def create_link(**attributes)
      Link.create! attributes.merge(user: create_user)
    end

    test &#39;filter option&#39; do
      link1 = create_link description: &#39;test1&#39;, url: &#39;http://test1.com&#39;
      link2 = create_link description: &#39;test2&#39;, url: &#39;http://test2.com&#39;
      link3 = create_link description: &#39;test3&#39;, url: &#39;http://test3.com&#39;
      link4 = create_link description: &#39;test4&#39;, url: &#39;http://test4.com&#39;

      result = find(
        filter: {
          description_contains: &#39;test1&#39;,
          OR: [{
            url_contains: &#39;test2&#39;,
            OR: [{
              url_contains: &#39;test3&#39;
            }]
          }, {
            description_contains: &#39;test2&#39;
          }]
        }
      )

      assert_equal result.map(&amp;:description).sort, [link1, link2, link3].map(&amp;:description).sort
    end
  end
end</code></pre>
<p>You can run the tests with the following command:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb6-1" title="1"><span class="ex">bundle</span> exec rails test</a></code></pre></div>
<p></Instruction></p>
</body>
</html>
