<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <meta charset="utf-8" />
    <meta name="generator" content="pandoc" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=yes"
    />
    <title>Queries</title>
    <style type="text/css">
      code {
        white-space: pre-wrap;
      }
      span.smallcaps {
        font-variant: small-caps;
      }
      span.underline {
        text-decoration: underline;
      }
      div.column {
        display: inline-block;
        vertical-align: top;
        width: 50%;
      }
    </style>
  </head>
  <body>
    <header id="title-block-header">
      <h1 class="title">Queries</h1>
    </header>
    <h3 id="defining-the-schema">Defining the Schema</h3>
    <p>
      You’re going to start by building out an empty Schema. The GraphQL API is
      how you’re going to expose your data to the web, so you’re going to place
      the code for the schema in the web context of your application. Get
      started by placing the following code in
      <code>lib/community_web/schema.ex</code>
    </p>
    <pre
      class="
        elixir(path=&quot;.../graphql-elixir/lib/community_web/schema.ex&quot;)
      "
    ><code>defmodule CommunityWeb.Schema do
  use Absinthe.Schema

  alias CommunityWeb.NewsResolver

  query do
    # this is the query entry point to our app
  end
end</code></pre>
    <p>
      This is a bare bones skeleton of a GraphQL schema with Absinthe. You’re
      defining a module, using the Absinthe.Schema module to provide some macros
      for schema building, and then setting out an empty root query object. The
      first feature you’re going to tackle is giving a client the ability to get
      all links.
    </p>
    <h3 id="query-for-returning-links">Query for returning links</h3>
    <p>
      The first simple thing to handle is getting all the available links. Add a
      <code>:link</code> object to the schema, and an
      <code>:all_links</code> field to the root query object. There is no need
      to add arguments right now, you’ll do that once you start handling
      filtering and pagination.
    </p>
    <pre
      class="
        elixir(path=&quot;.../graphql-elixir/lib/community_web/schema.ex&quot;)
      "
    ><code>defmodule CommunityWeb.Schema do
  use Absinthe.Schema

  alias CommunityWeb.NewsResolver

  object :link do
    field :id, non_null(:id)
    field :url, non_null(:string)
    field :description, non_null(:string)
  end

  query do
    @desc &quot;Get all links&quot;
    field :all_links, non_null(list_of(non_null(:link)))
  end
end</code></pre>
    <p>
      If you’re coming from a different implementation you may be surprised to
      see the snake case field <code>:all_links</code>. Don’t worry, GraphQL
      documents with <code>allLinks</code> will still work! One of Absinthe’s
      goals is to help developers write code that is both idiomatic for GraphQL
      as well as idiomatic for Elixir. To help with that, Absinthe has some
      built in (and configurable) adapter utilities that transform camel case
      input to snake case schema identifiers.
    </p>
    <p>
      Absinthe Schemas are also type checked at compile time. If you refer to a
      type that doesn’t exist, Absinthe will catch it for you as soon as
      possible!
    </p>
    <h3 id="query-resolver">Query Resolver</h3>
    <p>
      The query is now defined, but the server still doesn’t know how to handle
      it. To do that you will now write your first <strong>resolver</strong>.
      Resolvers are just functions mapped to GraphQL fields, with their actual
      behavior. You specify the field for a resolver by using the resolve macro
      and passing it a function:
    </p>
    <pre
      class="
        elixir(path=&quot;.../graphql-elixir/lib/community_web/schema.ex&quot;)
      "
    ><code>query do
  @desc &quot;Get all links&quot;
  field :all_links, non_null(list_of(non_null(:link))) do
    resolve(&amp;NewsResolver.all_links/3)
  end
end</code></pre>
    <p>
      If you aren’t super familiar with Elixir,
      <code>&amp;NewsResolver.all_links/3</code> is just a reference to the 3
      arity function <code>all_links</code> found in the
      <code>CommunityWeb.NewsResolver</code> module. Neither this function nor
      this module exist yet though so go ahead and fix that by putting this code
      in <code>lib/community_web/resolvers/news_resolver.ex</code>.
    </p>
    <pre
      class="
        elixir(path=&quot;.../graphql-elixir/blob/master/lib/community/web/resolvers/news_resolver.ex&quot;)
      "
    ><code>defmodule CommunityWeb.NewsResolver do
  alias Community.News

  def all_links(_root, _args, _info) do
    {:ok, News.list_links()}
  end
end</code></pre>
    <p>
      That’s it! You now have a schema that can do something. All you need to do
      now is setup our HTTP server with GraphiQL.
    </p>
    <h3 id="testing-with-playground">Testing with playground</h3>
    <p>
      It’s time to test what you’ve done so far! For this you’ll use
      <a href="https://github.com/graphql/graphiql">GraphiQL</a>, which you’ll
      need to route to from within the router generated for us by Phoenix.
      Replace the contents of <code>lib/community_web/router.ex</code> with:
    </p>
    <pre
      class="
        elixir(path=&quot;.../graphql-elixir/blob/master/lib/community/web/router.ex&quot;)
      "
    ><code>defmodule CommunityWeb.Router do
  use CommunityWeb, :router

  pipeline :api do
    plug :accepts, [&quot;json&quot;]
  end

  scope &quot;/&quot; do
    pipe_through :api

    forward &quot;/graphiql&quot;, Absinthe.Plug.GraphiQL,
      schema: CommunityWeb.Schema,
      interface: :simple,
      context: %{pubsub: CommunityWeb.Endpoint}
  end

end</code></pre>
    <p>
      Start your server with <code>iex -S mix phx.server</code> and then open
      your browser to
      <a href="http://localhost:4000/graphiql">localhost:4000/graphiql</a>.
    </p>
    <figure>
      <img
        src="http://i.imgur.com/EZIVYxP.png"
        alt="Browser open to localhost:4000/graphiql"
      />
      <figcaption>Browser open to localhost:4000/graphiql</figcaption>
    </figure>
    <p>
      Click on the <strong>Docs</strong> link at the upper right to see a
      generated documentation of your schema. You’ll see the
      <code>Query</code> type there, and clicking it will show you the new
      <code>allLinks</code> field, exactly as you’ve defined it. The
      documentation in GraphiQL is generated automatically based on your schema.
      This works thanks to a mechanism called
      <a href="http://graphql.org/learn/introspection/">Introspection</a>.
    </p>
    <figure>
      <img
        src="http://i.imgur.com/yEut1gg.png"
        alt="Generated documentation of your schema"
      />
      <figcaption>Generated documentation of your schema</figcaption>
    </figure>
    <p>
      Try it out! On the left-most text box, type a simple query for listing all
      links and hit the <strong>Play</strong> button. This is what you’ll see:
    </p>
    <pre class="graphql"><code>{
  allLinks {
    id
    url
    description
  }
}</code></pre>
    <figure>
      <img src="http://i.imgur.com/W7gpVvV.png" alt="GraphQL APIs" />
      <figcaption>GraphQL APIs</figcaption>
    </figure>
    <p>
      You can play around as much as you want with this tool. It makes testing
      GraphQL APIs so fun and easy, you’ll never want to live without it any
      more.
    </p>
  </body>
</html>
