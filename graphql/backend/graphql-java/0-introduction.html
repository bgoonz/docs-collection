<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <meta charset="utf-8" />
    <meta name="generator" content="pandoc" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=yes"
    />
    <title>Introduction</title>
    <style type="text/css">
      code {
        white-space: pre-wrap;
      }
      span.smallcaps {
        font-variant: small-caps;
      }
      span.underline {
        text-decoration: underline;
      }
      div.column {
        display: inline-block;
        vertical-align: top;
        width: 50%;
      }
    </style>
  </head>
  <body>
    <header id="title-block-header">
      <h1 class="title">Introduction</h1>
    </header>
    <h3 id="warning">Warning</h3>
    <p>
      The GraphQL Java tutorial by
      <span class="citation" data-cites="kaqqao">[@kaqqao]</span
      >(https://github.com/kaqqao) is unfortunately outdated and also uses some
      third party libraries on top of GraphQL Java, without making it clear that
      it is actually not GraphQL Java itself. The author is working on an
      updated version. Meanwhile, our recommend approach can be found
      <a
        href="https://www.graphql-java.com/tutorials/getting-started-with-spring-boot/"
        >here</a
      >.
    </p>
    <p>
      More information about this issue can be found
      <a href="https://github.com/howtographql/howtographql/issues/913">here</a
      >.
    </p>
    <h3 id="motivation">Motivation</h3>
    <p>
      Hovering around the top of most popularity indexes, Java holds a tight
      grip over vast segments of the market, and is frequently employed in
      scenarios well within GraphQL’s sweet spot. This is especially true when
      taking into account the type systems of the two technologies, in majority
      of cases, fit rather neatly together.
    </p>
    <h3 id="what-is-a-graphql-server">What is a GraphQL server?</h3>
    <p>
      The software component that parses, validates and executes GraphQL
      queries/mutations is commonly referred to as the GraphQL server. In this
      regard, it is similar to a database server that parses, validates and
      executes SQL queries. Implementations of GraphQL servers exist in a
      multitude of languages, implying easy introduction of GraphQL into
      virtually any technology stack.
    </p>
    <p>
      In this chapter, you’ll dive into the development of a custom GraphQL
      backend with Java.
    </p>
    <h3 id="schema-driven-development">Schema-driven development</h3>
    <p>
      While contract-first design has been touted in various contexts, it has
      rarely been easy to employ.
    </p>
    <blockquote>
      <p>
        Developing the contract (be it in the form of WSDL or Swagger or
        anything else) often assumes a deep and precise understanding of the
        client’s data requirements upfront, and this type of understanding is
        usually only developed <em>over time</em>.
      </p>
    </blockquote>
    <p>
      GraphQL conveniently does away with this hurdle by making the decision of
      what data gets fetched the exclusive domain of the client, opening in turn
      a path to a much smoother API evolution. This is further complemented by
      GraphQL’s self-describing nature (via
      <a href="http://graphql.org/learn/introspection/">introspection queries</a
      >), making contract-first (or rather <em>schema-first</em>, in GraphQL
      lingo) approach both natural and easy.
    </p>
    <p>
      The schema in GraphQL is the central contract between the client and the
      server, describing all the types of data and all the operations (queries
      and mutations) upon those types the server offers. Beyond the usual
      promise of client-server independence and easy mocking, developing in the
      schema-first style helps enforce the good practice of structuring the
      logic into smaller and simpler functions (the
      <em
        ><a href="https://en.wikipedia.org/wiki/Single_responsibility_principle"
          >single responsibility principle</a
        ></em
      >) that can conveniently be used as resolvers.
    </p>
    <p>
      With that said, the statically typed nature of Java also lends itself well
      to an alternative style, where the schema is generated dynamically, based
      on the typing information already present in the code. We will explore
      this approach briefly at the end of the track.
    </p>
  </body>
</html>
