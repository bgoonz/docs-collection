<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <meta charset="utf-8" />
    <meta name="generator" content="pandoc" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=yes"
    />
    <title>Android Native Modules</title>
    <style type="text/css">
      code {
        white-space: pre-wrap;
      }
      span.smallcaps {
        font-variant: small-caps;
      }
      span.underline {
        text-decoration: underline;
      }
      div.column {
        display: inline-block;
        vertical-align: top;
        width: 50%;
      }
    </style>
    <style type="text/css">
      a.sourceLine {
        display: inline-block;
        line-height: 1.25;
      }
      a.sourceLine {
        pointer-events: none;
        color: inherit;
        text-decoration: inherit;
      }
      a.sourceLine:empty {
        height: 1.2em;
      }
      .sourceCode {
        overflow: visible;
      }
      code.sourceCode {
        white-space: pre;
        position: relative;
      }
      div.sourceCode {
        margin: 1em 0;
      }
      pre.sourceCode {
        margin: 0;
      }
      @media screen {
        div.sourceCode {
          overflow: auto;
        }
      }
      @media print {
        code.sourceCode {
          white-space: pre-wrap;
        }
        a.sourceLine {
          text-indent: -1em;
          padding-left: 1em;
        }
      }
      pre.numberSource a.sourceLine {
        position: relative;
        left: -4em;
      }
      pre.numberSource a.sourceLine::before {
        content: attr(title);
        position: relative;
        left: -1em;
        text-align: right;
        vertical-align: baseline;
        border: none;
        pointer-events: all;
        display: inline-block;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        -khtml-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        padding: 0 4px;
        width: 4em;
        color: #aaaaaa;
      }
      pre.numberSource {
        margin-left: 3em;
        border-left: 1px solid #aaaaaa;
        padding-left: 4px;
      }
      div.sourceCode {
      }
      @media screen {
        a.sourceLine::before {
          text-decoration: underline;
        }
      }
      code span.al {
        color: #ff0000;
        font-weight: bold;
      } /* Alert */
      code span.an {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* Annotation */
      code span.at {
        color: #7d9029;
      } /* Attribute */
      code span.bn {
        color: #40a070;
      } /* BaseN */
      code span.bu {
      } /* BuiltIn */
      code span.cf {
        color: #007020;
        font-weight: bold;
      } /* ControlFlow */
      code span.ch {
        color: #4070a0;
      } /* Char */
      code span.cn {
        color: #880000;
      } /* Constant */
      code span.co {
        color: #60a0b0;
        font-style: italic;
      } /* Comment */
      code span.cv {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* CommentVar */
      code span.do {
        color: #ba2121;
        font-style: italic;
      } /* Documentation */
      code span.dt {
        color: #902000;
      } /* DataType */
      code span.dv {
        color: #40a070;
      } /* DecVal */
      code span.er {
        color: #ff0000;
        font-weight: bold;
      } /* Error */
      code span.ex {
      } /* Extension */
      code span.fl {
        color: #40a070;
      } /* Float */
      code span.fu {
        color: #06287e;
      } /* Function */
      code span.im {
      } /* Import */
      code span.in {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* Information */
      code span.kw {
        color: #007020;
        font-weight: bold;
      } /* Keyword */
      code span.op {
        color: #666666;
      } /* Operator */
      code span.ot {
        color: #007020;
      } /* Other */
      code span.pp {
        color: #bc7a00;
      } /* Preprocessor */
      code span.sc {
        color: #4070a0;
      } /* SpecialChar */
      code span.ss {
        color: #bb6688;
      } /* SpecialString */
      code span.st {
        color: #4070a0;
      } /* String */
      code span.va {
        color: #19177c;
      } /* Variable */
      code span.vs {
        color: #4070a0;
      } /* VerbatimString */
      code span.wa {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* Warning */
    </style>
  </head>
  <body>
    <header id="title-block-header">
      <h1 class="title">Android Native Modules</h1>
    </header>
    <p>
      Welcome to Native Modules for Android. Please start by reading the
      <a href="native-modules-intro">Native Modules Intro</a> for an intro to
      what native modules are.
    </p>
    <h2 id="create-a-calendar-native-module">
      Create a Calendar Native Module
    </h2>
    <p>
      In the following guide you will create a native module,
      <code>CalendarModule</code>, that will allow you to access Android’s
      calendar APIs from JavaScript. By the end, you will be able to call
      <code
        >CalendarModule.createCalendarEvent('Dinner Party', 'My House');</code
      >
      from JavaScript, invoking a Java method that creates a calendar event.
    </p>
    <blockquote>
      <p>
        The React Native team is currently working on a re-architecture of the
        Native Module system. This new system is called TurboModules, and it
        will help facilitate more efficient type-safe communication between
        JavaScript and native, without relying on the React Native bridge. It
        will also enable new extensions that weren’t possible with the legacy
        Native Module system. You can read more about it
        <a
          href="https://github.com/react-native-community/discussions-and-proposals/issues/40"
          >here</a
        >. Throughout these docs we have added notes around parts of Native
        Modules that will change in the TurboModules release and how you can
        best prepare for a smooth upgrade to TurboModules.
      </p>
    </blockquote>
    <h3 id="setup">Setup</h3>
    <p>
      To get started, open up the Android project within your React Native
      application in Android Studio. You can find your Android project here
      within a React Native app:
    </p>
    <figure>
      <img
        src="/docs/assets/native-modules-android-open-project.png"
        width="500"
        alt="Image of opening up an Android project within a React Native app inside of Android Studio."
      />
      <figcaption>Image of where you can find your Android project</figcaption>
    </figure>
    <p>
      We recommend using Android Studio to write your native code. Android
      studio is an IDE built for Android development and using it will help you
      resolve minor issues like code syntax errors quickly.
    </p>
    <p>
      We also recommend enabling
      <a href="https://docs.gradle.org/2.9/userguide/gradle_daemon.html"
        >Gradle Daemon</a
      >
      to speed up builds as you iterate on Java code.
    </p>
    <h3 id="create-a-custom-native-module-file">
      Create A Custom Native Module File
    </h3>
    <p>
      The first step is to create the CalendarModule.java Java file inside
      <code>android/app/src/main/java/com/your-app-name/ folder</code>. This
      Java file will contain your native module Java class.
    </p>
    <figure>
      <img
        src="/docs/assets/native-modules-android-add-class.png"
        width="700"
        alt="Image of adding a class called CalendarModule.java within the Android Studio."
      />
      <figcaption>Image of how to add the CalendarModuleClass</figcaption>
    </figure>
    <p>Then add the following content:</p>
    <div class="sourceCode" id="cb1">
      <pre
        class="sourceCode java"
      ><code class="sourceCode java"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">package</span><span class="im"> com.your-app-name;</span> <span class="co">// replace com.your-app-name with your app’s name</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="kw">import</span><span class="im"> com.facebook.react.bridge.NativeModule;</span></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="kw">import</span><span class="im"> com.facebook.react.bridge.ReactApplicationContext;</span></a>
<a class="sourceLine" id="cb1-4" title="4"><span class="kw">import</span><span class="im"> com.facebook.react.bridge.ReactContext;</span></a>
<a class="sourceLine" id="cb1-5" title="5"><span class="kw">import</span><span class="im"> com.facebook.react.bridge.ReactContextBaseJavaModule;</span></a>
<a class="sourceLine" id="cb1-6" title="6"><span class="kw">import</span><span class="im"> com.facebook.react.bridge.ReactMethod;</span></a>
<a class="sourceLine" id="cb1-7" title="7"><span class="kw">import</span><span class="im"> java.util.Map;</span></a>
<a class="sourceLine" id="cb1-8" title="8"><span class="kw">import</span><span class="im"> java.util.HashMap;</span></a>
<a class="sourceLine" id="cb1-9" title="9"></a>
<a class="sourceLine" id="cb1-10" title="10"><span class="kw">public</span> <span class="kw">class</span> CalendarModule <span class="kw">extends</span> ReactContextBaseJavaModule {</a>
<a class="sourceLine" id="cb1-11" title="11">   <span class="fu">CalendarModule</span>(ReactApplicationContext context) {</a>
<a class="sourceLine" id="cb1-12" title="12">       <span class="kw">super</span>(context);</a>
<a class="sourceLine" id="cb1-13" title="13">   }</a>
<a class="sourceLine" id="cb1-14" title="14">}</a></code></pre>
    </div>
    <p>
      As you can see, your <code>CalendarModule</code> class extends the
      <code>ReactContextBaseJavaModule</code> class. For Android, Java native
      modules are written as classes that extend
      <code>ReactContextBaseJavaModule</code> and implement the functionality
      required by JavaScript.
    </p>
    <blockquote>
      <p>
        It is worth noting that technically Java classes only need to extend the
        <code>BaseJavaModule</code> class or implement the
        <code>NativeModule</code> interface to be considered a Native Module by
        React Native.
      </p>
    </blockquote>
    <blockquote>
      <p>
        However we recommend that you use
        <code>ReactContextBaseJavaModule</code>, as shown above.
        <code>ReactContextBaseJavaModule</code> gives access to the
        <code>ReactApplicationContext</code> (RAC), which is useful for Native
        Modules that need to hook into activity lifecycle methods. Using
        <code>ReactContextBaseJavaModule</code> will also make it easier to make
        your native module type-safe in the future. For native module
        type-safety, which is coming in future releases, React Native looks at
        each native module’s JavaScript spec and generates an abstract base
        class that extends <code>ReactContextBaseJavaModule</code>.
      </p>
    </blockquote>
    <h3 id="module-name">Module Name</h3>
    <p>
      All Java native modules in Android need to implement the
      <code>getName()</code> method. This method returns a string, which
      represents the name of the native module. The native module can then be
      accessed in JavaScript using its name. For example, in the below code
      snippet, <code>getName()</code> returns <code>"CalendarModule"</code>.
    </p>
    <div class="sourceCode" id="cb2">
      <pre
        class="sourceCode java"
      ><code class="sourceCode java"><a class="sourceLine" id="cb2-1" title="1"><span class="co">// add to CalendarModule.java</span></a>
<a class="sourceLine" id="cb2-2" title="2"><span class="at">@Override</span></a>
<a class="sourceLine" id="cb2-3" title="3"><span class="kw">public</span> <span class="bu">String</span> <span class="fu">getName</span>() {</a>
<a class="sourceLine" id="cb2-4" title="4">   <span class="kw">return</span> <span class="st">&quot;CalendarModule&quot;</span>;</a>
<a class="sourceLine" id="cb2-5" title="5">}</a></code></pre>
    </div>
    <p>The native module can then be accessed in JS like this:</p>
    <pre
      class="jsx"
    ><code>const { CalendarModule } = ReactNative.NativeModules;</code></pre>
    <h3 id="export-a-native-method-to-javascript">
      Export a Native Method to JavaScript
    </h3>
    <p>
      Next you will need to add a method to your native module that will create
      calendar events and can be invoked in JavaScript. All native module
      methods meant to be invoked from JavaScript must be annotated with
      <code>@ReactMethod</code>.
    </p>
    <p>
      Set up a method <code>createCalendarEvent()</code> for
      <code>CalendarModule</code> that can be invoked in JS through
      <code>CalendarModule.createCalendarEvent()</code>. For now, the method
      will take in a name and location as strings. Argument type options will be
      covered shortly.
    </p>
    <div class="sourceCode" id="cb4">
      <pre
        class="sourceCode java"
      ><code class="sourceCode java"><a class="sourceLine" id="cb4-1" title="1"><span class="at">@ReactMethod</span></a>
<a class="sourceLine" id="cb4-2" title="2"><span class="kw">public</span> <span class="dt">void</span> <span class="fu">createCalendarEvent</span>(<span class="bu">String</span> name, <span class="bu">String</span> location) {</a>
<a class="sourceLine" id="cb4-3" title="3">}</a></code></pre>
    </div>
    <p>
      Add a debug log in the method to confirm it has been invoked when you call
      it from your application. Below is an example of how you can import and
      use the
      <a href="https://developer.android.com/reference/android/util/Log">Log</a>
      class from the Android util package:
    </p>
    <div class="sourceCode" id="cb5">
      <pre
        class="sourceCode java"
      ><code class="sourceCode java"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">import</span><span class="im"> android.util.Log;</span></a>
<a class="sourceLine" id="cb5-2" title="2"></a>
<a class="sourceLine" id="cb5-3" title="3"><span class="at">@ReactMethod</span></a>
<a class="sourceLine" id="cb5-4" title="4"><span class="kw">public</span> <span class="dt">void</span> <span class="fu">createCalendarEvent</span>(<span class="bu">String</span> name, <span class="bu">String</span> location) {</a>
<a class="sourceLine" id="cb5-5" title="5">   Log.<span class="fu">d</span>(<span class="st">&quot;CalendarModule&quot;</span>, <span class="st">&quot;Create event called with name: &quot;</span> + name</a>
<a class="sourceLine" id="cb5-6" title="6">   + <span class="st">&quot; and location: &quot;</span> + location);</a>
<a class="sourceLine" id="cb5-7" title="7">}</a></code></pre>
    </div>
    <p>
      Once you finish implementing the native module and hook it up in
      JavaScript, you can follow
      <a href="https://developer.android.com/studio/debug/am-logcat.html"
        >these steps</a
      >
      to view the logs from your app.
    </p>
    <h3 id="synchronous-methods">Synchronous Methods</h3>
    <p>
      You can pass <code>isBlockingSynchronousMethod = true</code> to a native
      method to mark it as a synchronous method.
    </p>
    <div class="sourceCode" id="cb6">
      <pre
        class="sourceCode java"
      ><code class="sourceCode java"><a class="sourceLine" id="cb6-1" title="1"><span class="at">@ReactMethod</span>(isBlockingSynchronousMethod = <span class="kw">true</span>)</a></code></pre>
    </div>
    <p>
      At the moment, we do not recommend this, since calling methods
      synchronously can have strong performance penalties and introduce
      threading-related bugs to your native modules. Additionally, please note
      that if you choose to enable <code>isBlockingSynchronousMethod</code>,
      your app can no longer use the Google Chrome debugger. This is because
      synchronous methods require the JS VM to share memory with the app. For
      the Google Chrome debugger, React Native runs inside the JS VM in Google
      Chrome, and communicates asynchronously with the mobile devices via
      WebSockets.
    </p>
    <h3 id="register-the-module-android-specific">
      Register the Module (Android Specific)
    </h3>
    <p>
      Once a native module is written, it needs to be registered with React
      Native. In order to do so, you need to add your native module to a
      <code>ReactPackage</code> and register the <code>ReactPackage</code> with
      React Native. During initialization, React Native will loop over all
      packages, and for each <code>ReactPackage</code>, register each native
      module within.
    </p>
    <p>
      React Native invokes the method <code>createNativeModules()</code> on a
      <code>ReactPackage</code> in order to get the list of native modules to
      register. For Android, if a module is not instantiated and returned in
      createNativeModules it will not be available from JavaScript.
    </p>
    <p>
      To add your Native Module to <code>ReactPackage</code>, first create a new
      Java Class named <code>MyAppPackage.java</code> that implements
      <code>ReactPackage</code> inside the
      <code>android/app/src/main/java/com/your-app-name/</code> folder:
    </p>
    <p>Then add the following content:</p>
    <div class="sourceCode" id="cb7">
      <pre
        class="sourceCode java"
      ><code class="sourceCode java"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">package</span><span class="im"> com.your-app-name;</span> <span class="co">// replace your-app-name with your app’s name</span></a>
<a class="sourceLine" id="cb7-2" title="2"><span class="kw">import</span><span class="im"> com.facebook.react.ReactPackage;</span></a>
<a class="sourceLine" id="cb7-3" title="3"><span class="kw">import</span><span class="im"> com.facebook.react.bridge.NativeModule;</span></a>
<a class="sourceLine" id="cb7-4" title="4"><span class="kw">import</span><span class="im"> com.facebook.react.bridge.ReactApplicationContext;</span></a>
<a class="sourceLine" id="cb7-5" title="5"><span class="kw">import</span><span class="im"> com.facebook.react.uimanager.ViewManager;</span></a>
<a class="sourceLine" id="cb7-6" title="6"></a>
<a class="sourceLine" id="cb7-7" title="7"><span class="kw">import</span><span class="im"> java.util.ArrayList;</span></a>
<a class="sourceLine" id="cb7-8" title="8"><span class="kw">import</span><span class="im"> java.util.Collections;</span></a>
<a class="sourceLine" id="cb7-9" title="9"><span class="kw">import</span><span class="im"> java.util.List;</span></a>
<a class="sourceLine" id="cb7-10" title="10"></a>
<a class="sourceLine" id="cb7-11" title="11"><span class="kw">public</span> <span class="kw">class</span> MyAppPackage <span class="kw">implements</span> ReactPackage {</a>
<a class="sourceLine" id="cb7-12" title="12"></a>
<a class="sourceLine" id="cb7-13" title="13">   <span class="at">@Override</span></a>
<a class="sourceLine" id="cb7-14" title="14">   <span class="kw">public</span> <span class="bu">List</span>&lt;ViewManager&gt; <span class="fu">createViewManagers</span>(ReactApplicationContext reactContext) {</a>
<a class="sourceLine" id="cb7-15" title="15">       <span class="kw">return</span> <span class="bu">Collections</span>.<span class="fu">emptyList</span>();</a>
<a class="sourceLine" id="cb7-16" title="16">   }</a>
<a class="sourceLine" id="cb7-17" title="17"></a>
<a class="sourceLine" id="cb7-18" title="18">   <span class="at">@Override</span></a>
<a class="sourceLine" id="cb7-19" title="19">   <span class="kw">public</span> <span class="bu">List</span>&lt;NativeModule&gt; <span class="fu">createNativeModules</span>(</a>
<a class="sourceLine" id="cb7-20" title="20">           ReactApplicationContext reactContext) {</a>
<a class="sourceLine" id="cb7-21" title="21">       <span class="bu">List</span>&lt;NativeModule&gt; modules = <span class="kw">new</span> <span class="bu">ArrayList</span>&lt;&gt;();</a>
<a class="sourceLine" id="cb7-22" title="22"></a>
<a class="sourceLine" id="cb7-23" title="23">       modules.<span class="fu">add</span>(<span class="kw">new</span> <span class="fu">CalendarModule</span>(reactContext));</a>
<a class="sourceLine" id="cb7-24" title="24"></a>
<a class="sourceLine" id="cb7-25" title="25">       <span class="kw">return</span> modules;</a>
<a class="sourceLine" id="cb7-26" title="26">   }</a>
<a class="sourceLine" id="cb7-27" title="27"></a>
<a class="sourceLine" id="cb7-28" title="28">}</a></code></pre>
    </div>
    <p>
      This file imports the native module you created,
      <code>CalendarModule</code>. It then instantiates
      <code>CalendarModule</code> within the
      <code>createNativeModules()</code> function and returns it as a list of
      <code>NativeModules</code> to register. If you add more native modules
      down the line, you can also instantiate them and add them to the list
      returned here.
    </p>
    <blockquote>
      <p>
        It is worth noting that this way of registering native modules eagerly
        initializes all native modules when the application starts, which adds
        to the startup time of an application. You can use
        <a
          href="https://github.com/facebook/react-native/blob/master/ReactAndroid/src/main/java/com/facebook/react/TurboReactPackage.java"
          >TurboReactPackage</a
        >
        as an alternative. Instead of <code>createNativeModules</code>, which
        return a list of instantiated native module objects, TurboReactPackage
        implements a
        <code>getModule(String name, ReactApplicationContext rac)</code> method
        that creates the native module object, when required. TurboReactPackage
        is a bit more complicated to implement at the moment. In addition to
        implementing a <code>getModule()</code> method, you have to implement a
        <code>getReactModuleInfoProvider()</code> method, which returns a list
        of all the native modules the package can instantiate along with a
        function that instantiates them, example
        <a
          href="https://github.com/facebook/react-native/blob/8ac467c51b94c82d81930b4802b2978c85539925/ReactAndroid/src/main/java/com/facebook/react/CoreModulesPackage.java#L86-L165"
          >here</a
        >. Again, using TurboReactPackage will allow your application to have a
        faster startup time, but it is currently a bit cumbersome to write. So
        proceed with caution if you choose to use TurboReactPackages.
      </p>
    </blockquote>
    <p>
      To register the <code>CalendarModule</code> package, you must add
      <code>MyAppPackage</code> to the list of packages returned in
      ReactNativeHost’s <code>getPackages()</code> method. Open up your
      <code>MainApplication.java</code> file, which can be found in the
      following path:
      <code
        >android/app/src/main/java/com/your-app-name/MainApplication.java</code
      >
    </p>
    <p>
      Locate ReactNativeHost’s <code>getPackages()</code> method and add your
      package to the packages list <code>getPackages()</code> returns:
    </p>
    <div class="sourceCode" id="cb8">
      <pre
        class="sourceCode java"
      ><code class="sourceCode java"><a class="sourceLine" id="cb8-1" title="1"><span class="at">@Override</span></a>
<a class="sourceLine" id="cb8-2" title="2">  <span class="kw">protected</span> <span class="bu">List</span>&lt;ReactPackage&gt; <span class="fu">getPackages</span>() {</a>
<a class="sourceLine" id="cb8-3" title="3">    <span class="at">@SuppressWarnings</span>(<span class="st">&quot;UnnecessaryLocalVariable&quot;</span>)</a>
<a class="sourceLine" id="cb8-4" title="4">    <span class="bu">List</span>&lt;ReactPackage&gt; packages = <span class="kw">new</span> <span class="fu">PackageList</span>(<span class="kw">this</span>).<span class="fu">getPackages</span>();</a>
<a class="sourceLine" id="cb8-5" title="5">    <span class="co">// below MyAppPackage is added to the list of packages returned</span></a>
<a class="sourceLine" id="cb8-6" title="6">    packages.<span class="fu">add</span>(<span class="kw">new</span> <span class="fu">MyAppPackage</span>());</a>
<a class="sourceLine" id="cb8-7" title="7">    <span class="kw">return</span> packages;</a>
<a class="sourceLine" id="cb8-8" title="8">  }</a></code></pre>
    </div>
    <p>You have now successfully registered your native module for Android!</p>
    <h3 id="test-what-you-have-built">Test What You Have Built</h3>
    <p>
      At this point, you have set up the basic scaffolding for your native
      module in Android. Test that out by accessing the native module and
      invoking its exported method in JavaScript.
    </p>
    <p>
      Find a place in your application where you would like to add a call to the
      native module’s <code>createCalendarEvent()</code> method. Below is an
      example of a component, <code>NewModuleButton</code> you can add in your
      app. You can invoke the native module inside
      <code>NewModuleButton</code>’s <code>onPress()</code> function.
    </p>
    <pre class="jsx"><code>import React from &#39;react&#39;;
import { NativeModules, Button } from &#39;react-native&#39;;

const NewModuleButton = () =&gt; {
  const onPress = () =&gt; {
    console.log(&#39;We will invoke the native module here!&#39;);
  };

  return (
    &lt;Button
      title=&quot;Click to invoke your native module!&quot;
      color=&quot;#841584&quot;
      onPress={onPress}
    /&gt;
  );
};

export default NewModuleButton;</code></pre>
    <p>
      In order to access your native module from JavaScript you need to first
      import <code>NativeModules</code> from React Native:
    </p>
    <pre
      class="jsx"
    ><code>import { NativeModules } from &#39;react-native&#39;;</code></pre>
    <p>
      You can then access the <code>CalendarModule</code> native module off of
      <code>NativeModules</code>.
    </p>
    <pre
      class="jsx"
    ><code>const { CalendarModule } = NativeModules;</code></pre>
    <p>
      Now that you have the CalendarModule native module available, you can
      invoke your native method <code>createCalendarEvent()</code>. Below it is
      added to the <code>onPress()</code> method in
      <code>NewModuleButton</code>:
    </p>
    <pre class="jsx"><code>const onPress = () =&gt; {
  CalendarModule.createCalendarEvent(&#39;testName&#39;, &#39;testLocation&#39;);
};</code></pre>
    <p>
      The final step is to rebuild the React Native app so that you can have the
      latest native code (with your new native module!) available. In your
      command line, where the react native application is located, run the
      following:
    </p>
    <pre class="shell"><code>npx react-native run-android</code></pre>
    <h3 id="building-as-you-iterate">Building as You Iterate</h3>
    <p>
      As you work through these guides and iterate on your native module, you
      will need to do a native rebuild of your application to access your most
      recent changes from JavaScript. This is because the code that you are
      writing sits within the native part of your application. While React
      Native’s metro bundler can watch for changes in JavaScript and rebuild on
      the fly for you, it will not do so for native code. So if you want to test
      your latest native changes you need to rebuild by using the
      <code>npx react-native run-android</code> command.
    </p>
    <h3 id="recap">Recap✨</h3>
    <p>
      You should now be able to invoke your
      <code>createCalendarEvent()</code> method on your native module in the
      app. In our example this occurs by pressing the
      <code>NewModuleButton</code>. You can confirm this by viewing the log you
      set up in your <code>createCalendarEvent()</code> method. You can follow
      <a href="https://developer.android.com/studio/debug/am-logcat.html"
        >these steps</a
      >
      to view ADB logs in your app. You should then be able to search for your
      <code>Log.d</code> message (in our example “Create event called with name:
      testName and location: testLocation”) and see your message logged each
      time you invoke your native module method.
    </p>
    <figure>
      <img
        src="/docs/assets/native-modules-android-logs.png"
        width="1000"
        alt="Image of logs."
      />
      <figcaption>Image of ADB logs in Android Studio</figcaption>
    </figure>
    <p>
      At this point you have created an Android native module and invoked its
      native method from JavaScript in your React Native application. You can
      read on to learn more about things like argument types available to a
      native module method and how to setup callbacks and promises.
    </p>
    <h2 id="beyond-a-calendar-native-module">
      Beyond a Calendar Native Module
    </h2>
    <h3 id="better-native-module-export">Better Native Module Export</h3>
    <p>
      Importing your native module by pulling it off of
      <code>NativeModules</code> like above is a bit clunky.
    </p>
    <p>
      To save consumers of your native module from needing to do that each time
      they want to access your native module, you can create a JavaScript
      wrapper for the module. Create a new JavaScript file named
      <code>CalendarModule.js</code> with the following content:
    </p>
    <pre class="jsx"><code>/**
* This exposes the native CalendarModule module as a JS module. This has a
* function &#39;createCalendarEvent&#39; which takes the following parameters:

* 1. String name: A string representing the name of the event
* 2. String location: A string representing the location of the event
*/
import { NativeModules } from &#39;react-native&#39;;
const { CalendarModule } = NativeModules;
export default CalendarModule;</code></pre>
    <p>
      This JavaScript file also becomes a good location for you to add any
      JavaScript side functionality. For example, if you use a type system like
      Typescript you can add type annotations for your native module here. While
      React Native does not yet support Native to JS type safety, all your JS
      code will be type safe. Doing so will also make it easier for you to
      switch to type-safe native modules down the line. Below is an example of
      adding type safety to the CalendarModule:
    </p>
    <pre class="jsx"><code>/**
* This exposes the native CalendarModule module as a JS module. This has a
* function &#39;createCalendarEvent&#39; which takes the following parameters:
*
* 1. String name: A string representing the name of the event
* 2. String location: A string representing the location of the event
*/
import { NativeModules } from &#39;react-native&#39;;
const { CalendarModule } = NativeModules
interface CalendarInterface {
   createCalendarEvent(name: string, location: string): void;
}
export default CalendarModule as CalendarInterface;</code></pre>
    <p>
      In your other JavaScript files you can access the native module and invoke
      its method like this:
    </p>
    <pre
      class="jsx"
    ><code>import CalendarModule from &#39;./CalendarModule&#39;;
CalendarModule.createCalendarEvent(&#39;foo&#39;, &#39;bar&#39;);</code></pre>
    <blockquote>
      <p>
        This assumes that the place you are importing
        <code>CalendarModule</code> is in the same hierarchy as
        <code>CalendarModule.js</code>. Please update the relative import as
        necessary.
      </p>
    </blockquote>
    <h3 id="argument-types">Argument Types</h3>
    <p>
      When a native module method is invoked in JavaScript, React Native
      converts the arguments from JS objects to their Java object analogues. So
      for example, if your Java Native Module method accepts a double, in JS you
      need to call the method with a number. React Native will handle the
      conversion for you. Below is a list of the argument types supported for
      native module methods and the JavaScript equivalents they map to.
    </p>
    <table>
      <thead>
        <tr class="header">
          <th>Java</th>
          <th>JavaScript</th>
        </tr>
      </thead>
      <tbody>
        <tr class="odd">
          <td>Boolean</td>
          <td>?boolean</td>
        </tr>
        <tr class="even">
          <td>boolean</td>
          <td>boolean</td>
        </tr>
        <tr class="odd">
          <td>Double</td>
          <td>?number</td>
        </tr>
        <tr class="even">
          <td>double</td>
          <td>number</td>
        </tr>
        <tr class="odd">
          <td>String</td>
          <td>string</td>
        </tr>
        <tr class="even">
          <td>Callback</td>
          <td>Function</td>
        </tr>
        <tr class="odd">
          <td>ReadableMap</td>
          <td>Object</td>
        </tr>
        <tr class="even">
          <td>ReadableArray</td>
          <td>Array</td>
        </tr>
      </tbody>
    </table>
    <blockquote>
      <p>
        The following types are currently supported but will not be supported in
        TurboModules. Please avoid using them:
      </p>
      <ul>
        <li>Integer -&gt; ?number</li>
        <li>int -&gt; number</li>
        <li>Float -&gt; ?number</li>
        <li>float -&gt; number</li>
      </ul>
    </blockquote>
    <p>
      For argument types not listed above, you will need to handle the
      conversion yourself. For example, in Android, <code>Date</code> conversion
      is not supported out of the box. You can handle the conversion to the
      <code>Date</code> type within the native method yourself like so:
    </p>
    <div class="sourceCode" id="cb17">
      <pre
        class="sourceCode java"
      ><code class="sourceCode java"><a class="sourceLine" id="cb17-1" title="1">    <span class="bu">String</span> dateFormat = <span class="st">&quot;yyyy-MM-dd&quot;</span>;</a>
<a class="sourceLine" id="cb17-2" title="2">    <span class="bu">SimpleDateFormat</span> sdf = <span class="kw">new</span> <span class="bu">SimpleDateFormat</span>(dateFormat);</a>
<a class="sourceLine" id="cb17-3" title="3">    <span class="bu">Calendar</span> eStartDate = <span class="bu">Calendar</span>.<span class="fu">getInstance</span>();</a>
<a class="sourceLine" id="cb17-4" title="4">    <span class="kw">try</span> {</a>
<a class="sourceLine" id="cb17-5" title="5">        eStartDate.<span class="fu">setTime</span>(sdf.<span class="fu">parse</span>(startDate));</a>
<a class="sourceLine" id="cb17-6" title="6">    }</a></code></pre>
    </div>
    <h3 id="exporting-constants">Exporting Constants</h3>
    <p>
      A native module can export constants by implementing the native method
      <code>getConstants()</code>, which is available in JS. Below you will
      implement <code>getConstants()</code> and return a Map that contains a
      <code>DEFAULT_EVENT_NAME</code> constant you can access in JavaScript:
    </p>
    <div class="sourceCode" id="cb18">
      <pre
        class="sourceCode java"
      ><code class="sourceCode java"><a class="sourceLine" id="cb18-1" title="1"><span class="at">@Override</span></a>
<a class="sourceLine" id="cb18-2" title="2"><span class="kw">public</span> <span class="bu">Map</span>&lt;<span class="bu">String</span>, <span class="bu">Object</span>&gt; <span class="fu">getConstants</span>() {</a>
<a class="sourceLine" id="cb18-3" title="3">   <span class="dt">final</span> <span class="bu">Map</span>&lt;<span class="bu">String</span>, <span class="bu">Object</span>&gt; constants = <span class="kw">new</span> <span class="bu">HashMap</span>&lt;&gt;();</a>
<a class="sourceLine" id="cb18-4" title="4">   constants.<span class="fu">put</span>(<span class="st">&quot;DEFAULT_EVENT_NAME&quot;</span>, <span class="st">&quot;New Event&quot;</span>);</a>
<a class="sourceLine" id="cb18-5" title="5">   <span class="kw">return</span> constants;</a>
<a class="sourceLine" id="cb18-6" title="6">}</a></code></pre>
    </div>
    <p>
      The constant can then be accessed by invoking <code>getConstants</code> on
      the native module in JS:
    </p>
    <pre
      class="jsx"
    ><code>const { DEFAULT_EVENT_NAME } = CalendarModule.getConstants();
console.log(DEFAULT_EVENT_NAME);</code></pre>
    <p>
      Technically it is possible to access constants exported in
      <code>getConstants()</code> directly off the native module object. This
      will no longer be supported with TurboModules, so we encourage the
      community to switch to the above approach to avoid necessary migration
      down the line.
    </p>
    <blockquote>
      <p>
        That currently constants are exported only at initialization time, so if
        you change getConstants values at runtime it won’t affect the JavaScript
        environment. This will change with Turbomodules. With Turbomodules,
        <code>getConstants()</code> will become a regular native module method,
        and each invocation will hit the native side.
      </p>
    </blockquote>
    <h3 id="callbacks">Callbacks</h3>
    <p>
      Native modules also support a unique kind of argument: a callback.
      Callbacks are used to pass data from Java to JavaScript for asynchronous
      methods. They can also be used to asynchronously execute JavaScript from
      the native side.
    </p>
    <p>
      In order to create a native module method with a callback, first import
      the <code>Callback</code> interface, and then add a new parameter to your
      native module method of type <code>Callback</code>. There are a couple of
      nuances with callback arguments that will soon be lifted with
      TurboModules. First off, you can only have two callbacks in your function
      arguments- a successCallback and a failureCallback. In addition, the last
      argument to a native module method call, if it’s a function, is treated as
      the successCallback, and the second to last argument to a native module
      method call, if it’s a function, is treated as the failure callback.
    </p>
    <div class="sourceCode" id="cb20">
      <pre
        class="sourceCode java"
      ><code class="sourceCode java"><a class="sourceLine" id="cb20-1" title="1"><span class="kw">import</span><span class="im"> com.facebook.react.bridge.Callback;</span></a>
<a class="sourceLine" id="cb20-2" title="2"></a>
<a class="sourceLine" id="cb20-3" title="3"><span class="at">@ReactMethod</span></a>
<a class="sourceLine" id="cb20-4" title="4"><span class="kw">public</span> <span class="dt">void</span> <span class="fu">createCalendarEvent</span>(<span class="bu">String</span> name, <span class="bu">String</span> location, <span class="bu">Callback</span> callBack) {</a>
<a class="sourceLine" id="cb20-5" title="5">}</a></code></pre>
    </div>
    <p>
      You can invoke the callback in your Java method, providing whatever data
      you want to pass to JavaScript. Please note that you can only pass
      serializable data from native code to JavaScript. If you need to pass back
      a native object you can use <code>WriteableMaps</code>, if you need to use
      a collection use <code>WritableArrays</code>. It is also important to
      highlight that the callback is not invoked immediately after the native
      function completes. Below the ID of an event created in an earlier call is
      passed to the callback.
    </p>
    <div class="sourceCode" id="cb21">
      <pre
        class="sourceCode java"
      ><code class="sourceCode java"><a class="sourceLine" id="cb21-1" title="1">  <span class="at">@ReactMethod</span></a>
<a class="sourceLine" id="cb21-2" title="2">   <span class="kw">public</span> <span class="dt">void</span> <span class="fu">createCalendarEvent</span>(<span class="bu">String</span> name, <span class="bu">String</span> location, <span class="bu">Callback</span> callBack) {</a>
<a class="sourceLine" id="cb21-3" title="3">       <span class="bu">Integer</span> eventId = ...</a>
<a class="sourceLine" id="cb21-4" title="4">       callback.<span class="fu">invoke</span>(eventId);</a>
<a class="sourceLine" id="cb21-5" title="5">   }</a></code></pre>
    </div>
    <p>This method could then be accessed in JavaScript using:</p>
    <pre class="jsx"><code>const onPress = () =&gt; {
  CalendarModule.createCalendarEvent(
    &#39;Party&#39;,
    &#39;My House&#39;,
    (eventId) =&gt; {
      console.log(`Created a new event with id ${eventId}`);
    }
  );
};</code></pre>
    <p>
      Another important detail to note is that a native module method can only
      invoke one callback, one time. This means that you can either call a
      success callback or a failure callback, but not both, and each callback
      can only be invoked at most one time. A native module can, however, store
      the callback and invoke it later.
    </p>
    <p>
      There are two approaches to error handling with callbacks. The first is to
      follow Node’s convention and treat the first argument passed to the
      callback as an error object.
    </p>
    <div class="sourceCode" id="cb23">
      <pre
        class="sourceCode java"
      ><code class="sourceCode java"><a class="sourceLine" id="cb23-1" title="1"><span class="at">@ReactMethod</span></a>
<a class="sourceLine" id="cb23-2" title="2"><span class="kw">public</span> <span class="dt">void</span> <span class="fu">createCalendarEvent</span>(<span class="bu">String</span> name, <span class="bu">String</span> location, <span class="bu">Callback</span> callBack) {</a>
<a class="sourceLine" id="cb23-3" title="3">    <span class="bu">Integer</span> eventId = ...</a>
<a class="sourceLine" id="cb23-4" title="4">    callBack.<span class="fu">invoke</span>(<span class="kw">null</span>, eventId);</a>
<a class="sourceLine" id="cb23-5" title="5">}</a></code></pre>
    </div>
    <p>
      In JavaScript, you can then check the first argument to see if an error
      was passed through:
    </p>
    <pre class="jsx"><code>const onPress = () =&gt; {
  CalendarModule.createCalendarEventCallback(
    &#39;testName&#39;,
    &#39;testLocation&#39;,
    (error, eventId) =&gt; {
      if (error) {
        console.error(`Error found! ${error}`);
      }
      console.log(`event id ${eventId} returned`);
    }
  );
};</code></pre>
    <p>Another option is to use an onSuccess and onFailure callback:</p>
    <div class="sourceCode" id="cb25">
      <pre
        class="sourceCode java"
      ><code class="sourceCode java"><a class="sourceLine" id="cb25-1" title="1"><span class="at">@ReactMethod</span></a>
<a class="sourceLine" id="cb25-2" title="2"><span class="kw">public</span> <span class="dt">void</span> <span class="fu">createCalendarEvent</span>(<span class="bu">String</span> name, <span class="bu">String</span> location, <span class="bu">Callback</span> myFailureCallback, <span class="bu">Callback</span> mySuccessCallback) {</a>
<a class="sourceLine" id="cb25-3" title="3">}</a></code></pre>
    </div>
    <p>
      Then in JavaScript you can add a separate callback for error and success
      responses:
    </p>
    <pre class="jsx"><code>const onPress = () =&gt; {
  CalendarModule.createCalendarEventCallback(
    &#39;testName&#39;,
    &#39;testLocation&#39;,
    (error) =&gt; {
      console.error(`Error found! ${error}`);
    },
    (eventId) =&gt; {
      console.log(`event id ${eventId} returned`);
    }
  );
};</code></pre>
    <h3 id="promises">Promises</h3>
    <p>
      Native modules can also fulfill a
      <a
        href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise"
        >Promise</a
      >, which can simplify your JavaScript, especially when using ES2016’s
      <a
        href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function"
        >async/await</a
      >
      syntax. When the last parameter of a native module Java method is a
      Promise, its corresponding JS method will return a JS Promise object.
    </p>
    <p>
      Refactoring the above code to use a promise instead of callbacks looks
      like this:
    </p>
    <div class="sourceCode" id="cb27">
      <pre
        class="sourceCode java"
      ><code class="sourceCode java"><a class="sourceLine" id="cb27-1" title="1"><span class="kw">import</span><span class="im"> com.facebook.react.bridge.Promise;</span></a>
<a class="sourceLine" id="cb27-2" title="2"></a>
<a class="sourceLine" id="cb27-3" title="3"><span class="at">@ReactMethod</span></a>
<a class="sourceLine" id="cb27-4" title="4"><span class="kw">public</span> <span class="dt">void</span> <span class="fu">createCalendarEvent</span>(<span class="bu">String</span> name, <span class="bu">String</span> location, Promise promise) {</a>
<a class="sourceLine" id="cb27-5" title="5">    <span class="kw">try</span> {</a>
<a class="sourceLine" id="cb27-6" title="6">        <span class="bu">Integer</span> eventId = ...</a>
<a class="sourceLine" id="cb27-7" title="7">        promise.<span class="fu">resolve</span>(eventId);</a>
<a class="sourceLine" id="cb27-8" title="8">    } <span class="kw">catch</span>(<span class="bu">Exception</span> e) {</a>
<a class="sourceLine" id="cb27-9" title="9">        promise.<span class="fu">reject</span>(<span class="st">&quot;Create Event Error&quot;</span>, e);</a>
<a class="sourceLine" id="cb27-10" title="10">    }</a>
<a class="sourceLine" id="cb27-11" title="11">}</a></code></pre>
    </div>
    <blockquote>
      <p>
        Similar to callbacks, a native module method can either reject or
        resolve a promise (but not both) and can do so at most once. This means
        that you can either call a success callback or a failure callback, but
        not both, and each callback can only be invoked at most one time. A
        native module can, however, store the callback and invoke it later.
      </p>
    </blockquote>
    <p>
      The JavaScript counterpart of this method returns a Promise. This means
      you can use the <code>await</code> keyword within an async function to
      call it and wait for its result:
    </p>
    <pre class="jsx"><code>const onSubmit = async () =&gt; {
  try {
    const eventId = await CalendarModule.createCalendarEvent(
      &#39;Party&#39;,
      &#39;My House&#39;
    );
    console.log(`Created a new event with id ${eventId}`);
  } catch (e) {
    console.error(e);
  }
};</code></pre>
    <p>
      The reject method takes different combinations of the following arguments:
    </p>
    <div class="sourceCode" id="cb29">
      <pre
        class="sourceCode java"
      ><code class="sourceCode java"><a class="sourceLine" id="cb29-1" title="1"><span class="bu">String</span> code, <span class="bu">String</span> message, WritableMap userInfo, <span class="bu">Throwable</span> throwable</a></code></pre>
    </div>
    <p>
      For more detail, you can find the <code>Promise.java</code> interface
      <a
        href="https://github.com/facebook/react-native/blob/master/ReactAndroid/src/main/java/com/facebook/react/bridge/Promise.java#L1"
        >here</a
      >. If <code>userInfo</code> is not provided, ReactNative will set it to
      null. For the rest of the parameters React Native will use a default
      value. The <code>message</code> argument provides the error
      <code>message</code> shown at the top of an error call stack. Below is an
      example of the error message shown in JavaScript from the following reject
      call in Java.
    </p>
    <p>Java reject call:</p>
    <div class="sourceCode" id="cb30">
      <pre
        class="sourceCode java"
      ><code class="sourceCode java"><a class="sourceLine" id="cb30-1" title="1">promise.<span class="fu">reject</span>(<span class="st">&quot;Create Event error&quot;</span>, <span class="st">&quot;Error parsing date&quot;</span>, e);</a></code></pre>
    </div>
    <p>Error message in React Native App when promise is rejected:</p>
    <figure>
      <img
        src="/docs/assets/native-modules-android-errorscreen.png"
        width="200"
        alt="Image of error message in React Native app."
      />
      <figcaption>Image of error message</figcaption>
    </figure>
    <h3 id="sending-events-to-javascript">Sending Events to JavaScript</h3>
    <p>
      Native modules can signal events to JavaScript without being invoked
      directly. For example, you might want to signal to JavaScript a reminder
      that a calendar event from the native Android calendar app will occur
      soon. The easiest way to do this is to use the
      <code>RCTDeviceEventEmitter</code> which can be obtained from the
      <code>ReactContext</code> as in the code snippet below.
    </p>
    <div class="sourceCode" id="cb31">
      <pre
        class="sourceCode java"
      ><code class="sourceCode java"><a class="sourceLine" id="cb31-1" title="1">...</a>
<a class="sourceLine" id="cb31-2" title="2"><span class="kw">import</span><span class="im"> com.facebook.react.modules.core.DeviceEventManagerModule;</span></a>
<a class="sourceLine" id="cb31-3" title="3"><span class="kw">import</span><span class="im"> com.facebook.react.bridge.WritableMap;</span></a>
<a class="sourceLine" id="cb31-4" title="4"><span class="kw">import</span><span class="im"> com.facebook.react.bridge.Arguments;</span></a>
<a class="sourceLine" id="cb31-5" title="5">...</a>
<a class="sourceLine" id="cb31-6" title="6"><span class="kw">private</span> <span class="dt">void</span> <span class="fu">sendEvent</span>(ReactContext reactContext,</a>
<a class="sourceLine" id="cb31-7" title="7">                      <span class="bu">String</span> eventName,</a>
<a class="sourceLine" id="cb31-8" title="8">                      <span class="at">@Nullable</span> WritableMap params) {</a>
<a class="sourceLine" id="cb31-9" title="9"> reactContext</a>
<a class="sourceLine" id="cb31-10" title="10">     .<span class="fu">getJSModule</span>(DeviceEventManagerModule.<span class="fu">RCTDeviceEventEmitter</span>.<span class="fu">class</span>)</a>
<a class="sourceLine" id="cb31-11" title="11">     .<span class="fu">emit</span>(eventName, params);</a>
<a class="sourceLine" id="cb31-12" title="12">}</a>
<a class="sourceLine" id="cb31-13" title="13">...</a>
<a class="sourceLine" id="cb31-14" title="14">WritableMap params = Arguments.<span class="fu">createMap</span>();</a>
<a class="sourceLine" id="cb31-15" title="15">params.<span class="fu">putString</span>(<span class="st">&quot;eventProperty&quot;</span>, <span class="st">&quot;someValue&quot;</span>);</a>
<a class="sourceLine" id="cb31-16" title="16">...</a>
<a class="sourceLine" id="cb31-17" title="17"><span class="fu">sendEvent</span>(reactContext, <span class="st">&quot;EventReminder&quot;</span>, params);</a></code></pre>
    </div>
    <p>
      JavaScript modules can then register to receive events by
      <code>addListener</code> on the
      <a
        href="https://github.com/facebook/react-native/blob/master/Libraries/EventEmitter/NativeEventEmitter.js"
        >NativeEventEmitter</a
      >
      class.
    </p>
    <pre
      class="jsx"
    ><code>import { NativeEventEmitter, NativeModules } from &#39;react-native&#39;;
...

 componentDidMount() {
   ...
   const eventEmitter = new NativeEventEmitter(NativeModules.ToastExample);
   this.eventListener = eventEmitter.addListener(&#39;EventReminder&#39;, (event) =&gt; {
      console.log(event.eventProperty) // &quot;someValue&quot;
   });
   ...
 }

 componentWillUnmount() {
   this.eventListener.remove(); //Removes the listener
 }</code></pre>
    <h3 id="getting-activity-result-from-startactivityforresult">
      Getting Activity Result from startActivityForResult
    </h3>
    <p>
      You’ll need to listen to <code>onActivityResult</code> if you want to get
      results from an activity you started with
      <code>startActivityForResult</code>. To do this, you must extend
      <code>BaseActivityEventListener</code> or implement
      <code>ActivityEventListener</code>. The former is preferred as it is more
      resilient to API changes. Then, you need to register the listener in the
      module’s constructor like so:
    </p>
    <div class="sourceCode" id="cb33">
      <pre
        class="sourceCode java"
      ><code class="sourceCode java"><a class="sourceLine" id="cb33-1" title="1">reactContext.<span class="fu">addActivityEventListener</span>(mActivityResultListener);</a></code></pre>
    </div>
    <p>
      Now you can listen to <code>onActivityResult</code> by implementing the
      following method:
    </p>
    <div class="sourceCode" id="cb34">
      <pre
        class="sourceCode java"
      ><code class="sourceCode java"><a class="sourceLine" id="cb34-1" title="1"><span class="at">@Override</span></a>
<a class="sourceLine" id="cb34-2" title="2"><span class="kw">public</span> <span class="dt">void</span> <span class="fu">onActivityResult</span>(</a>
<a class="sourceLine" id="cb34-3" title="3"> <span class="dt">final</span> Activity activity,</a>
<a class="sourceLine" id="cb34-4" title="4"> <span class="dt">final</span> <span class="dt">int</span> requestCode,</a>
<a class="sourceLine" id="cb34-5" title="5"> <span class="dt">final</span> <span class="dt">int</span> resultCode,</a>
<a class="sourceLine" id="cb34-6" title="6"> <span class="dt">final</span> Intent intent) {</a>
<a class="sourceLine" id="cb34-7" title="7"> <span class="co">// Your logic here</span></a>
<a class="sourceLine" id="cb34-8" title="8">}</a></code></pre>
    </div>
    <p>
      Let’s implement a basic image picker to demonstrate this. The image picker
      will expose the method <code>pickImage</code> to JavaScript, which will
      return the path of the image when called.
    </p>
    <pre
      class="jsx"
    ><code>public class ImagePickerModule extends ReactContextBaseJavaModule {

  private static final int IMAGE_PICKER_REQUEST = 1;
  private static final String E_ACTIVITY_DOES_NOT_EXIST = &quot;E_ACTIVITY_DOES_NOT_EXIST&quot;;
  private static final String E_PICKER_CANCELLED = &quot;E_PICKER_CANCELLED&quot;;
  private static final String E_FAILED_TO_SHOW_PICKER = &quot;E_FAILED_TO_SHOW_PICKER&quot;;
  private static final String E_NO_IMAGE_DATA_FOUND = &quot;E_NO_IMAGE_DATA_FOUND&quot;;

  private Promise mPickerPromise;

  private final ActivityEventListener mActivityEventListener = new BaseActivityEventListener() {

    @Override
    public void onActivityResult(Activity activity, int requestCode, int resultCode, Intent intent) {
      if (requestCode == IMAGE_PICKER_REQUEST) {
        if (mPickerPromise != null) {
          if (resultCode == Activity.RESULT_CANCELED) {
            mPickerPromise.reject(E_PICKER_CANCELLED, &quot;Image picker was cancelled&quot;);
          } else if (resultCode == Activity.RESULT_OK) {
            Uri uri = intent.getData();

            if (uri == null) {
              mPickerPromise.reject(E_NO_IMAGE_DATA_FOUND, &quot;No image data found&quot;);
            } else {
              mPickerPromise.resolve(uri.toString());
            }
          }

          mPickerPromise = null;
        }
      }
    }
  };

  ImagePickerModule(ReactApplicationContext reactContext) {
    super(reactContext);

    // Add the listener for `onActivityResult`
    reactContext.addActivityEventListener(mActivityEventListener);
  }

  @Override
  public String getName() {
    return &quot;ImagePickerModule&quot;;
  }

  @ReactMethod
  public void pickImage(final Promise promise) {
    Activity currentActivity = getCurrentActivity();

    if (currentActivity == null) {
      promise.reject(E_ACTIVITY_DOES_NOT_EXIST, &quot;Activity doesn&#39;t exist&quot;);
      return;
    }

    // Store the promise to resolve/reject when picker returns data
    mPickerPromise = promise;

    try {
      final Intent galleryIntent = new Intent(Intent.ACTION_PICK);

      galleryIntent.setType(&quot;image/*&quot;);

      final Intent chooserIntent = Intent.createChooser(galleryIntent, &quot;Pick an image&quot;);

      currentActivity.startActivityForResult(chooserIntent, IMAGE_PICKER_REQUEST);
    } catch (Exception e) {
      mPickerPromise.reject(E_FAILED_TO_SHOW_PICKER, e);
      mPickerPromise = null;
    }
  }
}</code></pre>
    <h3 id="listening-to-lifecycle-events">Listening to Lifecycle Events</h3>
    <p>
      Listening to the activity’s LifeCycle events such as
      <code>onResume</code>, <code>onPause</code> etc. is very similar to how
      <code>ActivityEventListener</code> was implemented. The module must
      implement <code>LifecycleEventListener</code>. Then, you need to register
      a listener in the module’s constructor like so:
    </p>
    <pre
      class="jsx"
    ><code>reactContext.addLifecycleEventListener(this);</code></pre>
    <p>
      Now you can listen to the activity’s LifeCycle events by implementing the
      following methods:
    </p>
    <pre class="jsx"><code>@Override
public void onHostResume() {
   // Activity `onResume`
}
@Override
public void onHostPause() {
   // Activity `onPause`
}
@Override
public void onHostDestroy() {
   // Activity `onDestroy`
}</code></pre>
    <h3 id="threading">Threading</h3>
    <p>
      To date, on Android, all native module async methods execute on one
      thread. Native modules should not have any assumptions about what thread
      they are being called on, as the current assignment is subject to change
      in the future. If a blocking call is required, the heavy work should be
      dispatched to an internally managed worker thread, and any callbacks
      distributed from there.
    </p>
  </body>
</html>
