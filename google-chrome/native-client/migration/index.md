---json {"title":"WebAssembly Migration Guide"} ---

<span id="migration"></span>

(P)NaCl Deprecation Announcements
---------------------------------

Given the momentum of cross-browser WebAssembly support, we plan to focus our native code efforts on WebAssembly going forward and plan to remove support for PNaCl in Q4 2019 (except for Chrome Apps). We believe that the vibrant ecosystem around <a href="http://webassembly.org" class="reference external">WebAssembly</a> makes it a better fit for new and existing high-performance web apps and that usage of PNaCl is sufficiently low to warrant deprecation.

As of Chrome 76, PNaCl on the open web has been moved behind an <a href="https://github.com/GoogleChrome/OriginTrials/blob/gh-pages/developer-guide.md" class="reference external">Origin Trial</a>, which is a mechanism for web developers to register and get access to a feature that isn’t on by default. This is usually a new proposed feature but in this case it’s a feature being deprecated. A developer can register on the <a href="/origintrials/#/view_trial/3553340105995321345" class="reference external">Origin Trial Console</a> and receive a token, which can be embedded into a page and will enable the feature without the user needing to use a flag. (For more details see the linked guide). The trial is scheduled to last through Chrome 78, approximately until December 2019. This change is not intended to affect NaCl or PNaCl in Chrome Apps or extensions, and the “enable-nacl” flag in chrome://flags can also be used to enable PNaCl locally for testing (this flag also retains its current function of enabling non-PNaCl “native” NaCl on any page).

We also recently announced the deprecation Q1 2018 of <a href="https://blog.chromium.org/2016/08/from-chrome-apps-to-web.html" class="reference external">Chrome Apps</a> outside of Chrome OS.

Toolchain Migration
-------------------

For the majority of (P)NaCl uses cases we recommend transitioning from the NaCl SDK to <a href="http://webassembly.org/getting-started/developers-guide/" class="reference external">Emscripten</a>. Migration is likely to be reasonably straightforward if your application is portable to Linux, uses <a href="https://www.libsdl.org/" class="reference external">SDL</a>, or POSIX APIs. While direct support for NaCl / Pepper APIs in not available, we’ve attempted to list Web API equivalents. For more challenging porting cases, please reach out on <a href="mailto:native-client-discuss%40googlegroups.com" class="reference external">native-client-discuss<span>@</span>googlegroups<span>.</span>com</a>

API Migration
-------------

We’ve outlined here the status of Web Platform substitutes for each of the APIs exposed to (P)NaCl. Additionally, the table lists the library or option in Emscripten that offers the closest substitute.

We expect to add shared memory threads support to WebAssembly in 2017, as threads are crucial to matching (P)NaCl’s most interesting use cases. Migration items which assume forthcoming threads support are marked below. If your application’s flow control relies heavily on blocking APIs, you may also find threads support is required for convenient porting.

While we’ve tried to be accurate in this table, there are no doubt errors or omissions. If you encounter one, please reach out to us on <a href="mailto:native-client-discuss%40googlegroups.com" class="reference external">native-client-discuss<span>@</span>googlegroups<span>.</span>com</a>

PPAPI
-----

### PPB\_Audio

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>Create</td><td style="text-align: center;">x</td><td>SDL (partial)</td><td>GAP (partial) - AudioWorkletNode ROUGHLY equivalent</td><td>The AudioWorkletSpec is done, but AudioDeviceClient may be a better fit for this API. The AudioDeviceClient is still being specified by the community. The worklet may not be the rough equivalent for this API.</td></tr><tr class="odd"><td>GetCurrentConfig</td><td style="text-align: center;"></td><td>SDL</td><td>AudioContext.* (gets back settings passed in)</td><td></td></tr><tr class="even"><td>StartPlayback</td><td style="text-align: center;"></td><td>SDL</td><td>AudioBufferSourceNode.start</td><td></td></tr><tr class="odd"><td>StopPlayback</td><td style="text-align: center;"></td><td>SDL</td><td>AudioBufferSourceNode.stop</td><td></td></tr></tbody></table>

### PPB\_AudioBuffer

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>GetTimestamp</td><td style="text-align: center;"></td><td>SDL</td><td>AudioBufferSourceNode.start (parameter)</td><td>Passed in each time instead of attached to the buffer.</td></tr><tr class="odd"><td>SetTimestamp</td><td style="text-align: center;"></td><td>SDL</td><td>AudioBufferSourceNode.start (parameter)</td><td></td></tr><tr class="even"><td>GetSampleRate</td><td style="text-align: center;"></td><td>SDL</td><td>AudioBuffer.sampleRate</td><td></td></tr><tr class="odd"><td>GetSampleSize</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - WebAudio only uses 32-bit float, PPAPI does 16-bit int.</td><td>PPAPI theoretically supports multiple sampling sizes. In practice, it only supports 16-bit samples. Unfortunately, developers have requested 16-bit sample sizes to save on memory use. The next version of the Web Audio spec will implement support for 16-bit samples. An optimization for AudioBuffer could be implemented similar to Firefox by using 16-bit buffer for audio that comes from decodeAudioData</td></tr><tr class="even"><td>GetNumberOfChannels</td><td style="text-align: center;"></td><td>SDL</td><td>AudioBuffer.numberOfChannels</td><td></td></tr><tr class="odd"><td>GetDataBuffer</td><td style="text-align: center;"></td><td>SDL</td><td>AudioBuffer.getChannelData</td><td></td></tr><tr class="even"><td>GetBufferSize</td><td style="text-align: center;"></td><td>SDL</td><td>AudioBuffer.length</td><td></td></tr></tbody></table>

### PPB\_AudioConfig

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>CreateStereo16Bit</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - Only 32-bit float samples supported</td><td>The next version of the Web Audio spec will implement support for 16-bit samples.</td></tr><tr class="odd"><td>GetSampleRate</td><td style="text-align: center;"></td><td>SDL</td><td>AudioContext.sampleRate</td><td></td></tr><tr class="even"><td>GetSampleFrameCount</td><td style="text-align: center;"></td><td>SDL</td><td>AudioBuffer.length</td><td></td></tr><tr class="odd"><td>RecommendSampleRate</td><td style="text-align: center;"></td><td>SDL</td><td>AudioContext.sampleRate (from default construct)</td><td>An AudioContext will have the preferred sampling rate that matchs the actual sample rate of the hardware audio device by default.</td></tr><tr class="even"><td>RecommendSampleFrameCount</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - Would be handled with the planned AudioDeviceClient</td><td>There is an open issue to allow a user-specified size, but that is still being defined. This is probably best handled with AudioDeviceClient which can tell you what the appropriate size would be for the given hardware.</td></tr></tbody></table>

### PPB\_Console

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>Log</td><td style="text-align: center;"></td><td>utime</td><td>console.log/warn/error/...</td><td></td></tr><tr class="odd"><td>LogWithSource</td><td style="text-align: center;"></td><td>GAP</td><td>GAP</td><td>The Console API is regarded as a sufficiently complete replacement, unless there are specific use cases raised by developers for the functionality provided by LogWithSource. DevTools Source Maps can be used to debug transpiled JavaScript in their original source language.</td></tr></tbody></table>

### PPB\_Core

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>getTime</td><td style="text-align: center;"></td><td>utime</td><td>new Date().getTime()</td><td></td></tr><tr class="odd"><td>getTimeTicks</td><td style="text-align: center;"></td><td>utime</td><td>new Date().getTime()</td><td></td></tr><tr class="even"><td>IsMainThread</td><td style="text-align: center;"></td><td>GAP</td><td>window.document !== undefined</td><td></td></tr><tr class="odd"><td>CallOnMainThread</td><td style="text-align: center;"></td><td>GAP</td><td>Worker.postMessage + Atomics.wait</td><td>Equivalent synchronization can be built.</td></tr></tbody></table>

### PPB\_FileIO

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>Create</td><td style="text-align: center;"></td><td>FS (partial)</td><td>window.chooseFileSystemEntries()</td><td>Create and open are used differently, but the pieces are of equal power.</td></tr><tr class="odd"><td>Open</td><td style="text-align: center;"></td><td>FS (partial)</td><td>window.chooseFileSystemEntries()</td><td></td></tr><tr class="even"><td>Query</td><td style="text-align: center;"></td><td>FS (partial)</td><td>Blob.size, FileSystemHandle.getFile(), FileSystemHandle.getDirectory(), File.lastModified</td><td>GAP (partial) - Blob.type can also be used to check the MIME type. The file system type, creation time, and last access time can not be determined with the Native File System API.</td></tr><tr class="odd"><td>Touch</td><td style="text-align: center;"></td><td>FS (partial)</td><td>FileSystemDirectoryHandle.getFile("name", {create: true})</td><td></td></tr><tr class="even"><td>Read</td><td style="text-align: center;"></td><td>FS (partial)</td><td>Blob.slice().arrayBuffer()</td><td></td></tr><tr class="odd"><td>Write</td><td style="text-align: center;"></td><td>FS (partial)</td><td>FileSystemWriter.write()</td><td></td></tr><tr class="even"><td>SetLength</td><td style="text-align: center;"></td><td>FS (partial)</td><td>FileSystemWriter.truncate()</td><td></td></tr><tr class="odd"><td>Flush</td><td style="text-align: center;"></td><td>GAP (partial)</td><td>GAP (partial) - Files are flushed when FileSystemWrite.close() is called</td><td>This is intended by design because the Native File System API files are exposed to the OS, therefore a Safe Browsing check needs to be performed before data is shown to the OS.</td></tr><tr class="even"><td>Close</td><td style="text-align: center;"></td><td>FS (partial)</td><td>FileSystemWriter.close()</td><td>Does not cancel pending operations, but flushes any data written so far to disk.</td></tr><tr class="odd"><td>ReadToArray</td><td style="text-align: center;"></td><td>GAP</td><td>Blob.slice().arrayBuffer() or Blob.arrayBuffer()</td><td>Allows multiple subrange reads in parallel.</td></tr></tbody></table>

### PPB\_FileRef

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>Create</td><td style="text-align: center;"></td><td>FS (partial)</td><td>FileSystemDirectoryHandle.getFile("name", {create: true})</td><td></td></tr><tr class="odd"><td>GetFileSystemType</td><td style="text-align: center;"></td><td>FS (partial)</td><td>FileSystem.type</td><td></td></tr><tr class="even"><td>GetName</td><td style="text-align: center;"></td><td>FS (partial)</td><td>File.name</td><td></td></tr><tr class="odd"><td>GetPath</td><td style="text-align: center;"></td><td>FS (partial)</td><td>GAP (partial) - With the Native File System API, the relative path of a file can be determined from reference to a directory that contains the file using FileSystemHandle.resolve(FileSystemHandle)</td><td>The absolute path of a file cannot be determined, and the user has to grant permission to access the directory containing the file.</td></tr><tr class="even"><td>GetParent</td><td style="text-align: center;"></td><td>FS (partial)</td><td>GAP (partial) - With the Native File System API, the relative path of a file can be determined from reference to a directory that contains the file using FileSystemHandle.resolve(FileSystemHandle)</td><td>The user has to grant permission to access the directory containing the file.</td></tr><tr class="odd"><td>MakeDirectory</td><td style="text-align: center;"></td><td>FS (partial)</td><td>FileSystemHandle.getDirectory(..., {createIfNotExists: true})</td><td></td></tr><tr class="even"><td>Touch</td><td style="text-align: center;"></td><td>FS (partial)</td><td>FileSystemDirectoryHandle.getFile("name", {create: true})</td><td>Modify time can be bumped by writing.</td></tr><tr class="odd"><td>Delete</td><td style="text-align: center;"></td><td>FS (partial)</td><td>FileSystemDirectoryHandle.removeEntry()</td><td>Unlike the PPAPI, directories do not have to be empty.</td></tr><tr class="even"><td>Rename</td><td style="text-align: center;"></td><td>FS (partial)</td><td>GAP (partial) - With the Native File System API, the file can be written with the new name using a combination of FileSystemFileHandle.getFile() for the new name and FileSystemFileHandle.createWriter().write() with the contents of the old file. Then FileSystemDirectoryHandle.removeEntry() to delete the old file.</td><td>There is not a direct API that will do this in one step in the Native File System API.</td></tr><tr class="odd"><td>Query</td><td style="text-align: center;"></td><td>GAP (partial)</td><td>Blob.size, FileSystemHandle.getFile(), FileSystemHandle.getDirectory(), File.lastModified</td><td>GAP (partial) - Blob.type can also be used to check the MIME type. The file system type, creation time, and last access time can not be determined with the Native File System API.</td></tr><tr class="even"><td>ReadDirectoryEntries</td><td style="text-align: center;"></td><td>FS (partial)</td><td>FileSystemDirectoryHandle.getEntries()</td><td></td></tr></tbody></table>

### PPB\_FileSystem

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>Create</td><td style="text-align: center;"></td><td>FS (partial)</td><td>window.requestFileSystem</td><td>JS API does both in one step</td></tr><tr class="odd"><td>Open</td><td style="text-align: center;"></td><td>GAP</td><td>window.requestFileSystem</td><td>JS API does both in one step</td></tr><tr class="even"><td>GetType</td><td style="text-align: center;"></td><td>GAP</td><td>FileSystem.type</td><td></td></tr></tbody></table>

### PPB\_Fullscreen

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>IsFullScreen</td><td style="text-align: center;"></td><td>html5.h</td><td>Document.fullscreenEnabled</td><td></td></tr><tr class="odd"><td>SetFullscreen</td><td style="text-align: center;"></td><td>html5.h</td><td>Document.requestFullscreen</td><td></td></tr><tr class="even"><td>GetScreenSize</td><td style="text-align: center;"></td><td>html5.h</td><td>Document.exitFullscreen</td><td></td></tr></tbody></table>

### PPB\_Gamepad

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>Sample</td><td style="text-align: center;"></td><td>SDL</td><td>Gamepad.*</td><td>The Gamepad object exposes a timestamp relative to navigationStart. It is updated when data is received from the hardware https://www.w3.org/TR/gamepad/#gamepad-interface</td></tr></tbody></table>

### PPB\_Graphics2D

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>Create</td><td style="text-align: center;"></td><td>SDL</td><td>Canvas.getContext('2d')</td><td></td></tr><tr class="odd"><td>Describe</td><td style="text-align: center;"></td><td>SDL</td><td>Canvas.clientWidth + Canvas.clientHeight</td><td></td></tr><tr class="even"><td>PaintImageData</td><td style="text-align: center;"></td><td>SDL</td><td>CanvasRenderingContext2D.putImageData</td><td></td></tr><tr class="odd"><td>Scroll</td><td style="text-align: center;"></td><td>GAP</td><td>CanvasRenderingContext2D.scrollIntoView, CanvasRenderingContext2D.drawImage</td><td>GAP (partial) - Can be implemented by drawing the canvas onto itself, with an offset, using drawImage, and then filling in the rest.</td></tr><tr class="even"><td>ReplaceContents</td><td style="text-align: center;"></td><td>SDL</td><td>CanvasRenderingContext2D.drawImage</td><td></td></tr><tr class="odd"><td>Flush</td><td style="text-align: center;"></td><td>GAP</td><td>No direct equivalent</td><td>GAP (partial) - There is always an implicit flush at the end of draw code; this is unlikely to change. However, the combination of <a href="https://html.spec.whatwg.org/multipage/canvas.html#the-offscreencanvas-interface">OffscreenCanvas</a> and <a href="https://html.spec.whatwg.org/multipage/canvas.html#the-imagebitmap-rendering-context">ImageBitmapRenderingContext</a> provide similar functionality.</td></tr><tr class="even"><td>SetScale</td><td style="text-align: center;"></td><td>SDL</td><td>CanvasRenderingContext2D.scale</td><td></td></tr><tr class="odd"><td>GetScale</td><td style="text-align: center;"></td><td>SDL</td><td>CanvasRenderingContext2D.currentTransform</td><td></td></tr><tr class="even"><td>SetLayerTransform</td><td style="text-align: center;"></td><td>SDL</td><td>CanvasRenderingContext2D.setTransform CanvasRenderingContext2D.scale CanvasRenderingContext2D.translate</td><td></td></tr></tbody></table>

### PPB\_Graphics3D

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>GetAttribMaxValue</td><td style="text-align: center;"></td><td>OpenGL ES 3.0</td><td>WebGL 2.0</td><td>GAP (partial) - WebGL 2.0 and Emscripten's exposure of OpenGL ES 3.0 support user-defined multisampled framebuffers, in which all of the parameters configurable via PPAPI can be set.</td></tr><tr class="odd"><td>Create</td><td style="text-align: center;"></td><td>SDL</td><td>Canvas.getContext</td><td></td></tr><tr class="even"><td>GetAttribs</td><td style="text-align: center;"></td><td>SDL</td><td>WebGLRenderingContext.getContextAttributes</td><td></td></tr><tr class="odd"><td>SetAttribs</td><td style="text-align: center;"></td><td>SDL</td><td>Canvas.getContext(.., OPTIONS)</td><td></td></tr><tr class="even"><td>GetError</td><td style="text-align: center;"></td><td>SDL</td><td>WebGLRenderingContext.getError</td><td></td></tr><tr class="odd"><td>ResizeBuffers</td><td style="text-align: center;"></td><td>SDL</td><td>Canvas.width = w; Canvas.height = h;</td><td></td></tr><tr class="even"><td>SwapBuffers</td><td style="text-align: center;"></td><td>GAP</td><td>No direct equivalent</td><td>GAP (partial) - There is always an implicit flush at the end of draw code; this is unlikely to change. However, the combination of <a href="https://html.spec.whatwg.org/multipage/canvas.html#the-offscreencanvas-interface">OffscreenCanvas</a> and <a href="https://html.spec.whatwg.org/multipage/canvas.html#the-imagebitmap-rendering-context">ImageBitmapRenderingContext</a> provide similar functionality.</td></tr></tbody></table>

### PPB\_ImageData

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>GetNativeImageDataFormat</td><td style="text-align: center;"></td><td>SDL</td><td>ImageData mandates RGBA order</td><td></td></tr><tr class="odd"><td>IsImageDataFormatSupported</td><td style="text-align: center;"></td><td>SDL</td><td>ImageData mandates RGBA order</td><td></td></tr><tr class="even"><td>Create</td><td style="text-align: center;"></td><td>SDL</td><td>CanvasRenderingContext2d.createImageData</td><td></td></tr><tr class="odd"><td>Describe</td><td style="text-align: center;"></td><td>SDL</td><td>ImageData never has a stride</td><td></td></tr><tr class="even"><td>Map</td><td style="text-align: center;"></td><td>SDL</td><td>ImageData.data</td><td></td></tr><tr class="odd"><td>Unmap</td><td style="text-align: center;"></td><td>SDL</td><td>ImageData.data</td><td></td></tr></tbody></table>

### PPB\_InputEvent

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>RequestInputEvents</td><td style="text-align: center;"></td><td>SDL</td><td>No direct equivalent</td><td>The lack of this feature is probably less relevant as JS / Wasm runs on the main thread and can more cheaply filter events without incurring a cross process round-trip.</td></tr><tr class="odd"><td>RequestFilteringInputEvents</td><td style="text-align: center;"></td><td>SDL</td><td>mouse* key* wheel* touch* composition* Events</td><td></td></tr><tr class="even"><td></td><td style="text-align: center;"></td><td>SDL</td><td>Element.addEventListener</td><td></td></tr><tr class="odd"><td>ClearInputEventRequest</td><td style="text-align: center;"></td><td>SDL</td><td>Element.removeEventListener</td><td></td></tr><tr class="even"><td>GetType</td><td style="text-align: center;"></td><td>SDL</td><td>Event class descendants</td><td></td></tr><tr class="odd"><td>GetTimeStamp</td><td style="text-align: center;"></td><td>SDL</td><td>Event.timeStamp</td><td></td></tr><tr class="even"><td>GetModifiers</td><td style="text-align: center;"></td><td>SDL</td><td>*Event.altKey/shiftKey/metaKey/ctrlKey</td><td></td></tr></tbody></table>

### PPB\_MouseInputEvent

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>Create</td><td style="text-align: center;"></td><td>SDL</td><td>MouseEvent</td><td></td></tr><tr class="odd"><td>GetButton</td><td style="text-align: center;"></td><td>SDL</td><td>MouseEvent.button</td><td></td></tr><tr class="even"><td>GetPosition</td><td style="text-align: center;"></td><td>SDL</td><td>MouseEvent.client*/page*/offset*</td><td></td></tr><tr class="odd"><td>GetClickCount</td><td style="text-align: center;"></td><td>SDL</td><td>dblclick' vs 'mousedown' Events</td><td></td></tr><tr class="even"><td>GetMovement</td><td style="text-align: center;"></td><td>SDL</td><td>MouseEvent.movement*</td><td></td></tr></tbody></table>

### PPB\_WheelInputEvent

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>Create</td><td style="text-align: center;"></td><td>SDL</td><td>WheelEvent</td><td></td></tr><tr class="odd"><td>GetDelta</td><td style="text-align: center;"></td><td>SDL</td><td>WheelEvent.delta*</td><td></td></tr><tr class="even"><td>GetTicks</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - deltaMode kind of contains this info, but incompletely.</td><td>There is discussion on implementing a WheelEvent.deltaMode API: https://github.com/w3c/uievents/issues/181#issuecomment-537811017</td></tr><tr class="odd"><td>GetScrollByPage</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - deltaMode kind of contains this info, but incompletely.</td><td>There is discussion on implementing a WheelEvent.deltaMode API: https://github.com/w3c/uievents/issues/181#issuecomment-537811017</td></tr></tbody></table>

### PPB\_KeyboardInputEvent

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>Create</td><td style="text-align: center;"></td><td>SDL</td><td>KeyboardEvent</td><td></td></tr><tr class="odd"><td>GetKeyCode</td><td style="text-align: center;"></td><td>SDL</td><td>KeyboardEvent.keyCode</td><td></td></tr><tr class="even"><td>GetCharacterText</td><td style="text-align: center;"></td><td>SDL</td><td>KeyboardEvent.key</td><td></td></tr><tr class="odd"><td>GetCode</td><td style="text-align: center;"></td><td>SDL</td><td>KeyboardEvent.code</td><td></td></tr></tbody></table>

### PPB\_TouchInputEvent

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>Create</td><td style="text-align: center;"></td><td>SDL</td><td>TouchEvent</td><td></td></tr><tr class="odd"><td>AddTouchPoint</td><td style="text-align: center;"></td><td>SDL</td><td>TouchEvent.touches.push</td><td></td></tr><tr class="even"><td>GetTouchCount</td><td style="text-align: center;"></td><td>SDL</td><td>TouchEvent.touches.length</td><td></td></tr><tr class="odd"><td>GetTouchByIndex</td><td style="text-align: center;"></td><td>SDL</td><td>TouchEvent.touches[i]</td><td></td></tr><tr class="even"><td>GetTouchById</td><td style="text-align: center;"></td><td>SDL</td><td>Touch.indentifer (to figure this out yourself)</td><td></td></tr></tbody></table>

### PPB\_IMEInputEvent

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>Create</td><td style="text-align: center;"></td><td>GAP</td><td>CompositionEvent</td><td></td></tr><tr class="odd"><td>GetText</td><td style="text-align: center;"></td><td>GAP</td><td>CompositionEvent.data</td><td></td></tr><tr class="even"><td>GetSegmentNumber</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - No direct equivalent</td><td>This data can potentially be retrieved from CompositionEvent.data.</td></tr><tr class="odd"><td>GetSegmentOffset</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - No direct equivalent</td><td></td></tr><tr class="even"><td>GetTargetSegment</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - No direct equivalent</td><td></td></tr><tr class="odd"><td>GetSelection</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - No direct equivalent</td><td></td></tr></tbody></table>

### PPB\_Instance

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>BindGraphics</td><td style="text-align: center;"></td><td>SDL</td><td>Canvas.getContext (moot as binding is automatic).</td><td></td></tr><tr class="odd"><td>IsFullFrame</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - No equivalent to mime type handlers.</td><td>NaCl apps can be registered to handle a particular mime type and own the whole document.</td></tr><tr class="even"><td>DidCreate</td><td style="text-align: center;"></td><td>N/A</td><td>&lt;Element&gt;[key]</td><td>General DOM access lets you fish out tag attributes</td></tr><tr class="odd"><td>DidDestroy</td><td style="text-align: center;"></td><td>N/A</td><td>N/A</td><td>Not triggered for NaCl</td></tr><tr class="even"><td>DidChangeView</td><td style="text-align: center;"></td><td>N/A</td><td>Element 'resize' Event</td><td></td></tr><tr class="odd"><td>DidChangeFocus</td><td style="text-align: center;"></td><td>N/A</td><td>Element 'focus', 'focusin', 'focusout' Events</td><td></td></tr><tr class="even"><td>HandleDocumentLoad</td><td style="text-align: center;"></td><td>N/A</td><td>GAP - No way to register as a mime type handler</td><td>NaCl modules via apps + a manifest entry can be set up to handle particular mime types.</td></tr></tbody></table>

### PPB\_MediaStreamAudioTrack

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>Configure</td><td style="text-align: center;"></td><td>GAP</td><td>getUserMedia()</td><td>The constraints from getUserMedia() can provide the configuration values to use in MediaStreamTrack.</td></tr><tr class="odd"><td>GetAttrib</td><td style="text-align: center;"></td><td>GAP</td><td>MediaStreamTrack.getSettings()</td><td></td></tr><tr class="even"><td>GetId</td><td style="text-align: center;"></td><td>GAP</td><td>MediaStreamTrack.id</td><td></td></tr><tr class="odd"><td>HasEnded</td><td style="text-align: center;"></td><td>GAP</td><td>MediaStreamTrack.readyState</td><td></td></tr><tr class="even"><td>GetBuffer</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - No equivalent</td><td></td></tr><tr class="odd"><td>RecycleBuffer</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - No equivalent</td><td></td></tr><tr class="even"><td>Close</td><td style="text-align: center;"></td><td>GAP</td><td>MediaStreamTrack.stop()</td><td></td></tr></tbody></table>

### PPB\_MediaStreamVideoTrack

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>Create</td><td style="text-align: center;"></td><td>GAP</td><td>Canvas Capture</td><td>Canvas Capture provides the ability to introduce video frames programatically.</td></tr><tr class="odd"><td>Configure</td><td style="text-align: center;"></td><td>GAP</td><td>applyConstraints(), getUserMedia()</td><td>GAP (partial) - The extent of configurations available in the Web API may differ from the PPAPI.</td></tr><tr class="even"><td>GetAttrib</td><td style="text-align: center;"></td><td>GAP</td><td>MediaStreamSettings.width</td><td></td></tr><tr class="odd"><td></td><td style="text-align: center;"></td><td>GAP</td><td>MediaStreamSettings.height</td><td></td></tr><tr class="even"><td></td><td style="text-align: center;"></td><td>GAP</td><td>GAP - no equivalent to PP_MEDIASTREAMVIDEOTRACK_ATTRIB_BUFFERED_FRAMES</td><td>MediaStream cannot be preloaded, so it will never buffer: https://www.w3.org/TR/mediacapture-streams/#mediastreams-in-media-elements</td></tr><tr class="odd"><td></td><td style="text-align: center;"></td><td>GAP</td><td>GAP - no equivalent to PP_MEDIASTREAMVIDEOTRACK_ATTRIB_FORMAT</td><td></td></tr><tr class="even"><td>GetId</td><td style="text-align: center;"></td><td>GAP</td><td>MediaStreamTrack.id</td><td></td></tr><tr class="odd"><td>HasEnded</td><td style="text-align: center;"></td><td>GAP</td><td>MediaStreamTrack.readyState</td><td></td></tr><tr class="even"><td>GetFrame</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - No equivalent</td><td></td></tr><tr class="odd"><td>RecycleFrame</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - No equivalent</td><td></td></tr><tr class="even"><td>Close</td><td style="text-align: center;"></td><td>GAP</td><td>MediaStreamTrack.stop()</td><td></td></tr><tr class="odd"><td>GetEmptyFrame</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - No equivalent</td><td></td></tr><tr class="even"><td>PutFrame</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - No equivalent</td><td></td></tr></tbody></table>

### PPB\_MessageLoop

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>Create</td><td style="text-align: center;"></td><td>N/A</td><td>Mostly moot, workers get an implicit event loop.</td><td></td></tr><tr class="odd"><td>GetForMainThread</td><td style="text-align: center;"></td><td>N/A</td><td>Mostly moot, workers get an implicit event loop.</td><td></td></tr><tr class="even"><td>GetCurrent</td><td style="text-align: center;"></td><td>N/A</td><td>Mostly moot, workers get an implicit event loop.</td><td></td></tr><tr class="odd"><td>AttachToCurrentThread</td><td style="text-align: center;"></td><td>N/A</td><td>Mostly moot, workers get an implicit event loop.</td><td></td></tr><tr class="even"><td>Run</td><td style="text-align: center;"></td><td>N/A</td><td>Mostly moot, workers get an implicit event loop.</td><td></td></tr><tr class="odd"><td>PostWork</td><td style="text-align: center;"></td><td>N/A</td><td>Mostly moot, workers get an implicit event loop.</td><td></td></tr><tr class="even"><td>PostQuit</td><td style="text-align: center;"></td><td>N/A</td><td>Mostly moot, workers get an implicit event loop.</td><td></td></tr></tbody></table>

### PPB\_Messaging

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>PostMessage</td><td style="text-align: center;"></td><td>N/A</td><td>Window.postMessage</td><td></td></tr><tr class="odd"><td>RegisterMessageHandler</td><td style="text-align: center;"></td><td>N/A</td><td>Window.addEventListener</td><td></td></tr><tr class="even"><td>UnregisterMessageHandler</td><td style="text-align: center;"></td><td>N/A</td><td>Window.removeEventListener</td><td></td></tr></tbody></table>

### PPB\_MouseCursor

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>SetCursor</td><td style="text-align: center;"></td><td>SDL</td><td>Element.style.cursor</td><td>Same set of stock cursors are supported. Custom cursors can be done with url(..). Dynamic custom cursors can be done with data URIs. CSS3 supports specifying the hotspot.</td></tr></tbody></table>

### PPB\_MouseLock

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>LockMouse</td><td style="text-align: center;"></td><td>SDL</td><td>Element.requestPointerLock</td><td></td></tr><tr class="odd"><td>UnlockMouse</td><td style="text-align: center;"></td><td>SDL</td><td>Element.exitPointerLock</td><td></td></tr></tbody></table>

### PPB\_OpenGLES2

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>Several Methods</td><td style="text-align: center;"></td><td>OpenGLES</td><td>Close to WebGL 1.0 in functionality.</td><td></td></tr><tr class="odd"><td></td><td style="text-align: center;">x</td><td></td><td>OffscreenCanvas</td><td></td></tr></tbody></table>

### PPB\_TextInputController

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>SetTextInputType</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - Potentially filled by Input Method Editor API</td><td>Some developers would like to either be able to hint in this fashion, or preferrably the ability to intercept and display IME events / output inline inside a canvas.</td></tr><tr class="odd"><td>UpdateCaretPosition</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - Potentially filled by Input Method Editor API</td><td>https://www.w3.org/TR/ime-api/</td></tr><tr class="even"><td>CancelCompositionText</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - Potentially filled by Input Method Editor API</td><td>https://www.w3.org/TR/ime-api/</td></tr><tr class="odd"><td>UpdateSurroundingText</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - Potentially filled by Input Method Editor API</td><td>https://www.w3.org/TR/ime-api/</td></tr></tbody></table>

### PPB\_URLLoader

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>Create</td><td style="text-align: center;"></td><td>embind</td><td>new XMLHttpRequest();</td><td></td></tr><tr class="odd"><td>Open</td><td style="text-align: center;"></td><td>embind</td><td>XMLHttpRequest.open</td><td></td></tr><tr class="even"><td>FollowRedirect</td><td style="text-align: center;"></td><td>embind</td><td>Request.redirect</td><td></td></tr><tr class="odd"><td></td><td style="text-align: center;"></td><td>GAP</td><td>GAP - No XMLHTTPRequest equivalent</td><td></td></tr><tr class="even"><td>GetUploadProgress</td><td style="text-align: center;"></td><td>embind</td><td>XMLHttpRequest 'progress' Event</td><td></td></tr><tr class="odd"><td></td><td style="text-align: center;"></td><td>GAP</td><td>FetchObserver</td><td>Not specced or implemented yet; https://github.com/whatwg/fetch/issues/607</td></tr><tr class="even"><td>GetDownloadProgress</td><td style="text-align: center;"></td><td>embind</td><td>XMLHttpRequest 'progress' Event</td><td></td></tr><tr class="odd"><td></td><td style="text-align: center;"></td><td>GAP</td><td>FetchObserver</td><td>Not specced or implemented yet; https://github.com/whatwg/fetch/issues/607</td></tr><tr class="even"><td>GetResponseInfo</td><td style="text-align: center;"></td><td>embind</td><td>XMLHttpRequest.getAllResponseHeaders</td><td></td></tr><tr class="odd"><td></td><td style="text-align: center;"></td><td>embind</td><td>Fetch Response.*</td><td></td></tr><tr class="even"><td>ReadResponseBody</td><td style="text-align: center;"></td><td>embind</td><td>XMLHttpRequest.response</td><td></td></tr><tr class="odd"><td></td><td style="text-align: center;"></td><td>embind</td><td>Body.* (Response is a Body)</td><td></td></tr><tr class="even"><td>FinishStreamingToFile</td><td style="text-align: center;"></td><td>embind</td><td>GAP - No direct equivalent</td><td>XMLHttpRequest and Fetch both assume streaming to memory, rather than directly to a storage.</td></tr><tr class="odd"><td>Close</td><td style="text-align: center;"></td><td>embind</td><td>XMLHttpRequest.abort</td><td></td></tr><tr class="even"><td></td><td style="text-align: center;"></td><td>GAP</td><td>Fetch API: AbortSignal and AbortController</td><td></td></tr></tbody></table>

### PPB\_URLRequestInfo

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>Create</td><td style="text-align: center;"></td><td>embind</td><td>XMLHttpRequest</td><td></td></tr><tr class="odd"><td></td><td style="text-align: center;"></td><td>embind</td><td>Fetch Request</td><td></td></tr><tr class="even"><td>SetProperty</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - No direct equivalent for XMLHttpRequest</td><td>XMLHttpRequest doesn't provide direct ways to per-request limit following redirects, stream to a file, set referrer or credentials policy.</td></tr><tr class="odd"><td></td><td style="text-align: center;"></td><td>embind</td><td>Request.*</td><td></td></tr><tr class="even"><td>AppendDataToBody</td><td style="text-align: center;"></td><td>embind</td><td>XMLHttpRequest.send</td><td>GAP - Both must have the whole body, rather than a chunk.</td></tr><tr class="odd"><td></td><td style="text-align: center;"></td><td>embind</td><td>fetch(.., options:body)</td><td></td></tr><tr class="even"><td>AppendFileToBody</td><td style="text-align: center;"></td><td>GAP</td><td>fetch() upload streaming</td><td>https://www.chromestatus.com/features/5274139738767360</td></tr><tr class="odd"><td></td><td style="text-align: center;"></td><td>N/A</td><td>&lt;form&gt;</td><td>You can also read with FileReader and upload, but that's more like AppendDataToBody</td></tr></tbody></table>

### PPB\_URLResponseInfo

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>GetProperty</td><td style="text-align: center;"></td><td>embind</td><td>XMLHttpRequest.getAllResponseHeaders + others</td><td></td></tr><tr class="odd"><td></td><td style="text-align: center;"></td><td>embind</td><td>Fetch Response.*</td><td></td></tr><tr class="even"><td>GetBodyAsFileRef</td><td style="text-align: center;"></td><td>embind</td><td>Fetch Response (Body) .blob()</td><td>Assumes storage layer optimizes transfer.</td></tr></tbody></table>

### PPB\_Var

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>VarFromUtf8</td><td style="text-align: center;"></td><td>embind</td><td>TextDecoder.decode</td><td></td></tr><tr class="odd"><td>VarToUtf8</td><td style="text-align: center;"></td><td>embind</td><td>TextEncoder.encode</td><td></td></tr><tr class="even"><td>VarFromResource</td><td style="text-align: center;"></td><td>N/A</td><td>N/A</td><td></td></tr><tr class="odd"><td>VarToResource</td><td style="text-align: center;"></td><td>N/A</td><td>N/A</td><td></td></tr></tbody></table>

### PPB\_VarArray

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>Get</td><td style="text-align: center;"></td><td>embind</td><td>Array[i]</td><td></td></tr><tr class="odd"><td>Set</td><td style="text-align: center;"></td><td>embind</td><td>Array[i] = x</td><td></td></tr><tr class="even"><td>GetLength</td><td style="text-align: center;"></td><td>embind</td><td>Array.length</td><td></td></tr><tr class="odd"><td>SetLength</td><td style="text-align: center;"></td><td>embind</td><td>Array.length = n</td><td></td></tr></tbody></table>

### PPB\_VarArrayBuffer

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>Create</td><td style="text-align: center;"></td><td>embind</td><td>new ArrayBuffer(n)</td><td></td></tr><tr class="odd"><td>ByteLength</td><td style="text-align: center;"></td><td>embind</td><td>ArrayBuffer.byteLength</td><td></td></tr><tr class="even"><td>Map</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - No direct equivalent</td><td>Asm.js / Wasm modules are unable to map regions of an ArrayBuffer other than their single linear memory heap. Future multiple memories or memory mapping might improve this.</td></tr><tr class="odd"><td>Unmap</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - No direct equivalent</td><td></td></tr></tbody></table>

### PPB\_VarDictionary

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>Create</td><td style="text-align: center;"></td><td>embind</td><td>{}</td><td></td></tr><tr class="odd"><td>Get</td><td style="text-align: center;"></td><td>embind</td><td>&lt;Object&gt;[i]</td><td></td></tr><tr class="even"><td>Set</td><td style="text-align: center;"></td><td>embind</td><td>&lt;Object&gt;[i] = x</td><td></td></tr><tr class="odd"><td>Delete</td><td style="text-align: center;"></td><td>embind</td><td>delete &lt;Object&gt;[i]</td><td></td></tr><tr class="even"><td>HasKey</td><td style="text-align: center;"></td><td>embind</td><td>x in &lt;Object&gt;</td><td></td></tr><tr class="odd"><td>GetKeys</td><td style="text-align: center;"></td><td>embind</td><td>for (k in &lt;Object&gt;) {}</td><td>No literal equivalent, but it can be built.</td></tr></tbody></table>

### PPB\_VideoDecoder

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>Create</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - Would be handled with the proposed WebCodecs API using VideoDecoder()</td><td>https://github.com/WICG/web-codecs/blob/master/explainer.md#example-of-decode-for-low-latency-live-streaming-or-cloud-gaming</td></tr><tr class="odd"><td>Initialize</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - Would be handled with the proposed WebCodecs API using VideoDecoder() initialization parameters (VideoDecoderInitParameters)</td><td>https://github.com/WICG/web-codecs/blob/master/explainer.md#example-of-decode-for-low-latency-live-streaming-or-cloud-gaming</td></tr><tr class="even"><td>Decode</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - Would be handled with the proposed WebCodecs API using ReadableStream.pipeThrough(VideoDecoder)</td><td>https://github.com/WICG/web-codecs/blob/master/explainer.md#example-of-decode-for-low-latency-live-streaming-or-cloud-gaming</td></tr><tr class="odd"><td>GetPicture</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - Would be handled with the proposed WebCodecs API using ReadableStream.pipeThrough(VideoDecoder).pipeTo(VideoTrackWriter().writable)</td><td>https://github.com/WICG/web-codecs/blob/master/explainer.md#example-of-decode-for-low-latency-live-streaming-or-cloud-gaming</td></tr><tr class="even"><td>RecyclePicture</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - Would be handled with the proposed WebCodecs API. The current design will automatically recycle the pictures and keep the decoding process going.</td><td>https://github.com/WICG/web-codecs/blob/master/explainer.md#example-of-decode-for-low-latency-live-streaming-or-cloud-gaming</td></tr><tr class="odd"><td>Flush</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - Would be handled with the proposed WebCodecs API. The API will be called Flush(), however there is still discussion on how it will be sequenced in relation to decode calls.</td><td>https://github.com/WICG/web-codecs/blob/master/explainer.md#example-of-decode-for-low-latency-live-streaming-or-cloud-gaming</td></tr><tr class="even"><td>Reset</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - Would be handled with the proposed WebCodecs API by destroying the VideoDecoder instance and creating a new one. This won't be as efficient as a dedicated reset method, but the semantics for a Reset() API is still being discussed.</td><td>https://github.com/WICG/web-codecs/blob/master/explainer.md#example-of-decode-for-low-latency-live-streaming-or-cloud-gaming</td></tr></tbody></table>

### PPB\_VideoEncoder

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>Create</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - Would be handled with the proposed WebCodecs API using VideoEncoder()</td><td></td></tr><tr class="odd"><td>GetSupportedProfiles</td><td style="text-align: center;"></td><td>GAP</td><td>GAP (partial) - navigator.mediaCapabilities.encodingInfo()</td><td>The supported profiles have to be checked one by one.</td></tr><tr class="even"><td>Initialize</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - Would be handled with the proposed WebCodecs API using VideoEncoder() initialization parameters</td><td></td></tr><tr class="odd"><td>GetFramesRequired</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - No equivalent</td><td>It is unlikely that the frame pool used internally by the Web Codecs API is exposed.</td></tr><tr class="even"><td>GetFrameCodedSize</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - No equivalent</td><td>It is unlikely that the frame pool used internally by the Web Codecs API is exposed.</td></tr><tr class="odd"><td>GetVideoFrame</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - Would be handled with the proposed WebCodecs API by using ReadableStream.pipeThrough(VideoEncoder). This would directly encode the data in the Readable stream instead of grabbing a single frame to fill with data before encoding.</td><td></td></tr><tr class="even"><td>Encode</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - Would be handled with the proposed WebCodecs API using ReadableStream.pipeThrough(VideoEncoder)</td><td></td></tr><tr class="odd"><td>GetBitstreamBuffer</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - Would be handled with the proposed WebCodecs API. The current design will automatically go through the encoded bitstream buffer that is piped through.</td><td>The WebCodecs API currently assumes that bitstream buffer can be copied rather than pooled, so it will not need to be recycled.</td></tr><tr class="even"><td>RecycleBitstreamBuffer</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - Would be handled with the proposed WebCodecs API. The current design will automatically recycle the buffer to keep the encoding process going.</td><td>This is unlikely to change in the future as performance implications are smaller.</td></tr><tr class="odd"><td>RequestEncodingParametersChange</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - Would be handled by the proposed Web Codecs API. Certain parameters will have the capability of being changed on the fly, while others will require the encoder to be torn down.</td><td></td></tr><tr class="even"><td>Close</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - Would be handled with the proposed WebCodecs API by using VideoEncoder.Close()</td><td></td></tr></tbody></table>

### PPB\_VideoFrame

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>GetTimestamp</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - Would be handled with the proposed WebCodecs API.</td><td></td></tr><tr class="odd"><td>SetTimestamp</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - Would be handled with the proposed WebCodecs API.</td><td></td></tr><tr class="even"><td>GetFormat</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - Would be handled with the proposed WebCodecs API.</td><td></td></tr><tr class="odd"><td>GetSize</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - Would be handled with the proposed WebCodecs API.</td><td></td></tr><tr class="even"><td>GetDataBuffer</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - Would be handled with the proposed WebCodecs API.</td><td></td></tr><tr class="odd"><td>GetDataBufferSize</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - Would be handled with the proposed WebCodecs API.</td><td></td></tr></tbody></table>

### PPB\_View

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>GetRect</td><td style="text-align: center;"></td><td>embind</td><td>Element.getBoundingClientRect</td><td></td></tr><tr class="odd"><td>IsFullscreen</td><td style="text-align: center;"></td><td>embind</td><td>Document.fullScreenEnabled</td><td>Pertains to document instead of just single element.</td></tr><tr class="even"><td>IsVisible</td><td style="text-align: center;"></td><td>embind</td><td>IntersectionObserver</td><td></td></tr><tr class="odd"><td>IsPageVisible</td><td style="text-align: center;"></td><td>embind</td><td>document.visibilityState</td><td></td></tr><tr class="even"><td>GetClipRect</td><td style="text-align: center;"></td><td>embind</td><td>IntersectionObserver</td><td></td></tr><tr class="odd"><td>GetDeviceScale</td><td style="text-align: center;"></td><td>embind</td><td>window.devicePixelRatio</td><td></td></tr><tr class="even"><td>GetCSSScale</td><td style="text-align: center;"></td><td>embind</td><td>&lt;Element&gt;.getBoundingClientRect().width / &lt;Element&gt;.offsetWidth</td><td></td></tr><tr class="odd"><td>GetScrollOffset</td><td style="text-align: center;"></td><td>embind</td><td>&lt;Element&gt;.scrollTop / &lt;Element&gt;.scrollLeft</td><td></td></tr></tbody></table>

### PPB\_WebSocket

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>Create</td><td style="text-align: center;"></td><td>GAP</td><td>WebSocket.WebSocket</td><td></td></tr><tr class="odd"><td>Connect</td><td style="text-align: center;"></td><td>GAP</td><td>WebSocket.WebSocket(url, ...) WebSocket 'open' Event</td><td></td></tr><tr class="even"><td>Close</td><td style="text-align: center;"></td><td>GAP</td><td>WebSocket.close</td><td></td></tr><tr class="odd"><td>ReceiveMessage</td><td style="text-align: center;"></td><td>GAP</td><td>WebSocket 'message' Event WebSocket 'error' Event WebSocket 'close' Event</td><td></td></tr><tr class="even"><td>SendMessage</td><td style="text-align: center;"></td><td>GAP</td><td>WebSocket.send</td><td></td></tr><tr class="odd"><td>GetBufferedAmount</td><td style="text-align: center;"></td><td>GAP</td><td>WebSocket.bufferedAmount</td><td></td></tr><tr class="even"><td>GetCloseCode</td><td style="text-align: center;"></td><td>GAP</td><td>CloseEvent.code</td><td></td></tr><tr class="odd"><td>GetCloseReason</td><td style="text-align: center;"></td><td>GAP</td><td>CloseEvent.reason</td><td></td></tr><tr class="even"><td>GetCloseWasClean</td><td style="text-align: center;"></td><td>GAP</td><td>CloseEvent.wasClean</td><td></td></tr><tr class="odd"><td>GetExtensions</td><td style="text-align: center;"></td><td>GAP</td><td>WebSocket.extensions</td><td></td></tr><tr class="even"><td>GetProtocol</td><td style="text-align: center;"></td><td>GAP</td><td>WebSocket.protocol</td><td></td></tr><tr class="odd"><td>GetReadyState</td><td style="text-align: center;"></td><td>GAP</td><td>WebSocket.readyState</td><td></td></tr><tr class="even"><td>GetURL</td><td style="text-align: center;"></td><td>GAP</td><td>WebSocket.url</td><td></td></tr></tbody></table>

### PPP\_Graphics3D

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>Graphics3DContextLost</td><td style="text-align: center;"></td><td>SDL</td><td>Canvas 'webglcontextlost' Event</td><td></td></tr></tbody></table>

### PPP\_InputEvent

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>HandleInputEvent</td><td style="text-align: center;"></td><td>SDL</td><td>Element.addEventListener</td><td></td></tr></tbody></table>

### PPP\_Instance

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>DidCreate</td><td style="text-align: center;"></td><td>N/A</td><td>&lt;Element&gt;[key]</td><td>General DOM access lets you fish out tag attributes</td></tr><tr class="odd"><td>DidDestroy</td><td style="text-align: center;"></td><td>N/A</td><td>N/A</td><td>Not triggered for NaCl</td></tr><tr class="even"><td>DidChangeView</td><td style="text-align: center;"></td><td>N/A</td><td>Element 'resize' Event</td><td></td></tr><tr class="odd"><td>DidChangeFocus</td><td style="text-align: center;"></td><td>N/A</td><td>Element 'focus', 'focusin', 'focusout' Events</td><td></td></tr><tr class="even"><td>HandleDocumentLoad</td><td style="text-align: center;"></td><td>N/A</td><td>GAP - No way to register as a mime type handler</td><td>NaCl Modules via apps + a manifest entry can be set up to handle particular mime types.</td></tr></tbody></table>

### PPP\_MessageHandler

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>HandleMessage</td><td style="text-align: center;"></td><td>embind</td><td>MessagePort 'message' Event Window 'message' Event</td><td></td></tr><tr class="odd"><td>HandleBlockingMessage</td><td style="text-align: center;"></td><td>N/A</td><td>GAP - No direct equivalent</td><td>Similar synchronization can be done off main thread with Atomics.wait. This was added to support emulation of synchronous plugin APIs.</td></tr></tbody></table>

### PPP\_Messaging

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>HandleMessage</td><td style="text-align: center;"></td><td>embind</td><td>MessagePort 'message' Event Window 'message' Event</td><td></td></tr></tbody></table>

### PPP\_MouseLock

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>MouseLockLost</td><td style="text-align: center;"></td><td>SDL</td><td>Element 'pointerlockchange', 'pointerlockerror' Events</td><td></td></tr></tbody></table>

IRT
---

### PPB\_Audio

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>Create</td><td style="text-align: center;">x</td><td>SDL (partial)</td><td>GAP (partial) - AudioWorkletNode ROUGHLY equivalent</td><td>The AudioWorkletSpec is done, but AudioDeviceClient may be a better fit for this API. The AudioDeviceClient is still being specified by the community. The worklet may not be the rough equivalent for this API.</td></tr><tr class="odd"><td>GetCurrentConfig</td><td style="text-align: center;"></td><td>SDL</td><td>AudioContext.* (gets back settings passed in)</td><td></td></tr><tr class="even"><td>StartPlayback</td><td style="text-align: center;"></td><td>SDL</td><td>AudioBufferSourceNode.start</td><td></td></tr><tr class="odd"><td>StopPlayback</td><td style="text-align: center;"></td><td>SDL</td><td>AudioBufferSourceNode.stop</td><td></td></tr></tbody></table>

### PPB\_AudioBuffer

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>GetTimestamp</td><td style="text-align: center;"></td><td>SDL</td><td>AudioBufferSourceNode.start (parameter)</td><td>Passed in each time instead of attached to the buffer.</td></tr><tr class="odd"><td>SetTimestamp</td><td style="text-align: center;"></td><td>SDL</td><td>AudioBufferSourceNode.start (parameter)</td><td></td></tr><tr class="even"><td>GetSampleRate</td><td style="text-align: center;"></td><td>SDL</td><td>AudioBuffer.sampleRate</td><td></td></tr><tr class="odd"><td>GetSampleSize</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - WebAudio only uses 32-bit float, PPAPI does 16-bit int.</td><td>PPAPI theoretically supports multiple sampling sizes. In practice, it only supports 16-bit samples. Unfortunately, developers have requested 16-bit sample sizes to save on memory use. The next version of the Web Audio spec will implement support for 16-bit samples. An optimization for AudioBuffer could be implemented similar to Firefox by using 16-bit buffer for audio that comes from decodeAudioData</td></tr><tr class="even"><td>GetNumberOfChannels</td><td style="text-align: center;"></td><td>SDL</td><td>AudioBuffer.numberOfChannels</td><td></td></tr><tr class="odd"><td>GetDataBuffer</td><td style="text-align: center;"></td><td>SDL</td><td>AudioBuffer.getChannelData</td><td></td></tr><tr class="even"><td>GetBufferSize</td><td style="text-align: center;"></td><td>SDL</td><td>AudioBuffer.length</td><td></td></tr></tbody></table>

### PPB\_AudioConfig

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>CreateStereo16Bit</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - Only 32-bit float samples supported</td><td>The next version of the Web Audio spec will implement support for 16-bit samples.</td></tr><tr class="odd"><td>GetSampleRate</td><td style="text-align: center;"></td><td>SDL</td><td>AudioContext.sampleRate</td><td></td></tr><tr class="even"><td>GetSampleFrameCount</td><td style="text-align: center;"></td><td>SDL</td><td>AudioBuffer.length</td><td></td></tr><tr class="odd"><td>RecommendSampleRate</td><td style="text-align: center;"></td><td>SDL</td><td>AudioContext.sampleRate (from default construct)</td><td>An AudioContext will have the preferred sampling rate that matchs the actual sample rate of the hardware audio device by default.</td></tr><tr class="even"><td>RecommendSampleFrameCount</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - Would be handled with the planned AudioDeviceClient</td><td>There is an open issue to allow a user-specified size, but that is still being defined. This is probably best handled with AudioDeviceClient which can tell you what the appropriate size would be for the given hardware.</td></tr></tbody></table>

### PPB\_Console

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>Log</td><td style="text-align: center;"></td><td>utime</td><td>console.log/warn/error/...</td><td></td></tr><tr class="odd"><td>LogWithSource</td><td style="text-align: center;"></td><td>GAP</td><td>GAP</td><td>The Console API is regarded as a sufficiently complete replacement, unless there are specific use cases raised by developers for the functionality provided by LogWithSource. DevTools Source Maps can be used to debug transpiled JavaScript in their original source language.</td></tr></tbody></table>

### PPB\_Core

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>getTime</td><td style="text-align: center;"></td><td>utime</td><td>new Date().getTime()</td><td></td></tr><tr class="odd"><td>getTimeTicks</td><td style="text-align: center;"></td><td>utime</td><td>new Date().getTime()</td><td></td></tr><tr class="even"><td>IsMainThread</td><td style="text-align: center;"></td><td>GAP</td><td>window.document !== undefined</td><td></td></tr><tr class="odd"><td>CallOnMainThread</td><td style="text-align: center;"></td><td>GAP</td><td>Worker.postMessage + Atomics.wait</td><td>Equivalent synchronization can be built.</td></tr></tbody></table>

### PPB\_FileIO

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>Create</td><td style="text-align: center;"></td><td>FS (partial)</td><td>window.chooseFileSystemEntries()</td><td>Create and open are used differently, but the pieces are of equal power.</td></tr><tr class="odd"><td>Open</td><td style="text-align: center;"></td><td>FS (partial)</td><td>window.chooseFileSystemEntries()</td><td></td></tr><tr class="even"><td>Query</td><td style="text-align: center;"></td><td>FS (partial)</td><td>Blob.size, FileSystemHandle.getFile(), FileSystemHandle.getDirectory(), File.lastModified</td><td>GAP (partial) - Blob.type can also be used to check the MIME type. The file system type, creation time, and last access time can not be determined with the Native File System API.</td></tr><tr class="odd"><td>Touch</td><td style="text-align: center;"></td><td>FS (partial)</td><td>FileSystemDirectoryHandle.getFile("name", {create: true})</td><td></td></tr><tr class="even"><td>Read</td><td style="text-align: center;"></td><td>FS (partial)</td><td>Blob.slice().arrayBuffer()</td><td></td></tr><tr class="odd"><td>Write</td><td style="text-align: center;"></td><td>FS (partial)</td><td>FileSystemWriter.write()</td><td></td></tr><tr class="even"><td>SetLength</td><td style="text-align: center;"></td><td>FS (partial)</td><td>FileSystemWriter.truncate()</td><td></td></tr><tr class="odd"><td>Flush</td><td style="text-align: center;"></td><td>GAP (partial)</td><td>GAP (partial) - Files are flushed when FileSystemWrite.close() is called</td><td>This is intended by design because the Native File System API files are exposed to the OS, therefore a Safe Browsing check needs to be performed before data is shown to the OS.</td></tr><tr class="even"><td>Close</td><td style="text-align: center;"></td><td>FS (partial)</td><td>FileSystemWriter.close()</td><td>Does not cancel pending operations, but flushes any data written so far to disk.</td></tr><tr class="odd"><td>ReadToArray</td><td style="text-align: center;"></td><td>GAP</td><td>Blob.slice().arrayBuffer() or Blob.arrayBuffer()</td><td>Allows multiple subrange reads in parallel.</td></tr></tbody></table>

### PPB\_FileRef

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>Create</td><td style="text-align: center;"></td><td>FS (partial)</td><td>FileSystemDirectoryHandle.getFile("name", {create: true})</td><td></td></tr><tr class="odd"><td>GetFileSystemType</td><td style="text-align: center;"></td><td>FS (partial)</td><td>FileSystem.type</td><td></td></tr><tr class="even"><td>GetName</td><td style="text-align: center;"></td><td>FS (partial)</td><td>File.name</td><td></td></tr><tr class="odd"><td>GetPath</td><td style="text-align: center;"></td><td>FS (partial)</td><td>GAP (partial) - With the Native File System API, the relative path of a file can be determined from reference to a directory that contains the file using FileSystemHandle.resolve(FileSystemHandle)</td><td>The absolute path of a file cannot be determined, and the user has to grant permission to access the directory containing the file.</td></tr><tr class="even"><td>GetParent</td><td style="text-align: center;"></td><td>FS (partial)</td><td>GAP (partial) - With the Native File System API, the relative path of a file can be determined from reference to a directory that contains the file using FileSystemHandle.resolve(FileSystemHandle)</td><td>The user has to grant permission to access the directory containing the file.</td></tr><tr class="odd"><td>MakeDirectory</td><td style="text-align: center;"></td><td>FS (partial)</td><td>FileSystemHandle.getDirectory(..., {createIfNotExists: true})</td><td></td></tr><tr class="even"><td>Touch</td><td style="text-align: center;"></td><td>FS (partial)</td><td>FileSystemDirectoryHandle.getFile("name", {create: true})</td><td>Modify time can be bumped by writing.</td></tr><tr class="odd"><td>Delete</td><td style="text-align: center;"></td><td>FS (partial)</td><td>FileSystemDirectoryHandle.removeEntry()</td><td>Unlike the PPAPI, directories do not have to be empty.</td></tr><tr class="even"><td>Rename</td><td style="text-align: center;"></td><td>FS (partial)</td><td>GAP (partial) - With the Native File System API, the file can be written with the new name using a combination of FileSystemFileHandle.getFile() for the new name and FileSystemFileHandle.createWriter().write() with the contents of the old file. Then FileSystemDirectoryHandle.removeEntry() to delete the old file.</td><td>There is not a direct API that will do this in one step in the Native File System API.</td></tr><tr class="odd"><td>Query</td><td style="text-align: center;"></td><td>GAP (partial)</td><td>Blob.size, FileSystemHandle.getFile(), FileSystemHandle.getDirectory(), File.lastModified</td><td>GAP (partial) - Blob.type can also be used to check the MIME type. The file system type, creation time, and last access time can not be determined with the Native File System API.</td></tr><tr class="even"><td>ReadDirectoryEntries</td><td style="text-align: center;"></td><td>FS (partial)</td><td>FileSystemDirectoryHandle.getEntries()</td><td></td></tr></tbody></table>

### PPB\_FileSystem

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>Create</td><td style="text-align: center;"></td><td>FS (partial)</td><td>window.requestFileSystem</td><td>JS API does both in one step</td></tr><tr class="odd"><td>Open</td><td style="text-align: center;"></td><td>GAP</td><td>window.requestFileSystem</td><td>JS API does both in one step</td></tr><tr class="even"><td>GetType</td><td style="text-align: center;"></td><td>GAP</td><td>FileSystem.type</td><td></td></tr></tbody></table>

### PPB\_Fullscreen

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>IsFullScreen</td><td style="text-align: center;"></td><td>html5.h</td><td>Document.fullscreenEnabled</td><td></td></tr><tr class="odd"><td>SetFullscreen</td><td style="text-align: center;"></td><td>html5.h</td><td>Document.requestFullscreen</td><td></td></tr><tr class="even"><td>GetScreenSize</td><td style="text-align: center;"></td><td>html5.h</td><td>Document.exitFullscreen</td><td></td></tr></tbody></table>

### PPB\_Gamepad

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>Sample</td><td style="text-align: center;"></td><td>SDL</td><td>Gamepad.*</td><td>The Gamepad object exposes a timestamp relative to navigationStart. It is updated when data is received from the hardware https://www.w3.org/TR/gamepad/#gamepad-interface</td></tr></tbody></table>

### PPB\_Graphics2D

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>Create</td><td style="text-align: center;"></td><td>SDL</td><td>Canvas.getContext('2d')</td><td></td></tr><tr class="odd"><td>Describe</td><td style="text-align: center;"></td><td>SDL</td><td>Canvas.clientWidth + Canvas.clientHeight</td><td></td></tr><tr class="even"><td>PaintImageData</td><td style="text-align: center;"></td><td>SDL</td><td>CanvasRenderingContext2D.putImageData</td><td></td></tr><tr class="odd"><td>Scroll</td><td style="text-align: center;"></td><td>GAP</td><td>CanvasRenderingContext2D.scrollIntoView, CanvasRenderingContext2D.drawImage</td><td>GAP (partial) - Can be implemented by drawing the canvas onto itself, with an offset, using drawImage, and then filling in the rest.</td></tr><tr class="even"><td>ReplaceContents</td><td style="text-align: center;"></td><td>SDL</td><td>CanvasRenderingContext2D.drawImage</td><td></td></tr><tr class="odd"><td>Flush</td><td style="text-align: center;"></td><td>GAP</td><td>No direct equivalent</td><td>GAP (partial) - There is always an implicit flush at the end of draw code; this is unlikely to change. However, the combination of <a href="https://html.spec.whatwg.org/multipage/canvas.html#the-offscreencanvas-interface">OffscreenCanvas</a> and <a href="https://html.spec.whatwg.org/multipage/canvas.html#the-imagebitmap-rendering-context">ImageBitmapRenderingContext</a> provide similar functionality.</td></tr><tr class="even"><td>SetScale</td><td style="text-align: center;"></td><td>SDL</td><td>CanvasRenderingContext2D.scale</td><td></td></tr><tr class="odd"><td>GetScale</td><td style="text-align: center;"></td><td>SDL</td><td>CanvasRenderingContext2D.currentTransform</td><td></td></tr><tr class="even"><td>SetLayerTransform</td><td style="text-align: center;"></td><td>SDL</td><td>CanvasRenderingContext2D.setTransform CanvasRenderingContext2D.scale CanvasRenderingContext2D.translate</td><td></td></tr></tbody></table>

### PPB\_Graphics3D

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>GetAttribMaxValue</td><td style="text-align: center;"></td><td>OpenGL ES 3.0</td><td>WebGL 2.0</td><td>GAP (partial) - WebGL 2.0 and Emscripten's exposure of OpenGL ES 3.0 support user-defined multisampled framebuffers, in which all of the parameters configurable via PPAPI can be set.</td></tr><tr class="odd"><td>Create</td><td style="text-align: center;"></td><td>SDL</td><td>Canvas.getContext</td><td></td></tr><tr class="even"><td>GetAttribs</td><td style="text-align: center;"></td><td>SDL</td><td>WebGLRenderingContext.getContextAttributes</td><td></td></tr><tr class="odd"><td>SetAttribs</td><td style="text-align: center;"></td><td>SDL</td><td>Canvas.getContext(.., OPTIONS)</td><td></td></tr><tr class="even"><td>GetError</td><td style="text-align: center;"></td><td>SDL</td><td>WebGLRenderingContext.getError</td><td></td></tr><tr class="odd"><td>ResizeBuffers</td><td style="text-align: center;"></td><td>SDL</td><td>Canvas.width = w; Canvas.height = h;</td><td></td></tr><tr class="even"><td>SwapBuffers</td><td style="text-align: center;"></td><td>GAP</td><td>No direct equivalent</td><td>GAP (partial) - There is always an implicit flush at the end of draw code; this is unlikely to change. However, the combination of <a href="https://html.spec.whatwg.org/multipage/canvas.html#the-offscreencanvas-interface">OffscreenCanvas</a> and <a href="https://html.spec.whatwg.org/multipage/canvas.html#the-imagebitmap-rendering-context">ImageBitmapRenderingContext</a> provide similar functionality.</td></tr></tbody></table>

### PPB\_ImageData

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>GetNativeImageDataFormat</td><td style="text-align: center;"></td><td>SDL</td><td>ImageData mandates RGBA order</td><td></td></tr><tr class="odd"><td>IsImageDataFormatSupported</td><td style="text-align: center;"></td><td>SDL</td><td>ImageData mandates RGBA order</td><td></td></tr><tr class="even"><td>Create</td><td style="text-align: center;"></td><td>SDL</td><td>CanvasRenderingContext2d.createImageData</td><td></td></tr><tr class="odd"><td>Describe</td><td style="text-align: center;"></td><td>SDL</td><td>ImageData never has a stride</td><td></td></tr><tr class="even"><td>Map</td><td style="text-align: center;"></td><td>SDL</td><td>ImageData.data</td><td></td></tr><tr class="odd"><td>Unmap</td><td style="text-align: center;"></td><td>SDL</td><td>ImageData.data</td><td></td></tr></tbody></table>

### PPB\_InputEvent

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>RequestInputEvents</td><td style="text-align: center;"></td><td>SDL</td><td>No direct equivalent</td><td>The lack of this feature is probably less relevant as JS / Wasm runs on the main thread and can more cheaply filter events without incurring a cross process round-trip.</td></tr><tr class="odd"><td>RequestFilteringInputEvents</td><td style="text-align: center;"></td><td>SDL</td><td>mouse* key* wheel* touch* composition* Events</td><td></td></tr><tr class="even"><td></td><td style="text-align: center;"></td><td>SDL</td><td>Element.addEventListener</td><td></td></tr><tr class="odd"><td>ClearInputEventRequest</td><td style="text-align: center;"></td><td>SDL</td><td>Element.removeEventListener</td><td></td></tr><tr class="even"><td>GetType</td><td style="text-align: center;"></td><td>SDL</td><td>Event class descendants</td><td></td></tr><tr class="odd"><td>GetTimeStamp</td><td style="text-align: center;"></td><td>SDL</td><td>Event.timeStamp</td><td></td></tr><tr class="even"><td>GetModifiers</td><td style="text-align: center;"></td><td>SDL</td><td>*Event.altKey/shiftKey/metaKey/ctrlKey</td><td></td></tr></tbody></table>

### PPB\_MouseInputEvent

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>Create</td><td style="text-align: center;"></td><td>SDL</td><td>MouseEvent</td><td></td></tr><tr class="odd"><td>GetButton</td><td style="text-align: center;"></td><td>SDL</td><td>MouseEvent.button</td><td></td></tr><tr class="even"><td>GetPosition</td><td style="text-align: center;"></td><td>SDL</td><td>MouseEvent.client*/page*/offset*</td><td></td></tr><tr class="odd"><td>GetClickCount</td><td style="text-align: center;"></td><td>SDL</td><td>dblclick' vs 'mousedown' Events</td><td></td></tr><tr class="even"><td>GetMovement</td><td style="text-align: center;"></td><td>SDL</td><td>MouseEvent.movement*</td><td></td></tr></tbody></table>

### PPB\_WheelInputEvent

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>Create</td><td style="text-align: center;"></td><td>SDL</td><td>WheelEvent</td><td></td></tr><tr class="odd"><td>GetDelta</td><td style="text-align: center;"></td><td>SDL</td><td>WheelEvent.delta*</td><td></td></tr><tr class="even"><td>GetTicks</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - deltaMode kind of contains this info, but incompletely.</td><td>There is discussion on implementing a WheelEvent.deltaMode API: https://github.com/w3c/uievents/issues/181#issuecomment-537811017</td></tr><tr class="odd"><td>GetScrollByPage</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - deltaMode kind of contains this info, but incompletely.</td><td>There is discussion on implementing a WheelEvent.deltaMode API: https://github.com/w3c/uievents/issues/181#issuecomment-537811017</td></tr></tbody></table>

### PPB\_KeyboardInputEvent

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>Create</td><td style="text-align: center;"></td><td>SDL</td><td>KeyboardEvent</td><td></td></tr><tr class="odd"><td>GetKeyCode</td><td style="text-align: center;"></td><td>SDL</td><td>KeyboardEvent.keyCode</td><td></td></tr><tr class="even"><td>GetCharacterText</td><td style="text-align: center;"></td><td>SDL</td><td>KeyboardEvent.key</td><td></td></tr><tr class="odd"><td>GetCode</td><td style="text-align: center;"></td><td>SDL</td><td>KeyboardEvent.code</td><td></td></tr></tbody></table>

### PPB\_TouchInputEvent

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>Create</td><td style="text-align: center;"></td><td>SDL</td><td>TouchEvent</td><td></td></tr><tr class="odd"><td>AddTouchPoint</td><td style="text-align: center;"></td><td>SDL</td><td>TouchEvent.touches.push</td><td></td></tr><tr class="even"><td>GetTouchCount</td><td style="text-align: center;"></td><td>SDL</td><td>TouchEvent.touches.length</td><td></td></tr><tr class="odd"><td>GetTouchByIndex</td><td style="text-align: center;"></td><td>SDL</td><td>TouchEvent.touches[i]</td><td></td></tr><tr class="even"><td>GetTouchById</td><td style="text-align: center;"></td><td>SDL</td><td>Touch.indentifer (to figure this out yourself)</td><td></td></tr></tbody></table>

### PPB\_IMEInputEvent

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>Create</td><td style="text-align: center;"></td><td>GAP</td><td>CompositionEvent</td><td></td></tr><tr class="odd"><td>GetText</td><td style="text-align: center;"></td><td>GAP</td><td>CompositionEvent.data</td><td></td></tr><tr class="even"><td>GetSegmentNumber</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - No direct equivalent</td><td>This data can potentially be retrieved from CompositionEvent.data.</td></tr><tr class="odd"><td>GetSegmentOffset</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - No direct equivalent</td><td></td></tr><tr class="even"><td>GetTargetSegment</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - No direct equivalent</td><td></td></tr><tr class="odd"><td>GetSelection</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - No direct equivalent</td><td></td></tr></tbody></table>

### PPB\_Instance

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>BindGraphics</td><td style="text-align: center;"></td><td>SDL</td><td>Canvas.getContext (moot as binding is automatic).</td><td></td></tr><tr class="odd"><td>IsFullFrame</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - No equivalent to mime type handlers.</td><td>NaCl apps can be registered to handle a particular mime type and own the whole document.</td></tr><tr class="even"><td>DidCreate</td><td style="text-align: center;"></td><td>N/A</td><td>&lt;Element&gt;[key]</td><td>General DOM access lets you fish out tag attributes</td></tr><tr class="odd"><td>DidDestroy</td><td style="text-align: center;"></td><td>N/A</td><td>N/A</td><td>Not triggered for NaCl</td></tr><tr class="even"><td>DidChangeView</td><td style="text-align: center;"></td><td>N/A</td><td>Element 'resize' Event</td><td></td></tr><tr class="odd"><td>DidChangeFocus</td><td style="text-align: center;"></td><td>N/A</td><td>Element 'focus', 'focusin', 'focusout' Events</td><td></td></tr><tr class="even"><td>HandleDocumentLoad</td><td style="text-align: center;"></td><td>N/A</td><td>GAP - No way to register as a mime type handler</td><td>NaCl modules via apps + a manifest entry can be set up to handle particular mime types.</td></tr></tbody></table>

### PPB\_MediaStreamAudioTrack

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>Configure</td><td style="text-align: center;"></td><td>GAP</td><td>getUserMedia()</td><td>The constraints from getUserMedia() can provide the configuration values to use in MediaStreamTrack.</td></tr><tr class="odd"><td>GetAttrib</td><td style="text-align: center;"></td><td>GAP</td><td>MediaStreamTrack.getSettings()</td><td></td></tr><tr class="even"><td>GetId</td><td style="text-align: center;"></td><td>GAP</td><td>MediaStreamTrack.id</td><td></td></tr><tr class="odd"><td>HasEnded</td><td style="text-align: center;"></td><td>GAP</td><td>MediaStreamTrack.readyState</td><td></td></tr><tr class="even"><td>GetBuffer</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - No equivalent</td><td></td></tr><tr class="odd"><td>RecycleBuffer</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - No equivalent</td><td></td></tr><tr class="even"><td>Close</td><td style="text-align: center;"></td><td>GAP</td><td>MediaStreamTrack.stop()</td><td></td></tr></tbody></table>

### PPB\_MediaStreamVideoTrack

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>Create</td><td style="text-align: center;"></td><td>GAP</td><td>Canvas Capture</td><td>Canvas Capture provides the ability to introduce video frames programatically.</td></tr><tr class="odd"><td>Configure</td><td style="text-align: center;"></td><td>GAP</td><td>applyConstraints(), getUserMedia()</td><td>GAP (partial) - The extent of configurations available in the Web API may differ from the PPAPI.</td></tr><tr class="even"><td>GetAttrib</td><td style="text-align: center;"></td><td>GAP</td><td>MediaStreamSettings.width</td><td></td></tr><tr class="odd"><td></td><td style="text-align: center;"></td><td>GAP</td><td>MediaStreamSettings.height</td><td></td></tr><tr class="even"><td></td><td style="text-align: center;"></td><td>GAP</td><td>GAP - no equivalent to PP_MEDIASTREAMVIDEOTRACK_ATTRIB_BUFFERED_FRAMES</td><td>MediaStream cannot be preloaded, so it will never buffer: https://www.w3.org/TR/mediacapture-streams/#mediastreams-in-media-elements</td></tr><tr class="odd"><td></td><td style="text-align: center;"></td><td>GAP</td><td>GAP - no equivalent to PP_MEDIASTREAMVIDEOTRACK_ATTRIB_FORMAT</td><td></td></tr><tr class="even"><td>GetId</td><td style="text-align: center;"></td><td>GAP</td><td>MediaStreamTrack.id</td><td></td></tr><tr class="odd"><td>HasEnded</td><td style="text-align: center;"></td><td>GAP</td><td>MediaStreamTrack.readyState</td><td></td></tr><tr class="even"><td>GetFrame</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - No equivalent</td><td></td></tr><tr class="odd"><td>RecycleFrame</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - No equivalent</td><td></td></tr><tr class="even"><td>Close</td><td style="text-align: center;"></td><td>GAP</td><td>MediaStreamTrack.stop()</td><td></td></tr><tr class="odd"><td>GetEmptyFrame</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - No equivalent</td><td></td></tr><tr class="even"><td>PutFrame</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - No equivalent</td><td></td></tr></tbody></table>

### PPB\_MessageLoop

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>Create</td><td style="text-align: center;"></td><td>N/A</td><td>Mostly moot, workers get an implicit event loop.</td><td></td></tr><tr class="odd"><td>GetForMainThread</td><td style="text-align: center;"></td><td>N/A</td><td>Mostly moot, workers get an implicit event loop.</td><td></td></tr><tr class="even"><td>GetCurrent</td><td style="text-align: center;"></td><td>N/A</td><td>Mostly moot, workers get an implicit event loop.</td><td></td></tr><tr class="odd"><td>AttachToCurrentThread</td><td style="text-align: center;"></td><td>N/A</td><td>Mostly moot, workers get an implicit event loop.</td><td></td></tr><tr class="even"><td>Run</td><td style="text-align: center;"></td><td>N/A</td><td>Mostly moot, workers get an implicit event loop.</td><td></td></tr><tr class="odd"><td>PostWork</td><td style="text-align: center;"></td><td>N/A</td><td>Mostly moot, workers get an implicit event loop.</td><td></td></tr><tr class="even"><td>PostQuit</td><td style="text-align: center;"></td><td>N/A</td><td>Mostly moot, workers get an implicit event loop.</td><td></td></tr></tbody></table>

### PPB\_Messaging

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>PostMessage</td><td style="text-align: center;"></td><td>N/A</td><td>Window.postMessage</td><td></td></tr><tr class="odd"><td>RegisterMessageHandler</td><td style="text-align: center;"></td><td>N/A</td><td>Window.addEventListener</td><td></td></tr><tr class="even"><td>UnregisterMessageHandler</td><td style="text-align: center;"></td><td>N/A</td><td>Window.removeEventListener</td><td></td></tr></tbody></table>

### PPB\_MouseCursor

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>SetCursor</td><td style="text-align: center;"></td><td>SDL</td><td>Element.style.cursor</td><td>Same set of stock cursors are supported. Custom cursors can be done with url(..). Dynamic custom cursors can be done with data URIs. CSS3 supports specifying the hotspot.</td></tr></tbody></table>

### PPB\_MouseLock

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>LockMouse</td><td style="text-align: center;"></td><td>SDL</td><td>Element.requestPointerLock</td><td></td></tr><tr class="odd"><td>UnlockMouse</td><td style="text-align: center;"></td><td>SDL</td><td>Element.exitPointerLock</td><td></td></tr></tbody></table>

### PPB\_OpenGLES2

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>Several Methods</td><td style="text-align: center;"></td><td>OpenGLES</td><td>Close to WebGL 1.0 in functionality.</td><td></td></tr><tr class="odd"><td></td><td style="text-align: center;">x</td><td></td><td>OffscreenCanvas</td><td></td></tr></tbody></table>

### PPB\_TextInputController

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>SetTextInputType</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - Potentially filled by Input Method Editor API</td><td>Some developers would like to either be able to hint in this fashion, or preferrably the ability to intercept and display IME events / output inline inside a canvas.</td></tr><tr class="odd"><td>UpdateCaretPosition</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - Potentially filled by Input Method Editor API</td><td>https://www.w3.org/TR/ime-api/</td></tr><tr class="even"><td>CancelCompositionText</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - Potentially filled by Input Method Editor API</td><td>https://www.w3.org/TR/ime-api/</td></tr><tr class="odd"><td>UpdateSurroundingText</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - Potentially filled by Input Method Editor API</td><td>https://www.w3.org/TR/ime-api/</td></tr></tbody></table>

### PPB\_URLLoader

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>Create</td><td style="text-align: center;"></td><td>embind</td><td>new XMLHttpRequest();</td><td></td></tr><tr class="odd"><td>Open</td><td style="text-align: center;"></td><td>embind</td><td>XMLHttpRequest.open</td><td></td></tr><tr class="even"><td>FollowRedirect</td><td style="text-align: center;"></td><td>embind</td><td>Request.redirect</td><td></td></tr><tr class="odd"><td></td><td style="text-align: center;"></td><td>GAP</td><td>GAP - No XMLHTTPRequest equivalent</td><td></td></tr><tr class="even"><td>GetUploadProgress</td><td style="text-align: center;"></td><td>embind</td><td>XMLHttpRequest 'progress' Event</td><td></td></tr><tr class="odd"><td></td><td style="text-align: center;"></td><td>GAP</td><td>FetchObserver</td><td>Not specced or implemented yet; https://github.com/whatwg/fetch/issues/607</td></tr><tr class="even"><td>GetDownloadProgress</td><td style="text-align: center;"></td><td>embind</td><td>XMLHttpRequest 'progress' Event</td><td></td></tr><tr class="odd"><td></td><td style="text-align: center;"></td><td>GAP</td><td>FetchObserver</td><td>Not specced or implemented yet; https://github.com/whatwg/fetch/issues/607</td></tr><tr class="even"><td>GetResponseInfo</td><td style="text-align: center;"></td><td>embind</td><td>XMLHttpRequest.getAllResponseHeaders</td><td></td></tr><tr class="odd"><td></td><td style="text-align: center;"></td><td>embind</td><td>Fetch Response.*</td><td></td></tr><tr class="even"><td>ReadResponseBody</td><td style="text-align: center;"></td><td>embind</td><td>XMLHttpRequest.response</td><td></td></tr><tr class="odd"><td></td><td style="text-align: center;"></td><td>embind</td><td>Body.* (Response is a Body)</td><td></td></tr><tr class="even"><td>FinishStreamingToFile</td><td style="text-align: center;"></td><td>embind</td><td>GAP - No direct equivalent</td><td>XMLHttpRequest and Fetch both assume streaming to memory, rather than directly to a storage.</td></tr><tr class="odd"><td>Close</td><td style="text-align: center;"></td><td>embind</td><td>XMLHttpRequest.abort</td><td></td></tr><tr class="even"><td></td><td style="text-align: center;"></td><td>GAP</td><td>Fetch API: AbortSignal and AbortController</td><td></td></tr></tbody></table>

### PPB\_URLRequestInfo

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>Create</td><td style="text-align: center;"></td><td>embind</td><td>XMLHttpRequest</td><td></td></tr><tr class="odd"><td></td><td style="text-align: center;"></td><td>embind</td><td>Fetch Request</td><td></td></tr><tr class="even"><td>SetProperty</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - No direct equivalent for XMLHttpRequest</td><td>XMLHttpRequest doesn't provide direct ways to per-request limit following redirects, stream to a file, set referrer or credentials policy.</td></tr><tr class="odd"><td></td><td style="text-align: center;"></td><td>embind</td><td>Request.*</td><td></td></tr><tr class="even"><td>AppendDataToBody</td><td style="text-align: center;"></td><td>embind</td><td>XMLHttpRequest.send</td><td>GAP - Both must have the whole body, rather than a chunk.</td></tr><tr class="odd"><td></td><td style="text-align: center;"></td><td>embind</td><td>fetch(.., options:body)</td><td></td></tr><tr class="even"><td>AppendFileToBody</td><td style="text-align: center;"></td><td>GAP</td><td>fetch() upload streaming</td><td>https://www.chromestatus.com/features/5274139738767360</td></tr><tr class="odd"><td></td><td style="text-align: center;"></td><td>N/A</td><td>&lt;form&gt;</td><td>You can also read with FileReader and upload, but that's more like AppendDataToBody</td></tr></tbody></table>

### PPB\_URLResponseInfo

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>GetProperty</td><td style="text-align: center;"></td><td>embind</td><td>XMLHttpRequest.getAllResponseHeaders + others</td><td></td></tr><tr class="odd"><td></td><td style="text-align: center;"></td><td>embind</td><td>Fetch Response.*</td><td></td></tr><tr class="even"><td>GetBodyAsFileRef</td><td style="text-align: center;"></td><td>embind</td><td>Fetch Response (Body) .blob()</td><td>Assumes storage layer optimizes transfer.</td></tr></tbody></table>

### PPB\_Var

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>VarFromUtf8</td><td style="text-align: center;"></td><td>embind</td><td>TextDecoder.decode</td><td></td></tr><tr class="odd"><td>VarToUtf8</td><td style="text-align: center;"></td><td>embind</td><td>TextEncoder.encode</td><td></td></tr><tr class="even"><td>VarFromResource</td><td style="text-align: center;"></td><td>N/A</td><td>N/A</td><td></td></tr><tr class="odd"><td>VarToResource</td><td style="text-align: center;"></td><td>N/A</td><td>N/A</td><td></td></tr></tbody></table>

### PPB\_VarArray

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>Get</td><td style="text-align: center;"></td><td>embind</td><td>Array[i]</td><td></td></tr><tr class="odd"><td>Set</td><td style="text-align: center;"></td><td>embind</td><td>Array[i] = x</td><td></td></tr><tr class="even"><td>GetLength</td><td style="text-align: center;"></td><td>embind</td><td>Array.length</td><td></td></tr><tr class="odd"><td>SetLength</td><td style="text-align: center;"></td><td>embind</td><td>Array.length = n</td><td></td></tr></tbody></table>

### PPB\_VarArrayBuffer

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>Create</td><td style="text-align: center;"></td><td>embind</td><td>new ArrayBuffer(n)</td><td></td></tr><tr class="odd"><td>ByteLength</td><td style="text-align: center;"></td><td>embind</td><td>ArrayBuffer.byteLength</td><td></td></tr><tr class="even"><td>Map</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - No direct equivalent</td><td>Asm.js / Wasm modules are unable to map regions of an ArrayBuffer other than their single linear memory heap. Future multiple memories or memory mapping might improve this.</td></tr><tr class="odd"><td>Unmap</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - No direct equivalent</td><td></td></tr></tbody></table>

### PPB\_VarDictionary

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>Create</td><td style="text-align: center;"></td><td>embind</td><td>{}</td><td></td></tr><tr class="odd"><td>Get</td><td style="text-align: center;"></td><td>embind</td><td>&lt;Object&gt;[i]</td><td></td></tr><tr class="even"><td>Set</td><td style="text-align: center;"></td><td>embind</td><td>&lt;Object&gt;[i] = x</td><td></td></tr><tr class="odd"><td>Delete</td><td style="text-align: center;"></td><td>embind</td><td>delete &lt;Object&gt;[i]</td><td></td></tr><tr class="even"><td>HasKey</td><td style="text-align: center;"></td><td>embind</td><td>x in &lt;Object&gt;</td><td></td></tr><tr class="odd"><td>GetKeys</td><td style="text-align: center;"></td><td>embind</td><td>for (k in &lt;Object&gt;) {}</td><td>No literal equivalent, but it can be built.</td></tr></tbody></table>

### PPB\_VideoDecoder

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>Create</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - Would be handled with the proposed WebCodecs API using VideoDecoder()</td><td>https://github.com/WICG/web-codecs/blob/master/explainer.md#example-of-decode-for-low-latency-live-streaming-or-cloud-gaming</td></tr><tr class="odd"><td>Initialize</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - Would be handled with the proposed WebCodecs API using VideoDecoder() initialization parameters (VideoDecoderInitParameters)</td><td>https://github.com/WICG/web-codecs/blob/master/explainer.md#example-of-decode-for-low-latency-live-streaming-or-cloud-gaming</td></tr><tr class="even"><td>Decode</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - Would be handled with the proposed WebCodecs API using ReadableStream.pipeThrough(VideoDecoder)</td><td>https://github.com/WICG/web-codecs/blob/master/explainer.md#example-of-decode-for-low-latency-live-streaming-or-cloud-gaming</td></tr><tr class="odd"><td>GetPicture</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - Would be handled with the proposed WebCodecs API using ReadableStream.pipeThrough(VideoDecoder).pipeTo(VideoTrackWriter().writable)</td><td>https://github.com/WICG/web-codecs/blob/master/explainer.md#example-of-decode-for-low-latency-live-streaming-or-cloud-gaming</td></tr><tr class="even"><td>RecyclePicture</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - Would be handled with the proposed WebCodecs API. The current design will automatically recycle the pictures and keep the decoding process going.</td><td>https://github.com/WICG/web-codecs/blob/master/explainer.md#example-of-decode-for-low-latency-live-streaming-or-cloud-gaming</td></tr><tr class="odd"><td>Flush</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - Would be handled with the proposed WebCodecs API. The API will be called Flush(), however there is still discussion on how it will be sequenced in relation to decode calls.</td><td>https://github.com/WICG/web-codecs/blob/master/explainer.md#example-of-decode-for-low-latency-live-streaming-or-cloud-gaming</td></tr><tr class="even"><td>Reset</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - Would be handled with the proposed WebCodecs API by destroying the VideoDecoder instance and creating a new one. This won't be as efficient as a dedicated reset method, but the semantics for a Reset() API is still being discussed.</td><td>https://github.com/WICG/web-codecs/blob/master/explainer.md#example-of-decode-for-low-latency-live-streaming-or-cloud-gaming</td></tr></tbody></table>

### PPB\_VideoEncoder

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>Create</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - Would be handled with the proposed WebCodecs API using VideoEncoder()</td><td></td></tr><tr class="odd"><td>GetSupportedProfiles</td><td style="text-align: center;"></td><td>GAP</td><td>GAP (partial) - navigator.mediaCapabilities.encodingInfo()</td><td>The supported profiles have to be checked one by one.</td></tr><tr class="even"><td>Initialize</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - Would be handled with the proposed WebCodecs API using VideoEncoder() initialization parameters</td><td></td></tr><tr class="odd"><td>GetFramesRequired</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - No equivalent</td><td>It is unlikely that the frame pool used internally by the Web Codecs API is exposed.</td></tr><tr class="even"><td>GetFrameCodedSize</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - No equivalent</td><td>It is unlikely that the frame pool used internally by the Web Codecs API is exposed.</td></tr><tr class="odd"><td>GetVideoFrame</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - Would be handled with the proposed WebCodecs API by using ReadableStream.pipeThrough(VideoEncoder). This would directly encode the data in the Readable stream instead of grabbing a single frame to fill with data before encoding.</td><td></td></tr><tr class="even"><td>Encode</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - Would be handled with the proposed WebCodecs API using ReadableStream.pipeThrough(VideoEncoder)</td><td></td></tr><tr class="odd"><td>GetBitstreamBuffer</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - Would be handled with the proposed WebCodecs API. The current design will automatically go through the encoded bitstream buffer that is piped through.</td><td>The WebCodecs API currently assumes that bitstream buffer can be copied rather than pooled, so it will not need to be recycled.</td></tr><tr class="even"><td>RecycleBitstreamBuffer</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - Would be handled with the proposed WebCodecs API. The current design will automatically recycle the buffer to keep the encoding process going.</td><td>This is unlikely to change in the future as performance implications are smaller.</td></tr><tr class="odd"><td>RequestEncodingParametersChange</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - Would be handled by the proposed Web Codecs API. Certain parameters will have the capability of being changed on the fly, while others will require the encoder to be torn down.</td><td></td></tr><tr class="even"><td>Close</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - Would be handled with the proposed WebCodecs API by using VideoEncoder.Close()</td><td></td></tr></tbody></table>

### PPB\_VideoFrame

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>GetTimestamp</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - Would be handled with the proposed WebCodecs API.</td><td></td></tr><tr class="odd"><td>SetTimestamp</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - Would be handled with the proposed WebCodecs API.</td><td></td></tr><tr class="even"><td>GetFormat</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - Would be handled with the proposed WebCodecs API.</td><td></td></tr><tr class="odd"><td>GetSize</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - Would be handled with the proposed WebCodecs API.</td><td></td></tr><tr class="even"><td>GetDataBuffer</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - Would be handled with the proposed WebCodecs API.</td><td></td></tr><tr class="odd"><td>GetDataBufferSize</td><td style="text-align: center;"></td><td>GAP</td><td>GAP - Would be handled with the proposed WebCodecs API.</td><td></td></tr></tbody></table>

### PPB\_View

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>GetRect</td><td style="text-align: center;"></td><td>embind</td><td>Element.getBoundingClientRect</td><td></td></tr><tr class="odd"><td>IsFullscreen</td><td style="text-align: center;"></td><td>embind</td><td>Document.fullScreenEnabled</td><td>Pertains to document instead of just single element.</td></tr><tr class="even"><td>IsVisible</td><td style="text-align: center;"></td><td>embind</td><td>IntersectionObserver</td><td></td></tr><tr class="odd"><td>IsPageVisible</td><td style="text-align: center;"></td><td>embind</td><td>document.visibilityState</td><td></td></tr><tr class="even"><td>GetClipRect</td><td style="text-align: center;"></td><td>embind</td><td>IntersectionObserver</td><td></td></tr><tr class="odd"><td>GetDeviceScale</td><td style="text-align: center;"></td><td>embind</td><td>window.devicePixelRatio</td><td></td></tr><tr class="even"><td>GetCSSScale</td><td style="text-align: center;"></td><td>embind</td><td>&lt;Element&gt;.getBoundingClientRect().width / &lt;Element&gt;.offsetWidth</td><td></td></tr><tr class="odd"><td>GetScrollOffset</td><td style="text-align: center;"></td><td>embind</td><td>&lt;Element&gt;.scrollTop / &lt;Element&gt;.scrollLeft</td><td></td></tr></tbody></table>

### PPB\_WebSocket

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>Create</td><td style="text-align: center;"></td><td>GAP</td><td>WebSocket.WebSocket</td><td></td></tr><tr class="odd"><td>Connect</td><td style="text-align: center;"></td><td>GAP</td><td>WebSocket.WebSocket(url, ...) WebSocket 'open' Event</td><td></td></tr><tr class="even"><td>Close</td><td style="text-align: center;"></td><td>GAP</td><td>WebSocket.close</td><td></td></tr><tr class="odd"><td>ReceiveMessage</td><td style="text-align: center;"></td><td>GAP</td><td>WebSocket 'message' Event WebSocket 'error' Event WebSocket 'close' Event</td><td></td></tr><tr class="even"><td>SendMessage</td><td style="text-align: center;"></td><td>GAP</td><td>WebSocket.send</td><td></td></tr><tr class="odd"><td>GetBufferedAmount</td><td style="text-align: center;"></td><td>GAP</td><td>WebSocket.bufferedAmount</td><td></td></tr><tr class="even"><td>GetCloseCode</td><td style="text-align: center;"></td><td>GAP</td><td>CloseEvent.code</td><td></td></tr><tr class="odd"><td>GetCloseReason</td><td style="text-align: center;"></td><td>GAP</td><td>CloseEvent.reason</td><td></td></tr><tr class="even"><td>GetCloseWasClean</td><td style="text-align: center;"></td><td>GAP</td><td>CloseEvent.wasClean</td><td></td></tr><tr class="odd"><td>GetExtensions</td><td style="text-align: center;"></td><td>GAP</td><td>WebSocket.extensions</td><td></td></tr><tr class="even"><td>GetProtocol</td><td style="text-align: center;"></td><td>GAP</td><td>WebSocket.protocol</td><td></td></tr><tr class="odd"><td>GetReadyState</td><td style="text-align: center;"></td><td>GAP</td><td>WebSocket.readyState</td><td></td></tr><tr class="even"><td>GetURL</td><td style="text-align: center;"></td><td>GAP</td><td>WebSocket.url</td><td></td></tr></tbody></table>

### PPP\_Graphics3D

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>Graphics3DContextLost</td><td style="text-align: center;"></td><td>SDL</td><td>Canvas 'webglcontextlost' Event</td><td></td></tr></tbody></table>

### PPP\_InputEvent

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>HandleInputEvent</td><td style="text-align: center;"></td><td>SDL</td><td>Element.addEventListener</td><td></td></tr></tbody></table>

### PPP\_Instance

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>DidCreate</td><td style="text-align: center;"></td><td>N/A</td><td>&lt;Element&gt;[key]</td><td>General DOM access lets you fish out tag attributes</td></tr><tr class="odd"><td>DidDestroy</td><td style="text-align: center;"></td><td>N/A</td><td>N/A</td><td>Not triggered for NaCl</td></tr><tr class="even"><td>DidChangeView</td><td style="text-align: center;"></td><td>N/A</td><td>Element 'resize' Event</td><td></td></tr><tr class="odd"><td>DidChangeFocus</td><td style="text-align: center;"></td><td>N/A</td><td>Element 'focus', 'focusin', 'focusout' Events</td><td></td></tr><tr class="even"><td>HandleDocumentLoad</td><td style="text-align: center;"></td><td>N/A</td><td>GAP - No way to register as a mime type handler</td><td>NaCl Modules via apps + a manifest entry can be set up to handle particular mime types.</td></tr></tbody></table>

### PPP\_MessageHandler

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>HandleMessage</td><td style="text-align: center;"></td><td>embind</td><td>MessagePort 'message' Event Window 'message' Event</td><td></td></tr><tr class="odd"><td>HandleBlockingMessage</td><td style="text-align: center;"></td><td>N/A</td><td>GAP - No direct equivalent</td><td>Similar synchronization can be done off main thread with Atomics.wait. This was added to support emulation of synchronous plugin APIs.</td></tr></tbody></table>

### PPP\_Messaging

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>HandleMessage</td><td style="text-align: center;"></td><td>embind</td><td>MessagePort 'message' Event Window 'message' Event</td><td></td></tr></tbody></table>

### PPP\_MouseLock

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>MouseLockLost</td><td style="text-align: center;"></td><td>SDL</td><td>Element 'pointerlockchange', 'pointerlockerror' Events</td><td></td></tr></tbody></table>

PPAPI (Apps)
------------

### PPB\_HostResolver

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>Create</td><td style="text-align: center;">x</td><td>GAP</td><td>GAP (partial) - No direct equivalent</td><td></td></tr><tr class="odd"><td>Resolve</td><td style="text-align: center;">x</td><td>GAP</td><td>GAP (partial) - No direct equivalent</td><td></td></tr><tr class="even"><td>GetCanonicalName</td><td style="text-align: center;">x</td><td>GAP</td><td>GAP (partial) - No direct equivalent</td><td></td></tr><tr class="odd"><td>GetNetAddressCount</td><td style="text-align: center;">x</td><td>GAP</td><td>GAP (partial) - No direct equivalent</td><td></td></tr><tr class="even"><td>GetNetAddress</td><td style="text-align: center;">x</td><td>GAP</td><td>GAP (partial) - No direct equivalent</td><td></td></tr></tbody></table>

### PPB\_NetAddress

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>CreateFromIPv4Address</td><td style="text-align: center;">x</td><td>GAP</td><td>GAP (partial) - No direct equivalent</td><td></td></tr><tr class="odd"><td>CreateFromIPv6Address</td><td style="text-align: center;">x</td><td>GAP</td><td>GAP (partial) - No direct equivalent</td><td></td></tr><tr class="even"><td>GetFamily</td><td style="text-align: center;">x</td><td>GAP</td><td>GAP (partial) - No direct equivalent</td><td></td></tr><tr class="odd"><td>DescribeAsString</td><td style="text-align: center;">x</td><td>GAP</td><td>GAP (partial) - No direct equivalent</td><td></td></tr><tr class="even"><td>DescribeAsIPv4Address</td><td style="text-align: center;">x</td><td>GAP</td><td>GAP (partial) - No direct equivalent</td><td></td></tr><tr class="odd"><td>DescribeAsIPv6Address</td><td style="text-align: center;">x</td><td>GAP</td><td>GAP (partial) - No direct equivalent</td><td></td></tr></tbody></table>

### PPB\_NetworkList

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>GetCount</td><td style="text-align: center;">x</td><td>GAP</td><td>GAP - No direct equivalent</td><td></td></tr><tr class="odd"><td>GetName</td><td style="text-align: center;">x</td><td>GAP</td><td>GAP - No direct equivalent</td><td></td></tr><tr class="even"><td>GetType</td><td style="text-align: center;">x</td><td>GAP</td><td>GAP - No direct equivalent</td><td></td></tr><tr class="odd"><td>GetState</td><td style="text-align: center;">x</td><td>GAP</td><td>GAP - No direct equivalent</td><td></td></tr><tr class="even"><td>GetIpAddress</td><td style="text-align: center;">x</td><td>GAP</td><td>GAP - No direct equivalent</td><td></td></tr><tr class="odd"><td>GetDisplayName</td><td style="text-align: center;">x</td><td>GAP</td><td>GAP - No direct equivalent</td><td></td></tr><tr class="even"><td>GetMTU</td><td style="text-align: center;">x</td><td>GAP</td><td>GAP - No direct equivalent</td><td></td></tr></tbody></table>

### PPB\_NetworkMonitor

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>Create</td><td style="text-align: center;">x</td><td>GAP</td><td>GAP - No direct equivalent</td><td></td></tr><tr class="odd"><td>UpdateNetworkList</td><td style="text-align: center;">x</td><td>GAP</td><td>GAP - No direct equivalent</td><td></td></tr></tbody></table>

### PPB\_NetworkProxy

<table><tbody><tr class="odd"><td>PPAPI Method</td><td style="text-align: center;">Assumes Threads</td><td>Emscripten</td><td>Web API</td><td>Limitations</td></tr><tr class="even"><td>GetProxyForURL</td><td style="text-align: center;">x</td><td>GAP</td><td>GAP - No direct equivalent</td><td></td></tr></tbody></table>

### PPB\_TCPSocket and PPB\_UDPSocket

There is not a direct 1:1 mapping for migration. Instead, we have outlined some user scenarios below and what the recommended migration path is.

<table><tbody><tr class="odd"><td>Use Case</td><td>Recommendations</td></tr><tr class="even"><td>Screen sharing</td><td><a href="https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getDisplayMedia">getDisplayMedia</a> and <a href="https://webrtc.org/">WebRTC</a> ( <a href="https://webrtc.github.io/samples/src/content/getusermedia/getdisplaymedia/">demo</a>)</td></tr><tr class="odd"><td>Loading from a local server to minimize bandwidth usage</td><td>XHR, Fetch, Streams, Service Worker, Cache APIs</td></tr><tr class="even"><td>Loading from a local instance of a web app / Connecting to a local instance of a web app</td><td><a href="https://webrtc.org/">WebRTC</a></td></tr><tr class="odd"><td>Chat</td><td><a href="https://developer.mozilla.org/ja/docs/Web/API/WebSockets_API">WebSocket</a>*</td></tr><tr class="even"><td>Realtime audio/video communication</td><td><a href="https://webrtc.org/">WebRTC</a></td></tr><tr class="odd"><td>Collaboration</td><td><a href="https://developer.mozilla.org/ja/docs/Web/API/WebSockets_API">WebSocket</a>*</td></tr><tr class="even"><td>Realtime multiplayer games</td><td><a href="https://github.com/WICG/web-transport/blob/master/README.md">WebTransport</a>** unless P2P in which case <a href="https://webrtc.org/">WebRTC</a> (or WebTransport over RTCIceTransport)</td></tr><tr class="odd"><td>Realtime interactive streaming</td><td><a href="https://github.com/WICG/web-transport/blob/master/README.md">WebTransport</a>**</td></tr><tr class="even"><td>Communicating with legacy server</td><td>Proxy server or middleware to do protocol conversion. Feedback to <a href="http://bit.ly/network-api-gaps">bit.ly/network-api-gaps</a></td></tr></tbody></table>

*\*: Or WebTransport in the future*  
*\*\*: See [chromestatus](https://chromestatus.com/features#webtransport) for availability*
