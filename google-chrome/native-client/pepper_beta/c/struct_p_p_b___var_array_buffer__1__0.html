<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>struct_p_p_b___var_array_buffer__1__0</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
</head>
<body>
<p>—json {“title”:“PPB_VarArrayBuffer Struct Reference”} —</p>
<h2 id="data-fields">Data Fields</h2>
<table>
<tbody>
<tr class="odd">
<td style="text-align: right;">
struct <a href="/docs/native-client/pepper_beta/c/struct_p_p___var/" class="el">PP_Var</a>(* 
</td>
<td>
<a href="/docs/native-client/pepper_beta/c/struct_p_p_b___var_array_buffer__1__0#a348f1470a2fc6cba9d430d0544e84225" class="el">Create</a> )(uint32_t size_in_bytes)
</td>
</tr>
<tr class="even">
<td style="text-align: right;">
<a href="/docs/native-client/pepper_beta/c/group___enums#ga4f272d99be14aacafe08dfd4ef830918" class="el">PP_Bool</a>(* 
</td>
<td>
<a href="/docs/native-client/pepper_beta/c/struct_p_p_b___var_array_buffer__1__0#a0ad6305942f991daa6dfe3b579931ea1" class="el">ByteLength</a> )(struct <a href="/docs/native-client/pepper_beta/c/struct_p_p___var/" class="el">PP_Var</a> array, uint32_t *byte_length)
</td>
</tr>
<tr class="odd">
<td style="text-align: right;">
void <em>(</em> 
</td>
<td>
<a href="/docs/native-client/pepper_beta/c/struct_p_p_b___var_array_buffer__1__0#a4c7c25b939f56de64fa3f6f906a7da8c" class="el">Map</a> )(struct <a href="/docs/native-client/pepper_beta/c/struct_p_p___var/" class="el">PP_Var</a> array)
</td>
</tr>
<tr class="even">
<td style="text-align: right;">
void(* 
</td>
<td>
<a href="/docs/native-client/pepper_beta/c/struct_p_p_b___var_array_buffer__1__0#ac841a12b7eb93dd05bd2b864920e22a7" class="el">Unmap</a> )(struct <a href="/docs/native-client/pepper_beta/c/struct_p_p___var/" class="el">PP_Var</a> array)
</td>
</tr>
</tbody>
</table>
<hr />
<p><span id="details" class="anchor" style="margin: 0;"></span></p>
<h2 id="detailed-description">Detailed Description</h2>
<p>The <code>PPB_VarArrayBuffer</code> interface provides a way to interact with JavaScript ArrayBuffers, which represent a contiguous sequence of bytes.</p>
<p>Use <code>PPB_Var</code> to manage the reference count for a <code>VarArrayBuffer</code>. Note that these Vars are not part of the embedding page’s DOM, and can only be shared with JavaScript using the <code>PostMessage</code> and <code>HandleMessage</code> functions of <code>pp::Instance</code>.</p>
<hr />
<h2 id="field-documentation">Field Documentation</h2>
<p><span id="a0ad6305942f991daa6dfe3b579931ea1" class="anchor" style="margin: 0;"></span></p>
<table>
<tbody>
<tr class="odd">
<td>
<a href="/docs/native-client/pepper_beta/c/group___enums#ga4f272d99be14aacafe08dfd4ef830918" class="el">PP_Bool</a>(* <a href="/docs/native-client/pepper_beta/c/struct_p_p_b___var_array_buffer__1__0#a0ad6305942f991daa6dfe3b579931ea1" class="el">PPB_VarArrayBuffer::ByteLength</a>)(struct <a href="/docs/native-client/pepper_beta/c/struct_p_p___var/" class="el">PP_Var</a> array, uint32_t *byte_length)
</td>
</tr>
</tbody>
</table>
<p><a href="/docs/native-client/pepper_beta/c/struct_p_p_b___var_array_buffer__1__0#a0ad6305942f991daa6dfe3b579931ea1" class="el" title="ByteLength() retrieves the length of the VarArrayBuffer in bytes.">ByteLength()</a> retrieves the length of the <code>VarArrayBuffer</code> in bytes.</p>
<p>On success, <code>byte_length</code> is set to the length of the given <code>ArrayBuffer</code> var. On failure, <code>byte_length</code> is unchanged (this could happen, for instance, if the given <code>PP_Var</code> is not of type <code>PP_VARTYPE_ARRAY_BUFFER</code>). Note that <a href="/docs/native-client/pepper_beta/c/struct_p_p_b___var_array_buffer__1__0#a0ad6305942f991daa6dfe3b579931ea1" class="el" title="ByteLength() retrieves the length of the VarArrayBuffer in bytes.">ByteLength()</a> will successfully retrieve the size of an <code>ArrayBuffer</code> even if the <code>ArrayBuffer</code> is not currently mapped.</p>
<strong>Parameters:</strong><br />

<table>
<tbody>
<tr class="odd">
<td>
[in]
</td>
<td>
array
</td>
<td>
The <code>ArrayBuffer</code> whose length should be returned.
</td>
</tr>
<tr class="even">
<td>
[out]
</td>
<td>
byte_length
</td>
<td>
A variable which is set to the length of the given <code>ArrayBuffer</code> on success.
</td>
</tr>
</tbody>
</table>
<!-- -->
<p><strong>Returns:</strong><br />
<code>PP_TRUE</code> on success, <code>PP_FALSE</code> on failure.</p>
<p><span id="a348f1470a2fc6cba9d430d0544e84225" class="anchor" style="margin: 0;"></span></p>
<table>
<tbody>
<tr class="odd">
<td>
struct <a href="/docs/native-client/pepper_beta/c/struct_p_p___var/" class="el">PP_Var</a>(* <a href="/docs/native-client/pepper_beta/c/struct_p_p_b___var_array_buffer__1__0#a348f1470a2fc6cba9d430d0544e84225" class="el">PPB_VarArrayBuffer::Create</a>)(uint32_t size_in_bytes)<code> [read]</code>
</td>
</tr>
</tbody>
</table>
<p><a href="/docs/native-client/pepper_beta/c/struct_p_p_b___var_array_buffer__1__0#a348f1470a2fc6cba9d430d0544e84225" class="el" title="Create() creates a zero-initialized VarArrayBuffer.">Create()</a> creates a zero-initialized <code>VarArrayBuffer</code>.</p>
<strong>Parameters:</strong><br />

<table>
<tbody>
<tr class="odd">
<td>
[in]
</td>
<td>
size_in_bytes
</td>
<td>
The size of the <code>ArrayBuffer</code> to be created.
</td>
</tr>
</tbody>
</table>
<!-- -->
<p><strong>Returns:</strong><br />
A <code>PP_Var</code> representing a <code>VarArrayBuffer</code> of the requested size and with a reference count of 1.</p>
<p><span id="a4c7c25b939f56de64fa3f6f906a7da8c" class="anchor" style="margin: 0;"></span></p>
<table>
<tbody>
<tr class="odd">
<td>
void<em>(</em> <a href="/docs/native-client/pepper_beta/c/struct_p_p_b___var_array_buffer__1__0#a4c7c25b939f56de64fa3f6f906a7da8c" class="el">PPB_VarArrayBuffer::Map</a>)(struct <a href="/docs/native-client/pepper_beta/c/struct_p_p___var/" class="el">PP_Var</a> array)
</td>
</tr>
</tbody>
</table>
<p><a href="/docs/native-client/pepper_beta/c/struct_p_p_b___var_array_buffer__1__0#a4c7c25b939f56de64fa3f6f906a7da8c" class="el" title="Map() maps the ArrayBuffer in to the module&#39;s address space and returns a pointer to the beginning of...">Map()</a> maps the <code>ArrayBuffer</code> in to the module’s address space and returns a pointer to the beginning of the buffer for the given <code>ArrayBuffer PP_Var</code>.</p>
<p>ArrayBuffers are copied when transmitted, so changes to the underlying memory are not automatically available to the embedding page.</p>
<p>Note that calling <a href="/docs/native-client/pepper_beta/c/struct_p_p_b___var_array_buffer__1__0#a4c7c25b939f56de64fa3f6f906a7da8c" class="el" title="Map() maps the ArrayBuffer in to the module&#39;s address space and returns a pointer to the beginning of...">Map()</a> can be a relatively expensive operation. Use care when calling it in performance-critical code. For example, you should call it only once when looping over an <code>ArrayBuffer</code>.</p>
<p><strong>Example:</strong></p>
<pre><code> char* data = (char*)(array_buffer_if.Map(array_buffer_var));
 uint32_t byte_length = 0;
 PP_Bool ok = array_buffer_if.ByteLength(array_buffer_var, &amp;byte_length);
 if (!ok)
   return DoSomethingBecauseMyVarIsNotAnArrayBuffer();
 for (uint32_t i = 0; i &lt; byte_length; ++i)
   data[i] = &#39;A&#39;;</code></pre>
<strong>Parameters:</strong><br />

<table>
<tbody>
<tr class="odd">
<td>
[in]
</td>
<td>
array
</td>
<td>
The <code>ArrayBuffer</code> whose internal buffer should be returned.
</td>
</tr>
</tbody>
</table>
<!-- -->
<p><strong>Returns:</strong><br />
A pointer to the internal buffer for this <code>ArrayBuffer</code>. Returns <code>NULL</code> if the given <code>PP_Var</code> is not of type <code>PP_VARTYPE_ARRAY_BUFFER</code>.</p>
<p><span id="ac841a12b7eb93dd05bd2b864920e22a7" class="anchor" style="margin: 0;"></span></p>
<table>
<tbody>
<tr class="odd">
<td>
void(* <a href="/docs/native-client/pepper_beta/c/struct_p_p_b___var_array_buffer__1__0#ac841a12b7eb93dd05bd2b864920e22a7" class="el">PPB_VarArrayBuffer::Unmap</a>)(struct <a href="/docs/native-client/pepper_beta/c/struct_p_p___var/" class="el">PP_Var</a> array)
</td>
</tr>
</tbody>
</table>
<p><a href="/docs/native-client/pepper_beta/c/struct_p_p_b___var_array_buffer__1__0#ac841a12b7eb93dd05bd2b864920e22a7" class="el" title="Unmap() unmaps the given ArrayBuffer var from the module address space.">Unmap()</a> unmaps the given <code>ArrayBuffer</code> var from the module address space.</p>
<p>Use this if you want to save memory but might want to call <a href="/docs/native-client/pepper_beta/c/struct_p_p_b___var_array_buffer__1__0#a4c7c25b939f56de64fa3f6f906a7da8c" class="el" title="Map() maps the ArrayBuffer in to the module&#39;s address space and returns a pointer to the beginning of...">Map()</a> to map the buffer again later. The <code>PP_Var</code> remains valid and should still be released using <code>PPB_Var</code> when you are done with the <code>ArrayBuffer</code>.</p>
<strong>Parameters:</strong><br />

<table>
<tbody>
<tr class="odd">
<td>
[in]
</td>
<td>
array
</td>
<td>
The <code>ArrayBuffer</code> to be released.
</td>
</tr>
</tbody>
</table>
<hr />
<p>The documentation for this struct was generated from the following file:</p>
<ul>
<li><a href="/docs/native-client/pepper_beta/c/ppb__var__array__buffer_8h/" class="el">ppb_var_array_buffer.h</a></li>
</ul>
</body>
</html>
