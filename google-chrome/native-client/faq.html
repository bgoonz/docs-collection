<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>faq</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
</head>
<body>
<p>—json {“title”:“Frequently Asked Questions”} —</p>
<p>{% include ‘partials/nacl-warning.njk’ %}</p>
<hr />
<ul>
<li><p><a href="#what-is-native-client-good-for" id="id1" class="reference internal">What is Native Client Good For?</a></p>
<ul>
<li><a href="#why-did-google-build-native-client" id="id2" class="reference internal">Why did Google build Native Client?</a></li>
<li><a href="#when-should-i-use-portable-native-client-instead-of-native-client" id="id3" class="reference internal">When should I use Portable Native Client instead of Native Client?</a></li>
<li><a href="#when-should-i-use-portable-native-client-native-client" id="id4" class="reference internal">When should I use Portable Native Client / Native Client?</a></li>
<li><a href="#how-fast-does-code-run-in-portable-native-client" id="id5" class="reference internal">How fast does code run in Portable Native Client?</a></li>
<li><a href="#why-use-portable-native-client-instead-of-technology-x" id="id6" class="reference internal">Why use Portable Native Client instead of <em>&lt;technology X&gt;</em>?</a></li>
<li><a href="#if-i-want-direct-access-to-the-os-should-i-use-native-client" id="id7" class="reference internal">If I want direct access to the OS, should I use Native Client?</a></li>
</ul></li>
<li><p><a href="#development-environments-and-tools" id="id8" class="reference internal">Development Environments and Tools</a></p>
<ul>
<li><a href="#what-development-environment-and-development-operating-system-do-you-recommend" id="id9" class="reference internal">What development environment and development operating system do you recommend?</a></li>
<li><a href="#i-m-not-familiar-with-native-development-tools-can-i-still-use-the-native-client-sdk" id="id10" class="reference internal">I’m not familiar with native development tools, can I still use the Native Client SDK?</a></li>
</ul></li>
<li><p><a href="#openness-and-supported-architectures-and-languages" id="id11" class="reference internal">Openness, and Supported Architectures and Languages</a></p>
<ul>
<li><a href="#is-native-client-open-is-it-a-standard" id="id12" class="reference internal">Is Native Client open? Is it a standard?</a></li>
<li><a href="#how-can-i-contribute-to-native-client" id="id13" class="reference internal">How can I contribute to Native Client?</a></li>
<li><a href="#what-are-the-supported-instruction-set-architectures" id="id14" class="reference internal">What are the supported instruction set architectures?</a></li>
<li><a href="#do-i-have-to-use-c-or-c-i-d-really-like-to-use-another-language" id="id15" class="reference internal">Do I have to use C or C++? I’d really like to use another language.</a></li>
<li><a href="#do-you-only-support-chrome-what-about-other-browsers" id="id16" class="reference internal">Do you only support Chrome? What about other browsers?</a></li>
<li><a href="#what-s-the-difference-between-npapi-and-pepper" id="id17" class="reference internal">What’s the difference between NPAPI and Pepper?</a></li>
<li><a href="#is-npapi-part-of-the-native-client-sdk" id="id18" class="reference internal">Is NPAPI part of the Native Client SDK?</a></li>
<li><a href="#does-native-client-support-simd-vector-instructions" id="id19" class="reference internal">Does Native Client support SIMD vector instructions?</a></li>
<li><a href="#can-i-use-native-client-for-3d-graphics" id="id20" class="reference internal">Can I use Native Client for 3D graphics?</a></li>
<li><a href="#does-native-client-support-concurrency-parallelism" id="id21" class="reference internal">Does Native Client support concurrency/parallelism?</a></li>
</ul></li>
<li><p><a href="#coming-soon" id="id22" class="reference internal">Coming Soon</a></p>
<ul>
<li><a href="#do-native-client-modules-have-access-to-external-devices" id="id23" class="reference internal">Do Native Client modules have access to external devices?</a></li>
</ul></li>
<li><p><a href="#security-and-privacy" id="id24" class="reference internal">Security and Privacy</a></p>
<ul>
<li><a href="#what-happens-to-my-data-when-i-use-native-client" id="id25" class="reference internal">What happens to my data when I use Native Client?</a></li>
<li><a href="#how-does-native-client-prevent-sandboxed-code-from-doing-bad-things" id="id26" class="reference internal">How does Native Client prevent sandboxed code from doing Bad Things?</a></li>
<li><a href="#how-does-google-know-that-the-safety-measures-in-native-client-are-sufficient" id="id27" class="reference internal">How does Google know that the safety measures in Native Client are sufficient?</a></li>
</ul></li>
<li><p><a href="#development" id="id28" class="reference internal">Development</a></p>
<ul>
<li><a href="#how-do-i-debug" id="id29" class="reference internal">How do I debug?</a></li>
<li><a href="#how-do-i-build-x86-32-x86-64-or-arm-nexes" id="id30" class="reference internal">How do I build x86-32, x86-64 or ARM <code>.nexes</code>?</a></li>
<li><a href="#how-can-my-web-application-determine-which-nexe-to-load" id="id31" class="reference internal">How can my web application determine which <code>.nexe</code> to load?</a></li>
<li><a href="#is-it-possible-to-build-a-native-client-module-with-just-plain-c-not-c" id="id32" class="reference internal">Is it possible to build a Native Client module with just plain C (not C++)?</a></li>
<li><a href="#what-unix-system-calls-can-i-make-through-native-client" id="id33" class="reference internal">What UNIX system calls can I make through Native Client?</a></li>
<li><a href="#is-my-favorite-third-party-library-available-for-native-client" id="id34" class="reference internal">Is my favorite third-party library available for Native Client?</a></li>
<li><a href="#do-all-the-files-in-an-application-need-to-be-served-from-the-same-domain" id="id35" class="reference internal">Do all the files in an application need to be served from the same domain?</a></li>
</ul></li>
<li><p><a href="#portability" id="id36" class="reference internal">Portability</a></p>
<ul>
<li><a href="#do-i-have-to-do-anything-special-to-make-my-application-run-on-different-operating-systems" id="id37" class="reference internal">Do I have to do anything special to make my application run on different operating systems?</a></li>
<li><a href="#how-easy-is-it-to-port-my-existing-native-code-to-native-client" id="id38" class="reference internal">How easy is it to port my existing native code to Native Client?</a></li>
</ul></li>
<li><p><a href="#troubleshooting" id="id39" class="reference internal">Troubleshooting</a></p>
<ul>
<li><a href="#my-pexe-isn-t-loading-help" id="id40" class="reference internal">My <code>.pexe</code> isn’t loading, help!</a></li>
<li><a href="#my-nexe-files-never-finish-loading-what-gives" id="id41" class="reference internal">My <code>.nexe</code> files never finish loading. What gives?</a></li>
</ul></li>
</ul>
<p>This document answers some frequently asked questions about Native Client (NaCl) and Portable Native Client (PNaCl, pronounced “pinnacle”). For a high-level overview of Native Client, see the <a href="/docs/native-client/overview" class="reference internal"><em>Technical Overview</em></a>.</p>
<p>If you have questions that aren’t covered in this FAQ:</p>
<ul>
<li>Scan through the <a href="/docs/native-client/sdk/release-notes" class="reference internal"><em>Release Notes</em></a>.</li>
<li>Search through or ask on the <a href="/docs/native-client/help" class="reference internal"><em>Native Client Forums</em></a>.</li>
</ul>
<h2 id="what-is-native-client-good-for">What is Native Client Good For?</h2>
<h3 id="why-did-google-build-native-client">Why did Google build Native Client?</h3>
<ul>
<li><strong>Performance:</strong> Native Client modules run nearly as fast as native compiled code.</li>
<li><strong>Security:</strong> Native Client lets users run native compiled code in the browser with the same level of security and privacy as traditional web applications.</li>
<li><p><strong>Convenience:</strong></p>
<ul>
<li>Developers can leverage existing code, written in C/C++ or other languages, in their applications without forcing users to install a plugin.</li>
<li>This code can interact with the embedding web page as part of an HTML and JavaScript web application, or it can be a self-contained and immersive experience.</li>
</ul></li>
<li><p><strong>Portability:</strong> Native Client and Portable Native Client applications can execute on:</p>
<ul>
<li>The Windows, Mac, Linux or ChromeOS operating systems.</li>
<li>Processors with the x86-32, x86-64, or ARM instruction set architectures. Native Client also has experimental support for MIPS.</li>
</ul></li>
</ul>
<p>Portable Native client further enhances the above:</p>
<ul>
<li><strong>Performance:</strong> Each PNaCl release brings with it more performance enhancements. Already-released applications get faster over time, conserving user’s battery.</li>
<li><strong>Security:</strong> Users are kept secure with an ever-improving sandbox model which adapts to novel attacks, without affecting already-released applications.</li>
<li><strong>Convenience:</strong> Developers only need to ship a single <code>.pexe</code> file, not one <code>.nexe</code> file per supported architecture.</li>
<li><strong>Portability:</strong> Developers and users don’t need to worry about already-released applications not working on new hardware: PNaCl already supports all architectures NaCl does, and as PNaCl evolves it gains support for new processors and fully uses their capabilities.</li>
</ul>
<p>For more details, refer to the <a href="/docs/native-client/nacl-and-pnacl" class="reference internal"><em>history behind and comparison of NaCl and PNaCl</em></a>.</p>
<h3 id="when-should-i-use-portable-native-client-instead-of-native-client">When should I use Portable Native Client instead of Native Client?</h3>
<p>See <a href="/docs/native-client/nacl-and-pnacl" class="reference internal"><em>NaCl and PNaCl</em></a>. In short: PNaCl works on the Open Web platform delivered by Chrome whereas NaCl only works on the Chrome Web Store.</p>
<h3 id="when-should-i-use-portable-native-client-native-client">When should I use Portable Native Client / Native Client?</h3>
<p>The following are some typical use cases. For details, see the <a href="/docs/native-client/overview" class="reference internal"><em>Technical Overview</em></a>.</p>
<ul>
<li>Porting existing applications or software components, written in C/C++ or virtual machines written in C/C++, for use in a web application.</li>
<li><p>Using compute-intensive applications, including threads and SIMD, such as:</p>
<ul>
<li>Scientific computing.</li>
<li>Handling multimedia for a web application.</li>
<li>Various aspects of web-based games, including physics engines and AI.</li>
</ul></li>
<li><p>Running untrusted code on a server or within an application (such as a plugin system for a game).</p></li>
</ul>
<p>Portable Native Client and Native Client are versatile technologies which are used in many other contexts outside of Chrome.</p>
<h3 id="how-fast-does-code-run-in-portable-native-client">How fast does code run in Portable Native Client?</h3>
<p>Fast! The SPEC2k benchmarks (C, C++ and floating-point benchmarks) give the following overhead for optimized PNaCl compared to regular optimized LLVM:</p>
<table>
<tbody>
<tr class="odd">
<td>
x86-32
</td>
<td>
15%
</td>
</tr>
<tr class="even">
<td>
x86-64
</td>
<td>
25%
</td>
</tr>
<tr class="odd">
<td>
ARM
</td>
<td>
10%
</td>
</tr>
</tbody>
</table>
<p>Note that benchmark performance is sometimes bimodal, so different use cases are likely to achieve better or worse performance than the above averages. For example floating-point heavy code usually exhibits much lower overheads whereas very branch-heavy code often performs worse.</p>
<p>Note that PNaCl supports performance features that are often used in native code such as <a href="/docs/native-client/reference/pnacl-c-cpp-language-support#language-support-threading" class="reference internal"><em>threading</em></a> and <a href="/docs/native-client/reference/pnacl-c-cpp-language-support#portable-simd-vectors" class="reference internal"><em>Portable SIMD Vectors</em></a>.</p>
<p>For details, see:</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=675znN6tntw&amp;list=PLOU2XLYxmsIIwGK7v7jg3gQvIAWJzdat_" class="reference external">PNaCl SIMD: Speed on the Web</a>.</li>
<li><a href="https://nativeclient.googlecode.com/svn/data/site/NaCl_SFI.pdf" class="reference external">Adapting Software Fault Isolation to Contemporary CPU Architectures</a> (PDF).</li>
<li><a href="http://research.google.com/pubs/pub34913.html" class="reference external">Native Client: A Sandbox for Portable, Untrusted x86 Code</a> (PDF).</li>
</ul>
<p>If your code isn’t performing as close to native speed as you’d expect, <a href="/docs/native-client/help" class="reference internal"><em>let us know</em></a>!</p>
<h3 id="why-use-portable-native-client-instead-of-technology-x">Why use Portable Native Client instead of <em>&lt;technology X&gt;</em>?</h3>
<p>Many other technologies can be compared to Portable Native Client: Flash, Java, Silverlight, ActiveX, .NET, asm.js, etc…</p>
<p>Different technologies have different strengths and weaknesses. In appropriate contexts, Portable Native Client can be faster, more secure, and/or more compatible across operating systems and architectures than other technologies.</p>
<p>Portable Native Client complement other technologies by giving web developers a new capability: the ability to run fast, secure native code from a web browser in an architecture-independent way.</p>
<h3 id="if-i-want-direct-access-to-the-os-should-i-use-native-client">If I want direct access to the OS, should I use Native Client?</h3>
<p>No—Native Client does not provide direct access to the OS or devices, or otherwise bypass the JavaScript security model. For more information, see later sections of this FAQ.</p>
<h2 id="development-environments-and-tools">Development Environments and Tools</h2>
<h3 id="what-development-environment-and-development-operating-system-do-you-recommend">What development environment and development operating system do you recommend?</h3>
<p>You can develop on Windows, Mac, or Linux, and the resulting Native Client or Portable Native Client application will run inside the Google Chrome browser on all those platforms as well as ChromeOS. You can also develop on ChromeOS with <a href="https://github.com/dnschneid/crouton" class="reference external">Crouton</a> or our <a href="https://www.youtube.com/watch?v=OzNuzBDEWzk&amp;list=PLOU2XLYxmsIIwGK7v7jg3gQvIAWJzdat_" class="reference external">experimental development environment which runs within NaCl</a>, and we’re working on self-hosting a full development environment on Portable Native Client.</p>
<p>Any editor+shell combination should work as well as IDEs like Eclipse, Visual Studio with the <a href="/docs/native-client/devguide/devcycle/vs-addin" class="reference internal"><em>Native Client Add-In</em></a> on Windows, or Xcode on Mac OSX.</p>
<h3 id="im-not-familiar-with-native-development-tools-can-i-still-use-the-native-client-sdk">I’m not familiar with native development tools, can I still use the Native Client SDK?</h3>
<p>You may find our <a href="/docs/native-client/devguide/tutorial/index" class="reference internal"><em>Tutorial</em></a> and <a href="/docs/native-client/devguide/devcycle/building" class="reference internal"><em>Building instructions</em></a> useful, and you can look at the code and Makefiles for the SDK examples to understand how the examples are built and run.</p>
<p>You’ll need to learn how to use some tools (like GCC, LLVM, make, Eclipse, Visual Studio, or Xcode) before you can get very far with the SDK. Try seaching for an <a href="https://www.google.com/search?q=gcc+introduction" class="reference external">introduction to GCC</a>.</p>
<h2 id="openness-and-supported-architectures-and-languages">Openness, and Supported Architectures and Languages</h2>
<h3 id="is-native-client-open-is-it-a-standard">Is Native Client open? Is it a standard?</h3>
<p>Native Client is completely open: the executable format is open and the <a href="https://code.google.com/p/nativeclient/" class="reference external">source code is open</a>. Right now the Native Client project is in its early stages, so it’s premature to consider Native Client for standardization.</p>
<p>We consistenly try to document our design and implementation and hope to standardize Portable Native Client when it gains more traction. A good example is our <a href="/docs/native-client/reference/pnacl-bitcode-abi" class="reference internal"><em>PNaCl bitcode reference manual</em></a>.</p>
<h3 id="how-can-i-contribute-to-native-client">How can I contribute to Native Client?</h3>
<p>Read about <a href="/docs/native-client/reference/ideas" class="reference internal"><em>contributor ideas</em></a>.</p>
<h3 id="what-are-the-supported-instruction-set-architectures">What are the supported instruction set architectures?</h3>
<p>Portable Native Client uses an architecture-independent format (the <code>.pexe</code>) which can currently be translated to execute on processors with the x86-32, x86-64, and ARM instruction set architectures, as well as experimental support for MIPS. As new architectures come along and become popular we expect Portable Native Client to support them without developers having to recompile their code.</p>
<p>Native Client can currently execute on the same architectures as Portable Native Client but is only supported on the Chrome Web Store. Native Client’s <code>.nexe</code> files are architecture-dependent and cannot adapt to new architectures without recompilation, we therefore deem them better suited to a web store than to the open web.</p>
<p>With Portable Native Client we deliver a system that has comparable portability to JavaScript and can adapt to new instruction set architectures without requiring recompilation. The web is better when it’s platform-independent, and we’d like it to stay that way.</p>
<h3 id="do-i-have-to-use-c-or-c-id-really-like-to-use-another-language."><span id="other-languages"></span>Do I have to use C or C++? I’d really like to use another language.</h3>
<p>Right now only C and C++ are supported directly by the toolchain in the SDK. C# and other languages in the .NET family are supported via the <a href="https://github.com/elijahtaylor/mono" class="reference external">Mono port</a> for Native Client. Moreover, there are several ongoing projects to support additional language runtimes (e.g. <a href="https://chromium.googlesource.com/webports" class="reference external">webports includes Lua, Python and Ruby</a>) as well as to compile more languages to LLVM’s intermediate representation (e.g. support <a href="http://halide-lang.org/" class="reference external">Halide</a>, Haskell with <a href="http://www.haskell.org/ghc/docs/latest/html/users_guide/code-generators.html" class="reference external">GHC</a> or support Fortran with <a href="https://flang-gsoc.blogspot.ie/2013/09/end-of-gsoc-report.html" class="reference external">flang</a>), or transpile languages to C/C++ (source-to-source compilation). Even JavaScript is supported by compiling <a href="https://code.google.com/p/v8/" class="reference external">V8</a> to target PNaCl.</p>
<p>The PNaCl toolchain is built on LLVM and can therefore generate code from languages such as <a href="http://www.rust-lang.org/" class="reference external">Rust</a>, <a href="https://golang.org" class="reference external">Go</a>, or Objective-C, but there may still be a few rough edges.</p>
<p>If you’re interested in getting other languages working, please contact the Native Client team by way of the <a href="https://groups.google.com/group/native-client-discuss" class="reference external">native-client-discuss</a> mailing list, and read through <a href="/docs/native-client/reference/ideas" class="reference internal"><em>contributor ideas</em></a>.</p>
<h3 id="do-you-only-support-chrome-what-about-other-browsers">Do you only support Chrome? What about other browsers?</h3>
<p>We aim to support multiple browsers. However, a number of features that we consider requirements for a production-quality system that keeps the user safe are difficult to implement without help from the browser. Specific examples are an out-of-process plugin architecture and appropriate interfaces for integrated 3D graphics. We have worked closely with Chromium developers to deliver these features and we are eager to collaborate with developers from other browsers.</p>
<h3 id="whats-the-difference-between-npapi-and-pepper">What’s the difference between NPAPI and Pepper?</h3>
<p><a href="/docs/native-client/pepper_stable/index" class="reference internal"><em>Pepper</em></a> (also known as PPAPI) is a new API that lets Native Client modules communicate with the browser. Pepper supports various features that don’t have robust support in NPAPI, such as event handling, out-of-process plugins, and asynchronous interfaces. Native Client has transitioned from using NPAPI to using Pepper.</p>
<h3 id="is-npapi-part-of-the-native-client-sdk">Is NPAPI part of the Native Client SDK?</h3>
<p>NPAPI is not supported by the Native Client SDK, and is <a href="http://blog.chromium.org/2013/09/saying-goodbye-to-our-old-friend-npapi.html" class="reference external">deprecated in Chrome</a>.</p>
<h3 id="does-native-client-support-simd-vector-instructions">Does Native Client support SIMD vector instructions?</h3>
<p>Portable Native Client supports portable SIMD vectors, as detailed in <a href="/docs/native-client/reference/pnacl-c-cpp-language-support#portable-simd-vectors" class="reference internal"><em>Portable SIMD Vectors</em></a>.</p>
<p>Native Client supports SSE, AVX1, FMA3 and AVX2 (except for VGATHER) on x86 and NEON on ARM.</p>
<h3 id="can-i-use-native-client-for-3d-graphics">Can I use Native Client for 3D graphics?</h3>
<p>Yes. Native Client supports <a href="https://www.khronos.org/opengles/" class="reference external">OpenGL ES 2.0</a>.</p>
<p>To alert the user regarding their hardware platform’s 3D feature set before loading a large NaCl application, see <a href="/docs/native-client/devguide/coding/3D-graphics" class="reference internal"><em>Vetting the driver in Javascript</em></a>.</p>
<p>Some GL extensions are exposed to Native Client applications, see the <a href="https://source.chromium.org/chromium/chromium/src/+/HEAD:ppapi/lib/gl/gles2/gles2.c" class="reference external">GLES2 file</a>. This file is part of the GL wrapper supplied by the library <code>ppapi_gles2</code> which you’ll want to include in your project. In most cases extensions map to extensions available on other platforms, or differ very slightly (if they differ, the extension is usually CHROMIUM or ANGLE instead of EXT).</p>
<h3 id="does-native-client-support-concurrencyparallelism">Does Native Client support concurrency/parallelism?</h3>
<p>Native Client and Portable Native Client both support pthreads, C11/C++11 threads, and low-level synchronization primitives (mutex, barriers, atomic read/modify/write, compare-and-exchange, etc…), thus allowing your Native Client application to utilize several CPU cores. Note that this allows you to modify datastructures concurrently without needing to copy them, which is often a limitation of shared-nothing systems. For more information see <a href="/docs/native-client/reference/pnacl-c-cpp-language-support#memory-model-and-atomics" class="reference internal"><em>memory model and atomics</em></a> and <a href="/docs/native-client/reference/pnacl-c-cpp-language-support#language-support-threading" class="reference internal"><em>threading</em></a>.</p>
<p>Native Client doesn’t support HTML5 Web Workers directly but can interact with JavaScript code which does.</p>
<h2 id="coming-soon">Coming Soon</h2>
<h3 id="do-native-client-modules-have-access-to-external-devices">Do Native Client modules have access to external devices?</h3>
<p>At this time Native Client modules do not have access to serial ports, camera devices, or microphones: Native Client can only use native resources that today’s browsers can access. However, we intend to recommend such features to the standards bodies and piggyback on their efforts to make these resources available inside the browser.</p>
<p>You can generally think of Pepper as the C/C++ bindings to the capabilities of HTML5. The goal is for Pepper and JavaScript to evolve together and stay on par with each other with respect to features and capabilities.</p>
<h2 id="security-and-privacy">Security and Privacy</h2>
<h3 id="what-happens-to-my-data-when-i-use-native-client">What happens to my data when I use Native Client?</h3>
<p>Users can opt-in to sending usage statistics and crash information in Chrome, which includes usage statistics and crash information about Native Client. Crashes in your code won’t otherwise send your information to Google: Google counts the number of such crashes, but does so anonymously without sending your application’s data or its debug information.</p>
<p>For additional information about privacy and Chrome, see the <a href="https://www.google.com/chrome/intl/en/privacy.html" class="reference external">Google Chrome privacy policy</a> and the <a href="https://www.google.com/chrome/intl/en/eula_text.html" class="reference external">Google Chrome Terms of Service</a>.</p>
<h3 id="how-does-native-client-prevent-sandboxed-code-from-doing-bad-things">How does Native Client prevent sandboxed code from doing Bad Things?</h3>
<p>Native Client’s sandbox works by validating the untrusted code (the compiled Native Client module) before running it. The validator checks the following:</p>
<ul>
<li><strong>Data integrity:</strong> No loads or stores are permitted outside of the data sandbox. In particular this means that once loaded into memory, the binary is not writable. This is enforced by operating system protection mechanisms. While new instructions can be inserted at runtime to support things like JIT compilers, such instructions will be subject to runtime verification according to the following constraints before they are executed.</li>
<li><strong>No unsafe instructions:</strong> The validator ensures that the Native Client application does not contain any unsafe instructions. Examples of unsafe instructions are <code>syscall</code>, <code>int</code>, and <code>lds</code>.</li>
<li><strong>Control flow integrity:</strong> The validator ensures that all direct and indirect branches target a safe instruction.</li>
</ul>
<p>The beauty of the Native Client sandbox is in reducing “safe” code to a few simple rules that can be verified by a small trusted validator: the compiler isn’t trusted. The same applies to Portable Native Client where even the <code>.pexe</code> to <code>.nexe</code> translator, a simplified compiler backend, isn’t trusted: it is validated before executing, and so is its output.</p>
<p>In addition to static analysis of untrusted code, the Native Client runtime also includes an outer sandbox that mediates system calls. For more details about both sandboxes, see <a href="http://research.google.com/pubs/pub34913.html" class="reference external">Native Client: A Sandbox for Portable, Untrusted x86 Code</a> (PDF).</p>
<h3 id="how-does-google-know-that-the-safety-measures-in-native-client-are-sufficient">How does Google know that the safety measures in Native Client are sufficient?</h3>
<p>Google has taken several steps to ensure that Native Client’s security works, including:</p>
<ul>
<li>Open source, peer-reviewed papers describing the design.</li>
<li>A <a href="/docs/native-client/community/security-contest/index" class="reference internal"><em>security contest</em></a>.</li>
<li>Multiple internal and external security reviews.</li>
<li>The ongoing vigilance of our engineering and developer community.</li>
</ul>
<p>Google is committed to making Native Client safer than JavaScript and other popular browser technologies. If you have suggestions for security improvements, let the team know, by way of the <a href="https://groups.google.com/group/native-client-discuss" class="reference external">native-client-discuss</a> mailing list.</p>
<h2 id="development">Development</h2>
<h3 id="how-do-i-debug">How do I debug?</h3>
<p>Instructions on <a href="/docs/native-client/sdk/examples#debugging-the-sdk-examples" class="reference internal"><em>debugging the SDK examples</em></a> using GDB are available. You can also debug Native Client modules with some <a href="/docs/native-client/devguide/devcycle/debugging" class="reference internal"><em>alternative approaches</em></a>.</p>
<h3 id="how-do-i-build-x86-32-x86-64-or-arm-.nexes">How do I build x86-32, x86-64 or ARM <code>.nexes</code>?</h3>
<p>By default, the applications in the <code>/examples</code> folder create architecture-independent <code>.pexe</code> for Portable Native Client. To generate a <code>.nexe</code> targeting one specific architecture using the Native Client or Portable Native Client toolchains, see the <a href="/docs/native-client/devguide/devcycle/building" class="reference internal"><em>Building instructions</em></a>.</p>
<h3 id="how-can-my-web-application-determine-which-.nexe-to-load">How can my web application determine which <code>.nexe</code> to load?</h3>
<p>Your application does not need to make the decision of loading an x86-32, x86-64 or ARM <code>.nexe</code> explicitly—the Native Client runtime examines a manifest file (<code>.nmf</code>) to pick the right <code>.nexe</code> file for a given user. You can generate a manifest file using a Python script that’s included in the SDK (see the <code>Makefile</code> in any of the SDK examples for an illustration of how to do so). Your HTML file specifies the manifest filename in the <code>src</code> attribute of the <code>&lt;embed&gt;</code> tag. You can see the way the pieces fit together by examining the examples included in the SDK.</p>
<h3 id="is-it-possible-to-build-a-native-client-module-with-just-plain-c-not-c">Is it possible to build a Native Client module with just plain C (not C++)?</h3>
<p>Yes. See the <code>"Hello, World!"</code> in C example in the SDK under <code>examples/tutorial/using_ppapi_simple/</code>, or the Game of Life example under <code>examples/demo/life/life.c</code>.</p>
<h3 id="what-unix-system-calls-can-i-make-through-native-client">What UNIX system calls can I make through Native Client?</h3>
<p>Native Client doesn’t directly expose any system calls from the host OS because of the inherent security risks and because the resulting application would not be portable across operating systems. Instead, Native Client provides portable cross-OS abstractions wrapping or proxying OS functionality or emulating UNIX system calls. For example, Native Client provides an <code>mmap()</code> system call that behaves much like the standard UNIX <code>mmap()</code> system call.</p>
<h3 id="is-my-favorite-third-party-library-available-for-native-client">Is my favorite third-party library available for Native Client?</h3>
<p>Google has ported several third-party libraries to Native Client; such libraries are available in the <a href="https://chromium.googlesource.com/webports" class="reference external">webports</a> project. We encourage you to contribute libraries to webports, and/or to host your own ported libraries, and to let the team know about it on <a href="https://groups.google.com/group/native-client-discuss" class="reference external">native-client-discuss</a> when you do. You can also read through <a href="/docs/native-client/reference/ideas" class="reference internal"><em>contributor ideas</em></a> to find ideas of new projects to port.</p>
<h3 id="do-all-the-files-in-an-application-need-to-be-served-from-the-same-domain">Do all the files in an application need to be served from the same domain?</h3>
<p>The <code>.nmf</code>, and <code>.nexe</code> or <code>.pexe</code> files must either be served from the same origin as the embedding page or an origin that has been configured correctly using <a href="http://en.wikipedia.org/wiki/Cross-origin_resource_sharing" class="reference external">CORS</a>.</p>
<p>For applications installed from the Chrome Web Store the Web Store manifest must include the correct, verified domain of the embedding page.</p>
<h2 id="portability">Portability</h2>
<h3 id="do-i-have-to-do-anything-special-to-make-my-application-run-on-different-operating-systems">Do I have to do anything special to make my application run on different operating systems?</h3>
<p>No. Native Client and Portable Native Client applications run without modification on all supported operating systems.</p>
<p>However, to run on different instruction set architectures (such as x86-32, x86-64 or ARM), you currently have to either:</p>
<ul>
<li>Use Portable Native Client.</li>
<li>Build and supply a separate <code>.nexe</code> file for each architecture, and make them available on the Chrome Web Store. See <a href="/docs/native-client/devguide/devcycle/building" class="reference internal"><em>target architectures</em></a> for details about which <code>.nexe</code> files will run on which architectures.</li>
</ul>
<h3 id="how-easy-is-it-to-port-my-existing-native-code-to-native-client">How easy is it to port my existing native code to Native Client?</h3>
<p>In most cases you won’t have to rewrite much, if any, code. The Native Client-specific tools, such as <code>pnacl-clang++</code> or <code>x86_64-nacl-g++</code>, take care of most of the necessary changes. You may need to make some changes to your operating system calls and interactions with external devices to work with the web. Porting existing Linux libraries is generally straightforward, with large libraries often requiring no source change.</p>
<p>The following kinds of code may be more challenging to port:</p>
<ul>
<li>Code that does direct <a href="/docs/native-client/pepper_stable/cpp/classpp_1_1_t_c_p_socket/" class="reference external">TCP</a> or <a href="/docs/native-client/pepper_stable/cpp/classpp_1_1_u_d_p_socket/" class="reference external">UDP</a> networking. For security reasons these APIs are only available to <a href="/apps" class="reference external">Chrome apps</a> after asking for the appropriate permissions, not on the open web. Native Client is otherwise restricted to the networking APIs available in the browser. You may want to use to <a href="/docs/native-client/nacl_io/" class="reference external">nacl_io library</a> to use POSIX-like sockets.</li>
<li>Code that creates processes, including UNIX <code>fork</code>, won’t function as-is. However, threads are supported. You can nonetheless create new <code>&lt;embed&gt;</code> tags in your HTML page to launch new PNaCl processes. You can even use new <code>.pexe</code> files that your existing <code>.pexe</code> saved in a local filesystem. This is somewhat akin to <code>execve</code>, but the process management has to go through <code>postMessage</code> to JavaScript in order to create the new <code>&lt;embed&gt;</code>.</li>
<li>Code that needs to do local file I/O. Native Client is restricted to accessing URLs and to local storage in the browser (the Pepper <a href="/docs/native-client/devguide/coding/file-io" class="reference internal"><em>File IO API</em></a> has access to the same per-application storage that JavaScript has via Local Storage). HTML5 File System can be used, among others. For POSIX compatabiliy the Native Client SDK includes a library called nacl_io which allows the application to interact with all these types of files via standard POSIX I/O functions (e.g. <code>open</code> / <code>fopen</code> / <code>read</code> / <code>write</code> / …). See <a href="/docs/native-client/devguide/coding/nacl_io" class="reference internal"><em>Using NaCl I/O</em></a> for more details.</li>
</ul>
<h2 id="troubleshooting"><span id="faq-troubleshooting"></span>Troubleshooting</h2>
<h3 id="my-.pexe-isnt-loading-help">My <code>.pexe</code> isn’t loading, help!</h3>
<ul>
<li>You must use Google Chrome version 31 or greater for Portable Native Client. Find your version of chrome by opening <code>about:chrome</code>, and <a href="http://www.google.com/chrome/" class="reference external">update Chrome</a> if you are on an older version. If you’re already using a recent version, open <code>about:components</code> and “Check for update” for PNaCl. Note that on ChromeOS PNaCl is always up to date, whereas on other operating systems it updates shortly after Chrome updates.</li>
<li>A PNaCl <code>.pexe</code> must be compiled with pepper_31 SDK or higher. <a href="/docs/native-client/sdk/download#updating-bundles" class="reference internal"><em>Update your bundles</em></a> and make sure you’re using a version of Chrome that matches the SDK version.</li>
<li>Your application can verify that Portable Native Client is supported in JavaScript with <code>navigator.mimeTypes['application/x-pnacl'] !== undefined</code>. This is preferred over checking the Chrome version.</li>
</ul>
<h3 id="my-.nexe-files-never-finish-loading.-what-gives">My <code>.nexe</code> files never finish loading. What gives?</h3>
<p>Here are ways to resolve some common problems that can prevent loading:</p>
<ul>
<li>You must use Google Chrome version 14 or greater for Native Client.</li>
<li>If you haven’t already done so, enable the Native Client flag in Google Chrome. Type <code>about:flags</code> in the Chrome address bar, scroll down to “Native Client”, click the “Enable” link, scroll down to the bottom of the page, and click the “Relaunch Now” button (all browser windows will restart).</li>
<li>Verify that the Native Client plugin is enabled in Google Chrome. Type <code>about:plugins</code> in the Chrome address bar, scroll down to “Native Client”, and click the “Enable” link. (You do not need to relaunch Chrome after you enable the Native Client plugin).</li>
<li>Make sure that the <code>.nexe</code> files are being served from a web server. Native Client uses the same-origin security policy, which means that modules will not load in pages opened with the <code>file://</code> protocol. In particular, you can’t run the examples in the SDK by simply dragging the HTML files from the desktop into the browser. See <a href="/docs/native-client/devguide/devcycle/running" class="reference internal"><em>Running Native Client Applications</em></a> for instructions on how to run the httpd.py mini-server included in the SDK.</li>
<li>The <code>.nexe</code> files must have been compiled using SDK version 0.5 or greater.</li>
<li>You must load the correct <code>.nexe</code> file for your machine’s specific instruction set architecture (x86-32, x86-64 or ARM). You can ensure you’re loading the correct <code>.nexe</code> file by building a separate <code>.nexe</code> for each architecture, and using a <code>.nmf</code> manifest file to let the browser select the correct <code>.nexe</code> file. Note: the need to select a processor-specific <code>.nexe</code> goes away with Portable Native Client.</li>
<li>If things still aren’t working, <a href="/docs/native-client/help" class="reference internal"><em>ask for help</em></a>!</li>
</ul>
</body>
</html>
