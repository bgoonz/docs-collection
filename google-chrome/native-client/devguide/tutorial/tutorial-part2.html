<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>tutorial-part2</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
</head>
<body>
<p>—json {“title”:“C++ Tutorial: Getting Started (Part 2)”} —</p>
<p>{% include ‘partials/nacl-warning.njk’ %}</p>
<hr />
<ul>
<li><a href="#overview" id="id1" class="reference internal">Overview</a></li>
<li><p><a href="#using-the-native-client-sdk-build-system" id="id2" class="reference internal">Using the Native Client SDK build system</a></p>
<ul>
<li><a href="#simplifying-the-makefile" id="id3" class="reference internal">Simplifying the Makefile</a></li>
<li><a href="#choosing-valid-toolchains-and-including-common-mk" id="id4" class="reference internal">Choosing valid toolchains, and including common.mk</a></li>
<li><a href="#configuring-your-project" id="id5" class="reference internal">Configuring your project</a></li>
<li><a href="#build-macros" id="id6" class="reference internal">Build macros</a></li>
</ul></li>
<li><p><a href="#making-index-html-work-for-chrome-apps" id="id7" class="reference internal">Making index.html work for Chrome Apps</a></p>
<ul>
<li><a href="#csp-rules" id="id8" class="reference internal">CSP rules</a></li>
<li><a href="#making-index-html-csp-compliant" id="id9" class="reference internal">Making index.html CSP-compliant</a></li>
<li><a href="#making-index-html-support-different-toolchains-and-configurations" id="id10" class="reference internal">Making index.html support different toolchains and configurations</a></li>
</ul></li>
<li><p><a href="#sharing-common-code-with-common-js" id="id11" class="reference internal">Sharing common code with common.js</a></p>
<ul>
<li><a href="#loading-the-page-and-creating-the-module" id="id12" class="reference internal">Loading the page and creating the module</a></li>
</ul></li>
<li><a href="#example-specific-behavior-with-example-js" id="id13" class="reference internal">Example-specific behavior with example.js</a></li>
<li><p><a href="#compile-the-native-client-module-and-run-the-application-again" id="id14" class="reference internal">Compile the Native Client module and run the application again</a></p></li>
</ul>
<h2 id="overview">Overview</h2>
<p>This tutorial shows how to convert the finished PNaCl web application from <a href="/docs/native-client/devguide/tutorial/tutorial-part1" class="reference internal"><em>Part 1</em></a> to use the Native Client SDK build system and common JavaScript files. It also demonstrates some techniques to make your web application <a href="/apps/contentSecurityPolicy" class="reference external">Content Security Policy (CSP)-compliant</a>, which is necessary for <a href="/apps" class="reference external">Chrome Apps</a>.</p>
<p>Using the Native Client SDK build system makes it easy to build with all of the SDK toolchains, and switch between the Debug and Release configurations. It also simplifies the makefiles for your project, as we’ll see in the next section. Finally, it adds some useful commands for <a href="/docs/native-client/sdk/examples#running-the-sdk-examples" class="reference internal"><em>running</em></a> and <a href="/docs/native-client/sdk/examples#debugging-the-sdk-examples" class="reference internal"><em>debugging</em></a> your application.</p>
<p>The finished code for this example can be found in the <code>pepper_$(VERSION)/getting_started/part2</code> directory in the Native Client SDK download.</p>
<h2 id="using-the-native-client-sdk-build-system">Using the Native Client SDK build system</h2>
<p>This section describes how to use the SDK build system. To do so, we’ll make changes in the makefile. Because the makefile in part1 and part2 are so different, it is easier to start from scratch. Here is the contents of the new makefile. The following sections will describe it in more detail.</p>
<h3 id="simplifying-the-makefile">Simplifying the Makefile</h3>
<p>The makefile from part1 only supports one toolchain (PNaCl) and one configuration (Release). It also only supports one source file. It’s relatively simple, but if we want to add support for multiple toolchains, configurations, source files, or build steps, it would grow increasingly complex. The SDK build system uses a set of variables and macros to make this possible, without significantly increasing the complexity of the makefile.</p>
<p>Here is the new makefile, supporting three toolchains (PNaCl, Newlib NaCl, Glibc NaCl) and two configurations (Debug, Release).</p>
<pre><code>VALID_TOOLCHAINS := pnacl clang-newlib glibc

NACL_SDK_ROOT ?= $(abspath $(CURDIR)/../..)
include $(NACL_SDK_ROOT)/tools/common.mk

TARGET = part2
LIBS = ppapi_cpp ppapi

CFLAGS = -Wall
SOURCES = hello_tutorial.cc

# Build rules generated by macros from common.mk:

$(foreach src,$(SOURCES),$(eval $(call COMPILE_RULE,$(src),$(CFLAGS))))

# The PNaCl workflow uses both an unstripped and finalized/stripped binary.
# On NaCl, only produce a stripped binary for Release configs (not Debug).
ifneq (,$(or $(findstring pnacl,$(TOOLCHAIN)),$(findstring Release,$(CONFIG))))
$(eval $(call LINK_RULE,$(TARGET)_unstripped,$(SOURCES),$(LIBS),$(DEPS)))
$(eval $(call STRIP_RULE,$(TARGET),$(TARGET)_unstripped))
else
$(eval $(call LINK_RULE,$(TARGET),$(SOURCES),$(LIBS),$(DEPS)))
endif

$(eval $(call NMF_RULE,$(TARGET),))</code></pre>
<h3 id="choosing-valid-toolchains-and-including-common.mk">Choosing valid toolchains, and including common.mk</h3>
<p>The makefile begins by specifying the toolchains that are valid for this project. The Native Client SDK build system supports multi-toolchain projects for its examples and libraries, but generally you will choose one toolchain when you begin your project and never change it. Please see the <a href="/docs/native-client/overview#toolchains" class="reference internal"><em>Toolchains section of the Native Client overview</em></a> for more information.</p>
<p>For this example, we support the <code>pnacl</code>, <code>clang-newlib</code> and <code>glibc</code> toolchains.</p>
<pre><code>VALID_TOOLCHAINS := pnacl clang-newlib glibc</code></pre>
<p>Next, as a convenience, we specify where to find <code>NACL_SDK_ROOT</code>. Because this example is located in <code>pepper_$(VERSION)/getting_started/part2</code>, the root of the SDK is two directories up.</p>
<pre><code>NACL_SDK_ROOT ?= $(abspath $(CURDIR)/../..)</code></pre>
<p>In your own projects, you can use the absolute path to your installed SDK here. You can also override this default by setting the <code>NACL_SDK_ROOT</code> environment variable. See <a href="/docs/native-client/devguide/tutorial/tutorial-part1#tutorial-step-5" class="reference internal"><em>Step 5 of Part 1 of this tutorial</em></a> for more details.</p>
<p>Next, we include the file <code>tools/common.mk</code>. This file provides the functionality for the Native Client SDK build system, including new build rules to compile and link a project, which we’ll use below.</p>
<pre><code>include $(NACL_SDK_ROOT)/tools/common.mk</code></pre>
<h3 id="configuring-your-project">Configuring your project</h3>
<p>After including <code>tools/common.mk</code>, we configure the project by specifying its name, the sources and libraries it uses:</p>
<pre><code>TARGET = part2
LIBS = ppapi_cpp ppapi

CFLAGS = -Wall
SOURCES = hello_tutorial.cc</code></pre>
<p>These variable names are not required and not used by the SDK build system; they are only used in the rules described below. By convention, all SDK makefiles use the following variables:</p>
<p>TARGET<br />
The name of the project to build. This variable determines the name of the library or executable that will be generated. In the above example, we call the target <code>part2</code>, which will generate an executable called <code>part2.pexe</code> for PNaCl. For NaCl toolchains, the executable’s file name will be given a suffix for its architecture. For example, the ARM executable is called <code>part2_arm.nexe</code>.</p>
<p>LIBS<br />
A list of libraries that this executable needs to link against. The library search path is already set up to only look in the directory for the current toolchain and architecture. In this example, we link against <code>ppapi_cpp</code> and <code>ppapi</code>. <code>ppapi_cpp</code> is needed to use the <a href="/docs/native-client/pepper_stable/cpp/" class="reference external">Pepper C++ interface</a>. <code>ppapi</code> is needed for communicating with the browser.</p>
<p>CFLAGS<br />
A list of extra flags to pass to the compiler. In this example, we pass <code>-Wall</code>, which turns on all warnings.</p>
<p>LDFLAGS<br />
A list of additional flags to pass to the linker. This example does not need any special linker flags, so this variable is omitted.</p>
<p>SOURCES<br />
A list of C or C++ sources to compile, separated by spaces. If you have a long list of sources, it may be easier to read if you put each file on its own line, and use <code>\</code> as a line-continuation character. Here’s an example:</p>
<!-- -->
<pre><code>SOURCES = foo.cc \
          bar.cc \
          baz.cc \
          quux.cc</code></pre>
<h3 id="build-macros">Build macros</h3>
<p>For many projects, the following build macros do not need to be changed; they will use the variables we’ve defined above.</p>
<pre><code>$(foreach src,$(SOURCES),$(eval $(call COMPILE_RULE,$(src),$(CFLAGS))))

ifneq (,$(or $(findstring pnacl,$(TOOLCHAIN)),$(findstring Release,$(CONFIG))))
$(eval $(call LINK_RULE,$(TARGET)_unstripped,$(SOURCES),$(LIBS),$(DEPS)))
$(eval $(call STRIP_RULE,$(TARGET),$(TARGET)_unstripped))
else
$(eval $(call LINK_RULE,$(TARGET),$(SOURCES),$(LIBS),$(DEPS)))
endif

$(eval $(call NMF_RULE,$(TARGET),))</code></pre>
<p>The first line defines rules to compile each source in <code>SOURCES</code>, using the flags in <code>CFLAGS</code>:</p>
<pre><code>$(foreach src,$(SOURCES),$(eval $(call COMPILE_RULE,$(src),$(CFLAGS))))</code></pre>
<p>The next six lines define rules to link the object files into one or more executables. When <code>TOOLCHAIN</code> is <code>pnacl</code>, there is only one executable generated: in the example above, <code>part2.pexe</code>. When using a NaCl toolchain, there will be three executables generated, one for each architecture: in the example above, <code>part2_arm.nexe</code>, <code>part2_x86_32.nexe</code> and <code>part2_x86_64.nexe</code>.</p>
<p>When <code>CONFIG</code> is <code>Release</code>, each executable is also stripped to remove debug information and reduce the file size. Otherwise, when the <code>TOOLCHAIN</code> is <code>pnacl</code>, the workflow involves creating an unstripped binary for debugging and then finalizing it and stripping it for publishing.</p>
<pre><code>ifneq (,$(or $(findstring pnacl,$(TOOLCHAIN)),$(findstring Release,$(CONFIG))))
$(eval $(call LINK_RULE,$(TARGET)_unstripped,$(SOURCES),$(LIBS),$(DEPS)))
$(eval $(call STRIP_RULE,$(TARGET),$(TARGET)_unstripped))
else
$(eval $(call LINK_RULE,$(TARGET),$(SOURCES),$(LIBS),$(DEPS)))
endif</code></pre>
<p>Finally, the NMF rule generates a NaCl manifest file (<code>.nmf</code>) that references each executable generated in the previous step:</p>
<pre><code>$(eval $(call NMF_RULE,$(TARGET),))</code></pre>
<h2 id="making-index.html-work-for-chrome-apps">Making index.html work for Chrome Apps</h2>
<p>This section describes the changes necessary to make the HTML and JavaScript in part1 CSP-compliant. This is required if you want to build a <a href="/apps" class="reference external">Chrome App</a>, but is not necessary if you want to use PNaCl on the open web.</p>
<h3 id="csp-rules">CSP rules</h3>
<p><a href="/apps/contentSecurityPolicy#what" class="reference external">Chrome Apps CSP</a> restricts you from doing the following:</p>
<ul>
<li>You can’t use inline scripting in your Chrome App pages. The restriction bans both <code>&lt;script&gt;</code> blocks and event handlers (<code>&lt;button onclick="..."&gt;</code>).</li>
<li>You can’t reference any external resources in any of your app files (except for video and audio resources). You can’t embed external resources in an iframe.</li>
<li>You can’t use string-to-JavaScript methods like <code>eval()</code> and <code>new Function()</code>.</li>
</ul>
<h3 id="making-index.html-csp-compliant">Making index.html CSP-compliant</h3>
<p>To make our application CSP-compliant, we have to remove inline scripting. As described above, we can’t use inline <code>&lt;script&gt;</code> blocks or event handlers. This is easy to do—we’ll just reference some new files from our script tag, and remove all of our inlined scripts:</p>
<pre><code>&lt;head&gt;
  ...
  &lt;script type=&quot;text/javascript&quot; src=&quot;common.js&quot;&gt;&lt;/script&gt;
  &lt;script type=&quot;text/javascript&quot; src=&quot;example.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;</code></pre>
<p><code>common.js</code> has shared code used by all SDK examples, and is described later in this document. <code>example.js</code> is a script that has code specific to this example.</p>
<p>We also need to remove the inline event handler on the body tag:</p>
<pre><code>&lt;body onload=&quot;pageDidLoad()&quot;&gt;
...</code></pre>
<p>This logic is now handled by <code>common.js</code>.</p>
<h3 id="making-index.html-support-different-toolchains-and-configurations">Making index.html support different toolchains and configurations</h3>
<p>Finally, there are a few changes to <code>index.html</code> that are not necessary for CSP-compliance, but help make the SDK examples more generic.</p>
<p>First, we add some <a href="https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Using_data_attributes" class="reference external">data attributes</a> to the body element to specify the name, supported toolchains, supported configurations, and path to the <code>.nmf</code> file:</p>
<pre><code>&lt;body data-name=&quot;part2&quot;
    data-tools=&quot;clang-newlib glibc pnacl&quot;
    data-configs=&quot;Debug Release&quot;
    data-path=&quot;{tc}/{config}&quot;&gt;
...</code></pre>
<p><code>common.js</code> will read these data attributes to allow you to load the same example with different toolchains by changing the URL’s <a href="http://en.wikipedia.org/wiki/Query_string" class="reference external">query string</a>. For example, you can load the glibc Debug version of this example by navigating to <code>index.html?tc=glibc&amp;config=Debug</code>. Path URI’s such as <code>../</code>, for example do not work for either the data-path parameter or its corresponding query string.</p>
<p>Next, we remove the <code>embed</code> element that is described in HTML. This will be automatically added for us by <code>common.js</code>, based on the current toolchain/configuration combination:</p>
<pre><code>&lt;!--
Just as in part1, the &lt;embed&gt; element will be wrapped inside the &lt;div&gt;
element with the id &quot;listener&quot;. In part1, the embed was specified in HTML,
here the common.js module creates a new &lt;embed&gt; element and adds it to the
&lt;div&gt; for us.
--&gt;
&lt;div id=&quot;listener&quot;&gt;&lt;/div&gt;</code></pre>
<h2 id="sharing-common-code-with-common.js">Sharing common code with common.js</h2>
<p><code>common.js</code> contains JavaScript code that each example uses to create a NaCl module, handle messages from that module and other common tasks like displaying the module load status and logging messages. Explaining all of <code>common.js</code> is outside the scope of this document, but please look at the documentation in that file for more information.</p>
<h3 id="loading-the-page-and-creating-the-module">Loading the page and creating the module</h3>
<p>Since we’ve added <code>&lt;script&gt;</code> tags for <code>common.js</code> and <code>example.js</code> to the <code>head</code> element, they will be loaded and executed before the rest of the document has been parsed. As a result, we have to wait for the page to finish loading before we try to create the embed element and add it to the page.</p>
<p>We can do that by calling <code>addEventListener</code> and listening for the <code>DOMContentLoaded</code> event:</p>
<pre><code>// Listen for the DOM content to be loaded. This event is fired when parsing of
// the page&#39;s document has finished.
document.addEventListener(&#39;DOMContentLoaded&#39;, function() {
  ...
});</code></pre>
<p>Inside this function, we parse the URL query string, and compare that to the data attributes:</p>
<pre><code>// From https://developer.mozilla.org/en-US/docs/DOM/window.location
var searchVars = {};
if (window.location.search.length &gt; 1) {
  var pairs = window.location.search.substr(1).split(&#39;&amp;&#39;);
  for (var key_ix = 0; key_ix &lt; pairs.length; key_ix++) {
    var keyValue = pairs[key_ix].split(&#39;=&#39;);
    searchVars[unescape(keyValue[0])] =
        keyValue.length &gt; 1 ? unescape(keyValue[1]) : &#39;&#39;;
  }
}

...

var toolchains = body.dataset.tools.split(&#39; &#39;);
var configs = body.dataset.configs.split(&#39; &#39;);

...

var tc = toolchains.indexOf(searchVars.tc) !== -1 ?
    searchVars.tc : toolchains[0];

// If the config value is included in the search vars, use that.
// Otherwise default to Release if it is valid, or the first value if
// Release is not valid.
if (configs.indexOf(searchVars.config) !== -1)
  var config = searchVars.config;
else if (configs.indexOf(&#39;Release&#39;) !== -1)
  var config = &#39;Release&#39;;
else
  var config = configs[0];</code></pre>
<p>Then <code>domContentLoaded</code> is called, which performs some checks to see if the browser supports Native Client, then creates the NaCl module.</p>
<pre><code>function domContentLoaded(name, tool, path, width, height, attrs) {
  updateStatus(&#39;Page loaded.&#39;);
  if (!browserSupportsNaCl(tool)) {
    updateStatus(
        &#39;Browser does not support NaCl (&#39; + tool + &#39;), or NaCl is disabled&#39;);
  } else if (common.naclModule == null) {
    updateStatus(&#39;Creating embed: &#39; + tool);

    // We use a non-zero sized embed to give Chrome space to place the bad
    // plug-in graphic, if there is a problem.
    width = typeof width !== &#39;undefined&#39; ? width : 200;
    height = typeof height !== &#39;undefined&#39; ? height : 200;
    attachDefaultListeners();
    createNaClModule(name, tool, path, width, height, attrs);
  } else {
    // It&#39;s possible that the Native Client module onload event fired
    // before the page&#39;s onload event.  In this case, the status message
    // will reflect &#39;SUCCESS&#39;, but won&#39;t be displayed.  This call will
    // display the current message.
    updateStatus(&#39;Waiting.&#39;);
  }
}</code></pre>
<p><code>attachDefaultListeners</code> is added before the creation of the module, to make sure that no messages are lost. Note that <code>window.attachListeners</code> is also called; this is the way that <code>common.js</code> allows each example to configure itself differently. If an example defines the <code>attachListeners</code> function, it will be called by <code>common.js</code>.</p>
<pre><code>function attachDefaultListeners() {
  var listenerDiv = document.getElementById(&#39;listener&#39;);
  listenerDiv.addEventListener(&#39;load&#39;, moduleDidLoad, true);
  listenerDiv.addEventListener(&#39;message&#39;, handleMessage, true);
  listenerDiv.addEventListener(&#39;crash&#39;, handleCrash, true);
  if (typeof window.attachListeners !== &#39;undefined&#39;) {
    window.attachListeners();
  }
}</code></pre>
<p>Finally, <code>createNaClModule</code> actually creates the <code>embed</code>, and appends it as a child of the element with id <code>listener</code>:</p>
<pre><code>function createNaClModule(name, tool, path, width, height, attrs) {
  var moduleEl = document.createElement(&#39;embed&#39;);
  moduleEl.setAttribute(&#39;name&#39;, &#39;nacl_module&#39;);
  moduleEl.setAttribute(&#39;id&#39;, &#39;nacl_module&#39;);
  moduleEl.setAttribute(&#39;width&#39;, width);
  moduleEl.setAttribute(&#39;height&#39;, height);
  moduleEl.setAttribute(&#39;path&#39;, path);
  moduleEl.setAttribute(&#39;src&#39;, path + &#39;/&#39; + name + &#39;.nmf&#39;);

  ...

  var mimetype = mimeTypeForTool(tool);
  moduleEl.setAttribute(&#39;type&#39;, mimetype);

  var listenerDiv = document.getElementById(&#39;listener&#39;);
  listenerDiv.appendChild(moduleEl);
  ...
}</code></pre>
<p>When the module finishes loading, it will dispatch a <code>load</code> event, and the event listener function that was registered above (<code>moduleDidLoad</code>) will be called. Note that <code>common.js</code> allows each example to define a <code>window.moduleDidLoad</code> function, that will be called here as well.</p>
<pre><code>function moduleDidLoad() {
  common.naclModule = document.getElementById(&#39;nacl_module&#39;);
  updateStatus(&#39;RUNNING&#39;);

  if (typeof window.moduleDidLoad !== &#39;undefined&#39;) {
    window.moduleDidLoad();
  }
}</code></pre>
<h2 id="example-specific-behavior-with-example.js">Example-specific behavior with example.js</h2>
<p>As described in the previous section, <code>common.js</code> will call certain functions during the module loading process. This example only needs to respond to two: <code>moduleDidLoad</code> and <code>handleMessage</code>.</p>
<pre><code>// This function is called by common.js when the NaCl module is
// loaded.
function moduleDidLoad() {
  // Once we load, hide the plugin. In this example, we don&#39;t display anything
  // in the plugin, so it is fine to hide it.
  common.hideModule();

  // After the NaCl module has loaded, common.naclModule is a reference to the
  // NaCl module&#39;s &lt;embed&gt; element.
  //
  // postMessage sends a message to it.
  common.naclModule.postMessage(&#39;hello&#39;);
}

// This function is called by common.js when a message is received from the
// NaCl module.
function handleMessage(message) {
  var logEl = document.getElementById(&#39;log&#39;);
  logEl.textContent += message.data;
}</code></pre>
<h2 id="compile-the-native-client-module-and-run-the-application-again">Compile the Native Client module and run the application again</h2>
<ol type="1">
<li><p>Compile the Native Client module by running the <code>make</code> command again.</p></li>
<li><p>Start the SDK web server by running <code>make server</code>.</p></li>
<li><p>Re-run the application by reloading <code>http://localhost:5103/part2</code> in Chrome.</p>
<p>After Chrome loads the Native Client module, you should see the message sent from the module.</p></li>
</ol>
</body>
</html>
