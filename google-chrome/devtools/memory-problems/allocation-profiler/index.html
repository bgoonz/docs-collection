<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="dcterms.date" content="2015-04-13" />
  <title>How to Use the Allocation Profiler Tool</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">How to Use the Allocation Profiler Tool</h1>
<p class="date">2015-04-13</p>
</header>
<p>Use the allocation profiler tool to find objects that aren’t being properly garbage collected, and continue to retain memory.</p>
<h2 id="how-the-tool-works-how_the_tool_works">How the tool works {: #how_the_tool_works }</h2>
<p>The <strong>allocation profiler</strong> combines the detailed snapshot information of the <a href="/docs/devtools/memory-problems/heap-snapshots">heap profiler</a> with the incremental updating and tracking of the <a href="/docs/devtools/evaluate-performance/">Timeline panel</a>. Similar to these tools, tracking objects’ heap allocation involves starting a recording, performing a sequence of actions, then stop the recording for analysis.</p>
<p>The tool takes heap snapshots periodically throughout the recording (as frequently as every 50 ms!) and one final snapshot at the end of the recording.</p>
<p>{% Img src=“image/admin/eQkiSycjOtiM8pGHNCFH.png”, alt=“Allocation profiler”, width=“620”, height=“474” %}</p>
<p>{% Aside %}</p>
<p><strong>Note:</strong> The number after the @ is an object ID that persists among multiple snapshots taken. This allows precise comparison between heap states. Displaying an object’s address makes no sense, as objects are moved during garbage collections.</p>
<p>{% endAside %}</p>
<h2 id="enable-allocation-profiler-enable_allocation_profiler">Enable allocation profiler {: #enable_allocation_profiler }</h2>
<p>To begin using the allocation profiler:</p>
<ol type="1">
<li>Make sure you have the latest <a href="https://www.google.com/intl/en/chrome/browser/canary.html">Chrome Canary</a>.</li>
<li>Open the Developer Tools and click on the gear icon in the lower right.</li>
<li>Now, open the Profiler panel, you should see a profile called “Record Heap Allocations”</li>
</ol>
<p>{% Img src=“image/admin/f5LWyjVhPWDTihZsMBRU.png”, alt=“Record heap allocations profiler”, width=“800”, height=“444” %}</p>
<h2 id="read-a-heap-allocation-profile-read_a_heap_allocation_profile">Read a heap allocation profile {: #read_a_heap_allocation_profile }</h2>
<p>The heap allocation profile shows where objects are being created and identifies the retaining path. In the snapshot below, the bars at the top indicate when new objects are found in the heap.</p>
<p>The height of each bar corresponds to the size of the recently allocated objects, and the color of the bars indicate whether or not those objects are still live in the final heap snapshot. Blue bars indicate objects that are still live at the end of the timeline, Gray bars indicate objects that were allocated during the timeline, but have since been garbage collected:</p>
<p>{% Img src=“image/admin/nSsCYXi2rkMk2SBaH9Gj.png”, alt=“Allocation profiler snapshot”, width=“800”, height=“416” %}</p>
<p>In the snapshot below, an action was performed 10 times. The sample program caches five objects, so the last five blue bars are expected. But the leftmost blue bar indicates a potential problem.</p>
<p>You can then use the sliders in the timeline above to zoom in on that particular snapshot and see the objects that were recently allocated at that point:</p>
<p>{% Img src=“image/admin/6VYMytA90PywfFglF7mu.png”, alt=“Zoom in on snapshot”, width=“800”, height=“416” %}</p>
<p>Clicking on a specific object in the heap will show its retaining tree in the bottom portion of the heap snapshot. Examining the retaining path to the object should give you enough information to understand why the object was not collected, and you can make the necessary code changes to remove the unnecessary reference.</p>
<h2 id="view-memory-allocation-by-function-allocation-profiler">View memory allocation by function {: #allocation-profiler }</h2>
<p>You can also view memory allocation by JavaScript function. See <a href="/docs/devtools/memory-problems/#allocation-profile">Investigate memory allocation by function</a> for more information.</p>
</body>
</html>
