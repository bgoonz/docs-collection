<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>index</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
</head>
<body>
<h2 id="overview">Overview</h2>
<p>An extension can register itself as a speech engine. By doing so, it can intercept some or all calls to functions such as <a href="/docs/extensions/reference/tts/#method-speak"><code>tts.speak</code></a> and <a href="/docs/extensions/reference/tts/#method-stop"><code>tts.stop</code></a> and provide an alternate implementation. Extensions are free to use any available web technology to provide speech, including streaming audio from a server, HTML5 audio, Native Client, or Flash. An extension could even do something different with the utterances, like display closed captions in a pop-up window or send them as log messages to a remote server.</p>
<h2 id="manifest">Manifest</h2>
<p>To implement a TTS engine, an extension must declare the “ttsEngine” permission and then declare all voices it provides in the extension manifest, like this:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode json"><code class="sourceCode json"><a class="sourceLine" id="cb1-1" title="1"><span class="fu">{</span></a>
<a class="sourceLine" id="cb1-2" title="2">  <span class="dt">&quot;name&quot;</span><span class="fu">:</span> <span class="st">&quot;My TTS Engine&quot;</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb1-3" title="3">  <span class="dt">&quot;version&quot;</span><span class="fu">:</span> <span class="st">&quot;1.0&quot;</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb1-4" title="4">  <span class="dt">&quot;permissions&quot;</span><span class="fu">:</span> <span class="ot">[</span><span class="st">&quot;ttsEngine&quot;</span><span class="ot">]</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb1-5" title="5">  <span class="dt">&quot;tts_engine&quot;</span><span class="fu">:</span> <span class="fu">{</span></a>
<a class="sourceLine" id="cb1-6" title="6">    <span class="dt">&quot;voices&quot;</span><span class="fu">:</span> <span class="ot">[</span></a>
<a class="sourceLine" id="cb1-7" title="7">      <span class="fu">{</span></a>
<a class="sourceLine" id="cb1-8" title="8">        <span class="dt">&quot;voice_name&quot;</span><span class="fu">:</span> <span class="st">&quot;Alice&quot;</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb1-9" title="9">        <span class="dt">&quot;lang&quot;</span><span class="fu">:</span> <span class="st">&quot;en-US&quot;</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb1-10" title="10">        <span class="dt">&quot;event_types&quot;</span><span class="fu">:</span> <span class="ot">[</span><span class="st">&quot;start&quot;</span><span class="ot">,</span> <span class="st">&quot;marker&quot;</span><span class="ot">,</span> <span class="st">&quot;end&quot;</span><span class="ot">]</span></a>
<a class="sourceLine" id="cb1-11" title="11">      <span class="fu">}</span><span class="ot">,</span></a>
<a class="sourceLine" id="cb1-12" title="12">      <span class="fu">{</span></a>
<a class="sourceLine" id="cb1-13" title="13">        <span class="dt">&quot;voice_name&quot;</span><span class="fu">:</span> <span class="st">&quot;Pat&quot;</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb1-14" title="14">        <span class="dt">&quot;lang&quot;</span><span class="fu">:</span> <span class="st">&quot;en-US&quot;</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb1-15" title="15">        <span class="dt">&quot;event_types&quot;</span><span class="fu">:</span> <span class="ot">[</span><span class="st">&quot;end&quot;</span><span class="ot">]</span></a>
<a class="sourceLine" id="cb1-16" title="16">      <span class="fu">}</span></a>
<a class="sourceLine" id="cb1-17" title="17">    <span class="ot">]</span></a>
<a class="sourceLine" id="cb1-18" title="18">  <span class="fu">},</span></a>
<a class="sourceLine" id="cb1-19" title="19">  <span class="dt">&quot;background&quot;</span><span class="fu">:</span> <span class="fu">{</span></a>
<a class="sourceLine" id="cb1-20" title="20">    <span class="dt">&quot;page&quot;</span><span class="fu">:</span> <span class="st">&quot;background.html&quot;</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb1-21" title="21">    <span class="dt">&quot;persistent&quot;</span><span class="fu">:</span> <span class="kw">false</span></a>
<a class="sourceLine" id="cb1-22" title="22">  <span class="fu">}</span></a>
<a class="sourceLine" id="cb1-23" title="23"><span class="fu">}</span></a></code></pre></div>
<p>An extension can specify any number of voices.</p>
<p>The <code>voice_name</code> parameter is required. The name should be descriptive enough that it identifies the name of the voice and the engine used. In the unlikely event that two extensions register voices with the same name, a client can specify the ID of the extension that should do the synthesis.</p>
<p>The <code>lang</code> parameter is optional, but highly recommended. Almost always, a voice can synthesize speech in just a single language. When an engine supports more than one language, it can easily register a separate voice for each language. Under rare circumstances where a single voice can handle more than one language, it’s easiest to just list two separate voices and handle them using the same logic internally. However, if you want to create a voice that will handle utterances in any language, leave out the <code>lang</code> parameter from your extension’s manifest.</p>
<p>Finally, the <code>event_types</code> parameter is required if the engine can send events to update the client on the progress of speech synthesis. At a minimum, supporting the <code>'end'</code> event type to indicate when speech is finished is highly recommended, otherwise Chrome cannot schedule queued utterances.</p>
<p>Once loaded, an extension can replace the list of declared voices by calling <code>chrome.ttsEngine.updateVoices</code>. (Note that the parameters used in the programatic call to <code>updateVoices</code> are in camel case: e.g., <code>voiceName</code>, unlike the manifest file which uses <code>voice_name</code>.)</p>
<p>{% Aside %}</p>
<p><strong>Note:</strong> If your TTS engine does not support the <code>'end'</code> event type, Chrome cannot queue utterances because it has no way of knowing when your utterance has finished. To help mitigate this, Chrome passes an additional boolean <code>enqueue</code> option to your engine’s onSpeak handler, giving you the option of implementing your own queueing. This is discouraged because then clients are unable to queue utterances that should get spoken by different speech engines.</p>
<p>{% endAside %}</p>
<p>The possible event types that you can send correspond to the event types that the <code>speak()</code> method receives:</p>
<ul>
<li><code>'start'</code>: The engine has started speaking the utterance.</li>
<li><code>'word'</code>: A word boundary was reached. Use <code>event.charIndex</code> to determine the current speech position.</li>
<li><code>'sentence'</code>: A sentence boundary was reached. Use <code>event.charIndex</code> to determine the current speech position.</li>
<li><code>'marker'</code>: An SSML marker was reached. Use <code>event.charIndex</code> to determine the current speech position.</li>
<li><code>'end'</code>: The engine has finished speaking the utterance.</li>
<li><code>'error'</code>: An engine-specific error occurred and this utterance cannot be spoken. Pass more information in <code>event.errorMessage</code>.</li>
</ul>
<p>The <code>'interrupted'</code> and <code>'cancelled'</code> events are not sent by the speech engine; they are generated automatically by Chrome.</p>
<p>Text-to-speech clients can get the voice information from your extension’s manifest by calling <a href="/docs/extensions/reference/tts/#method-getVoices"><code>tts.getVoices</code></a>, assuming you’ve registered speech event listeners as described below.</p>
<h2 id="handling-speech-events">Handling speech events</h2>
<p>To generate speech at the request of clients, your extension must register listeners for both <code>onSpeak</code> and <code>onStop</code>, like this:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">const</span> speakListener <span class="op">=</span> (utterance<span class="op">,</span> options<span class="op">,</span> sendTtsEvent) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb2-2" title="2">  <span class="at">sendTtsEvent</span>(<span class="op">{</span><span class="dt">type</span><span class="op">:</span> <span class="st">&#39;start&#39;</span><span class="op">,</span> <span class="dt">charIndex</span><span class="op">:</span> <span class="dv">0</span><span class="op">}</span>)</a>
<a class="sourceLine" id="cb2-3" title="3"></a>
<a class="sourceLine" id="cb2-4" title="4">  <span class="co">// (start speaking)</span></a>
<a class="sourceLine" id="cb2-5" title="5"></a>
<a class="sourceLine" id="cb2-6" title="6">  <span class="at">sendTtsEvent</span>(<span class="op">{</span><span class="dt">type</span><span class="op">:</span> <span class="st">&#39;end&#39;</span><span class="op">,</span> <span class="dt">charIndex</span><span class="op">:</span> <span class="va">utterance</span>.<span class="at">length</span><span class="op">}</span>)</a>
<a class="sourceLine" id="cb2-7" title="7"><span class="op">};</span></a>
<a class="sourceLine" id="cb2-8" title="8"></a>
<a class="sourceLine" id="cb2-9" title="9"><span class="kw">const</span> stopListener <span class="op">=</span> () <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb2-10" title="10">  <span class="co">// (stop all speech)</span></a>
<a class="sourceLine" id="cb2-11" title="11"><span class="op">};</span></a>
<a class="sourceLine" id="cb2-12" title="12"></a>
<a class="sourceLine" id="cb2-13" title="13"><span class="va">chrome</span>.<span class="va">ttsEngine</span>.<span class="va">onSpeak</span>.<span class="at">addListener</span>(speakListener)<span class="op">;</span></a>
<a class="sourceLine" id="cb2-14" title="14"><span class="va">chrome</span>.<span class="va">ttsEngine</span>.<span class="va">onStop</span>.<span class="at">addListener</span>(stopListener)<span class="op">;</span></a></code></pre></div>
<p>{% Aside ‘warning’ %}</p>
<p><strong>Important:</strong> If your extension does not register listeners for both <code>onSpeak</code> and <code>onStop</code>, it will not intercept any speech calls, regardless of what is in the manifest.</p>
<p>{% endAside %}</p>
<p>The decision of whether or not to send a given speech request to an extension is based solely on whether the extension supports the given voice parameters in its manifest and has registered listeners for <code>onSpeak</code> and <code>onStop</code>. In other words, there’s no way for an extension to receive a speech request and dynamically decide whether to handle it.</p>
</body>
</html>
